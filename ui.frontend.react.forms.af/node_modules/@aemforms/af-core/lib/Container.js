"use strict";
/*
 * Copyright 2022 Adobe, Inc.
 *
 * Your access and use of this software is governed by the Adobe Customer Feedback Program Terms and Conditions or other Beta License Agreement signed by your employer and Adobe, Inc.. This software is NOT open source and may not be used without one of the foregoing licenses. Even with a foregoing license, your access and use of this file is limited to the earlier of (a) 180 days, (b) general availability of the product(s) which utilize this software (i.e. AEM Forms), (c) January 1, 2023, (d) Adobe providing notice to you that you may no longer use the software or that your beta trial has otherwise ended.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL ADOBE NOR ITS THIRD PARTY PROVIDERS AND PARTNERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 */
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const JsonUtils_1 = require("./utils/JsonUtils");
const Scriptable_1 = __importDefault(require("./Scriptable"));
const controller_1 = require("./controller");
const DataGroup_1 = __importDefault(require("./data/DataGroup"));
/**
 * Defines a generic container class which any form container should extend from.
 * @typeparam T type of the node which extends {@link ContainerJson} and {@link RulesJson}
 */
class Container extends Scriptable_1.default {
    constructor() {
        super(...arguments);
        this._children = [];
        this._itemTemplate = null;
    }
    /**
     * @private
     */
    ruleNodeReference() {
        return this._childrenReference;
    }
    //todo : this should not be public
    get items() {
        return this._children;
    }
    set maxItems(m) {
        this._jsonModel.maxItems = m;
        const minItems = this._jsonModel.minItems || 1;
        const itemsLength = this._children.length;
        const items2Remove = Math.min(itemsLength - m, itemsLength - minItems);
        if (items2Remove > 0) {
            for (let i = 0; i < items2Remove; i++) {
                this.getDataNode().$removeDataNode(m + i);
                this._childrenReference.pop();
            }
            const elems = this._children.splice(m, items2Remove);
            this.notifyDependents((0, controller_1.propertyChange)('items', elems, null));
        }
    }
    /**
     * returns whether the items in the Panel can repeat or not
     */
    hasDynamicItems() {
        return this._itemTemplate != null;
    }
    get isContainer() {
        return true;
    }
    /**
     * Returns the current container state
     */
    getState() {
        return Object.assign(Object.assign({}, this._jsonModel), { ':type': this[':type'], items: this._children.map(x => {
                return Object.assign({}, x.getState());
            }) });
    }
    _addChildToRuleNode(child, options) {
        // eslint-disable-next-line @typescript-eslint/no-this-alias
        const self = this;
        const { parent = this } = options;
        //the child has not been added to the array, hence using the length as new index
        // this means unnamed panel inside repeatable named parent // this is an edge case, handling it gracefully
        // todo: rules don't work inside repeatable array
        const name = parent.type == 'array' ? parent._children.length + '' : child.name || '';
        if (name.length > 0) {
            Object.defineProperty(parent._childrenReference, name, {
                get: () => {
                    if (child.isContainer && child.hasDynamicItems()) {
                        self.ruleEngine.trackDependency(child); //accessing dynamic panel directly
                    }
                    if (self.hasDynamicItems()) {
                        self.ruleEngine.trackDependency(self); //accessing a child of dynamic panel
                        if (this._children[name] !== undefined) { // pop function calls this getter in order to return the item
                            return this._children[name].getRuleNode();
                        }
                    }
                    else {
                        return child.getRuleNode();
                    }
                },
                configurable: true,
                enumerable: true
            });
        }
    }
    _addChild(itemJson, index) {
        // get first non transparent parent
        // eslint-disable-next-line @typescript-eslint/no-this-alias
        let nonTransparentParent = this;
        while (nonTransparentParent != null && nonTransparentParent.isTransparent()) {
            // @ts-ignore
            nonTransparentParent = nonTransparentParent.parent;
        }
        if (typeof index !== 'number' || index > nonTransparentParent._children.length) {
            index = nonTransparentParent === null || nonTransparentParent === void 0 ? void 0 : nonTransparentParent._children.length;
        }
        const itemTemplate = Object.assign({ index }, (0, JsonUtils_1.deepClone)(itemJson));
        //@ts-ignore
        const retVal = this._createChild(itemTemplate, { parent: nonTransparentParent, index: index });
        this._addChildToRuleNode(retVal, { parent: nonTransparentParent });
        if (index === (nonTransparentParent === null || nonTransparentParent === void 0 ? void 0 : nonTransparentParent._children.length)) {
            nonTransparentParent === null || nonTransparentParent === void 0 ? void 0 : nonTransparentParent._children.push(retVal);
            //(this.getDataNode() as DataGroup).$addDataNode(index);
        }
        else {
            // @ts-ignore
            nonTransparentParent === null || nonTransparentParent === void 0 ? void 0 : nonTransparentParent._children.splice(index, 0, retVal);
            //(this.getDataNode() as DataGroup).$addDataNode();
        }
        retVal._initialize();
        return retVal;
    }
    indexOf(f) {
        return this._children.indexOf(f);
    }
    /**
     * @private
     */
    defaultDataModel(name) {
        const type = this._jsonModel.type || undefined;
        if (type === undefined) {
            return undefined;
        }
        else {
            const instance = type === 'array' ? [] : {};
            return new DataGroup_1.default(name, instance, type);
        }
    }
    /**
     * @private
     */
    _initialize() {
        super._initialize();
        const items = this._jsonModel.items;
        this._jsonModel.items = [];
        this._childrenReference = this._jsonModel.type == 'array' ? [] : {};
        if (this._jsonModel.type == 'array' && items.length === 1 && this.getDataNode() != null) {
            this._itemTemplate = (0, JsonUtils_1.deepClone)(items[0]);
            if (typeof (this._jsonModel.minItems) !== 'number') {
                this._jsonModel.minItems = 0;
            }
            if (typeof (this._jsonModel.maxItems) !== 'number') {
                this._jsonModel.maxItems = -1;
            }
            if (typeof (this._jsonModel.initialItems) !== 'number') {
                this._jsonModel.initialItems = Math.max(1, this._jsonModel.minItems);
            }
            for (let i = 0; i < this._jsonModel.initialItems; i++) {
                //@ts-ignore
                this._addChild(this._itemTemplate);
            }
        }
        else if (items.length > 0) {
            items.forEach((item) => {
                this._addChild(item);
            });
            this._jsonModel.minItems = this._children.length;
            this._jsonModel.maxItems = this._children.length;
            this._jsonModel.initialItems = this._children.length;
        }
        this.setupRuleNode();
    }
    /**
     * @private
     */
    addItem(action) {
        if (action.type === 'addItem' && this._itemTemplate != null) {
            //@ts-ignore
            if ((this._jsonModel.maxItems === -1) || (this._children.length < this._jsonModel.maxItems)) {
                const retVal = this._addChild(this._itemTemplate, action.payload);
                this.notifyDependents((0, controller_1.propertyChange)('items', retVal.getState, null));
                retVal.dispatch(new controller_1.Initialize());
                retVal.dispatch(new controller_1.ExecuteRule());
            }
        }
    }
    /**
     * @private
     */
    removeItem(action) {
        if (action.type === 'removeItem' && this._itemTemplate != null) {
            const index = action.payload || this._children.length - 1;
            const state = this._children[index].getState();
            //@ts-ignore
            if (this._children.length > this._jsonModel.minItems) {
                // clear child
                //remove field
                this._childrenReference.pop();
                this._children.splice(index, 1);
                this.getDataNode().$removeDataNode(index);
                for (let i = index; i < this._children.length; i++) {
                    this._children[i].dispatch(new controller_1.ExecuteRule());
                }
                this.notifyDependents((0, controller_1.propertyChange)('items', null, state));
            }
        }
    }
    /**
     * @private
     */
    queueEvent(action) {
        var _a;
        super.queueEvent(action);
        if ((_a = action.metadata) === null || _a === void 0 ? void 0 : _a.dispatch) {
            this.items.forEach(x => {
                //@ts-ignore
                x.queueEvent(action);
            });
        }
    }
    validate() {
        return this.items.flatMap(x => {
            return x.validate();
        }).filter(x => x.fieldName !== '');
    }
    /**
     * @private
     */
    dispatch(action) {
        var _a;
        super.dispatch(action);
        if ((_a = action.metadata) === null || _a === void 0 ? void 0 : _a.dispatch) {
            this.items.forEach(x => {
                x.dispatch(action);
            });
        }
    }
    /**
     * @private
     */
    importData(contextualDataModel) {
        this._bindToDataModel(contextualDataModel);
        this.syncDataAndFormModel(this.getDataNode());
    }
    /**
     * prefill the form with data on the given element
     * @param dataModel
     * @param contextualDataModel
     * @param operation
     * @private
     */
    syncDataAndFormModel(contextualDataModel) {
        if ((contextualDataModel === null || contextualDataModel === void 0 ? void 0 : contextualDataModel.$type) === 'array' && this._itemTemplate != null) {
            const dataLength = contextualDataModel === null || contextualDataModel === void 0 ? void 0 : contextualDataModel.$value.length;
            const itemsLength = this._children.length;
            const maxItems = this._jsonModel.maxItems === -1 ? dataLength : this._jsonModel.maxItems;
            const minItems = this._jsonModel.minItems;
            //@ts-ignore
            let items2Add = Math.min(dataLength - itemsLength, maxItems - itemsLength);
            //@ts-ignore
            const items2Remove = Math.min(itemsLength - dataLength, itemsLength - minItems);
            while (items2Add > 0) {
                items2Add--;
                this._addChild(this._itemTemplate);
            }
            if (items2Remove > 0) {
                this._children.splice(dataLength, items2Remove);
                for (let i = 0; i < items2Remove; i++) {
                    this._childrenReference.pop();
                }
            }
        }
        this._children.forEach(x => {
            x.importData(contextualDataModel);
        });
    }
}
exports.default = Container;
