"use strict";
/*
 * Copyright 2022 Adobe, Inc.
 *
 * Your access and use of this software is governed by the Adobe Customer Feedback Program Terms and Conditions or other Beta License Agreement signed by your employer and Adobe, Inc.. This software is NOT open source and may not be used without one of the foregoing licenses. Even with a foregoing license, your access and use of this file is limited to the earlier of (a) 180 days, (b) general availability of the product(s) which utilize this software (i.e. AEM Forms), (c) January 1, 2023, (d) Adobe providing notice to you that you may no longer use the software or that your beta trial has otherwise ended.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL ADOBE NOR ITS THIRD PARTY PROVIDERS AND PARTNERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 */
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const Controller_1 = require("./controller/Controller");
const Field_1 = __importDefault(require("./Field"));
const FormUtils_1 = require("./utils/FormUtils");
const ValidationUtils_1 = require("./utils/ValidationUtils");
const FileObject_1 = require("./FileObject");
function addNameToDataURL(dataURL, name) {
    return dataURL.replace(';base64', `;name=${encodeURIComponent(name)};base64`);
}
function processFiles(files) {
    return Promise.all([].map.call(files, processFile));
}
function processFile(file) {
    return __awaiter(this, void 0, void 0, function* () {
        const { name, size, mediaType } = file;
        // eslint-disable-next-line @typescript-eslint/no-unused-vars
        const fileObj = yield new Promise((resolve, reject) => {
            const reader = new FileReader();
            reader.onload = event => {
                resolve(new FileObject_1.FileObject({
                    // @ts-ignore
                    data: addNameToDataURL(event.target.result, name),
                    mediaType: mediaType,
                    name,
                    size
                }));
            };
            reader.readAsDataURL(file.data);
        });
        return fileObj;
    });
}
/**
 * Implementation of FileUpload runtime model which extends from {@link Field | field}
 */
class FileUpload extends Field_1.default {
    //private _files: FileObject[];
    _getDefaults() {
        return Object.assign(Object.assign({}, super._getDefaults()), { accept: ['audio/*', 'video/*', 'image/*', 'text/*', 'application/pdf'], maxFileSize: '2MB', type: 'file' });
    }
    static extractFileInfo(files) {
        return (files instanceof Array ? files : [files])
            .map((file) => {
            let retVal = null;
            if (file instanceof FileObject_1.FileObject) {
                retVal = file;
            }
            else if (typeof File !== 'undefined' && file instanceof File) {
                // case: file object
                retVal = {
                    name: file.name,
                    mediaType: file.type,
                    size: file.size,
                    data: file
                };
            }
            else if (typeof file === 'string' && (0, ValidationUtils_1.isDataUrl)(file)) {
                // case: data URL
                const { blob, name } = (0, FormUtils_1.dataURItoBlob)(file);
                retVal = {
                    name: name,
                    mediaType: blob.type,
                    size: blob.size,
                    data: blob
                };
            }
            else {
                // case: string as file object
                let jFile = file;
                try {
                    jFile = JSON.parse(file);
                    retVal = jFile;
                }
                catch (ex) {
                    // do nothing
                }
                if (typeof (jFile === null || jFile === void 0 ? void 0 : jFile.data) === 'string' && (0, ValidationUtils_1.isDataUrl)(jFile === null || jFile === void 0 ? void 0 : jFile.data)) {
                    // case: data URL
                    const { blob } = (0, FormUtils_1.dataURItoBlob)(jFile === null || jFile === void 0 ? void 0 : jFile.data);
                    retVal = {
                        name: jFile === null || jFile === void 0 ? void 0 : jFile.name,
                        mediaType: jFile === null || jFile === void 0 ? void 0 : jFile.type,
                        size: blob.size,
                        data: blob
                    };
                }
                else if (typeof jFile === 'string') {
                    // case: data as external url
                    const fileName = jFile.split('/').pop();
                    retVal = {
                        name: fileName,
                        mediaType: 'application/octet-stream',
                        size: 0,
                        data: jFile
                    };
                }
                else if (jFile instanceof Object) {
                    // todo: just added for ease of integration for the view layer
                    retVal = {
                        name: jFile === null || jFile === void 0 ? void 0 : jFile.name,
                        mediaType: jFile === null || jFile === void 0 ? void 0 : jFile.type,
                        size: jFile === null || jFile === void 0 ? void 0 : jFile.size,
                        data: jFile === null || jFile === void 0 ? void 0 : jFile.data
                    };
                }
            }
            return new FileObject_1.FileObject(retVal);
        });
    }
    /**
     * Returns the max file size in bytes as per IEC specification
     */
    get maxFileSize() {
        return (0, FormUtils_1.getFileSizeInBytes)(this._jsonModel.maxFileSize);
    }
    /**
     * Returns the list of mime types which file attachment can accept
     */
    get accept() {
        return this._jsonModel.accept;
    }
    /**
     * Checks whether there are any updates in the properties
     * @param propNames
     * @param updates
     * @private
     */
    _applyUpdates(propNames, updates) {
        return propNames.reduce((acc, propertyName) => {
            //@ts-ignore
            const prevValue = this._jsonModel[propertyName];
            const currentValue = updates[propertyName];
            if (currentValue !== prevValue) {
                acc[propertyName] = {
                    propertyName,
                    currentValue,
                    prevValue
                };
                if (prevValue instanceof FileObject_1.FileObject && typeof currentValue === 'object' && propertyName === 'value') {
                    // @ts-ignore
                    this._jsonModel[propertyName] = new FileObject_1.FileObject(Object.assign(Object.assign({}, prevValue), { 'data': currentValue.data }));
                }
                else {
                    // @ts-ignore
                    this._jsonModel[propertyName] = currentValue;
                }
            }
            return acc;
        }, {});
    }
    typeCheck(value) {
        const type = this._jsonModel.type || 'file';
        switch (type) {
            case 'string':
                return { valid: true, value: value };
            default:
                return ValidationUtils_1.Constraints.type(type, value);
        }
    }
    get value() {
        // @ts-ignore
        this.ruleEngine.trackDependency(this);
        if (this._jsonModel.value === undefined) {
            return null;
        }
        let val = this._jsonModel.value;
        // always return file object irrespective of data schema
        if (val != null) {
            // @ts-ignore
            val = this.coerce((val instanceof Array ? val : [val])
                .map(file => {
                let retVal = file;
                if (!(retVal instanceof FileObject_1.FileObject)) {
                    retVal = new FileObject_1.FileObject({
                        'name': file.name,
                        'mediaType': file.mediaType,
                        'size': file.size,
                        'data': file.data
                    });
                }
                // define serialization here
                /*
                Object.defineProperty(retVal, 'data', {
                    get: async function() {
                        if (file.data instanceof File) {
                            return processFile(file);
                        } else {
                            return file.data;
                        }
                    }
                });
                */
                return retVal;
            }));
        }
        return val;
    }
    set value(value) {
        if (value !== undefined) {
            // store file list here
            const typeRes = this.typeCheck(value);
            const changes = this._setProperty('value', typeRes.value, false);
            let fileInfoPayload = FileUpload.extractFileInfo(value);
            fileInfoPayload = this.coerce(fileInfoPayload);
            this._setProperty('value', fileInfoPayload, false);
            if (changes.length > 0) {
                const dataNode = this.getDataNode();
                if (typeof dataNode !== 'undefined') {
                    let val = this._jsonModel.value;
                    const retVal = (val instanceof Array ? val : [val]).map(file => {
                        if (this.type === 'file' || this.type === 'file[]') {
                            return file;
                        }
                        else if (this.type === 'string' || this.type === 'string[]') {
                            // @ts-ignore
                            return file.data.toString();
                        }
                    });
                    val = this.coerce(retVal);
                    if (dataNode !== undefined) {
                        dataNode.setValue(val, this._jsonModel.value);
                    }
                }
                let updates;
                if (typeRes.valid) {
                    updates = this.evaluateConstraints();
                }
                else {
                    const changes = {
                        'valid': typeRes.valid,
                        'errorMessage': typeRes.valid ? '' : this.getErrorMessage('type')
                    };
                    updates = this._applyUpdates(['valid', 'errorMessage'], changes);
                }
                if (updates.valid) {
                    this.triggerValidationEvent(updates);
                }
                const changeAction = new Controller_1.Change({ changes: changes.concat(Object.values(updates)) });
                this.dispatch(changeAction);
            }
        }
    }
    _serialize() {
        return __awaiter(this, void 0, void 0, function* () {
            const val = this._jsonModel.value;
            if (val === undefined) {
                return null;
            }
            // @ts-ignore
            const filesInfo = yield processFiles(val instanceof Array ? val : [val]);
            return filesInfo;
        });
    }
    coerce(val) {
        let retVal = val;
        if ((this.type === 'string' || this.type === 'file') && retVal instanceof Array) {
            // @ts-ignore
            retVal = val[0];
        }
        return retVal;
    }
    importData(dataModel) {
        this._bindToDataModel(dataModel);
        const dataNode = this.getDataNode();
        if (dataNode !== undefined) {
            const value = dataNode === null || dataNode === void 0 ? void 0 : dataNode.$value;
            let newValue = value;
            // only if not undefined, proceed further
            if (value != null) {
                const fileObj = FileUpload.extractFileInfo(value);
                newValue = this.coerce(fileObj);
                // is this needed ?
                this.form.getEventQueue().queue(this, (0, Controller_1.propertyChange)('value', newValue, this._jsonModel.value));
            }
            this._jsonModel.value = newValue;
        }
    }
}
exports.default = FileUpload;
