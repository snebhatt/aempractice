"use strict";
/*
 * Copyright 2022 Adobe, Inc.
 *
 * Your access and use of this software is governed by the Adobe Customer Feedback Program Terms and Conditions or other Beta License Agreement signed by your employer and Adobe, Inc.. This software is NOT open source and may not be used without one of the foregoing licenses. Even with a foregoing license, your access and use of this file is limited to the earlier of (a) 180 days, (b) general availability of the product(s) which utilize this software (i.e. AEM Forms), (c) January 1, 2023, (d) Adobe providing notice to you that you may no longer use the software or that your beta trial has otherwise ended.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL ADOBE NOR ITS THIRD PARTY PROVIDERS AND PARTNERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 */
Object.defineProperty(exports, "__esModule", { value: true });
const BaseNode_1 = require("./BaseNode");
/**
 * Defines scriptable aspects (ie rules, events) of form runtime model. Any form runtime object which requires
 * execution of rules/events should extend from this class.
 */
const dynamicProps = ['label',
    'enum',
    'enumNames',
    'enforceEnum',
    'exclusiveMinimum',
    'exclusiveMaximum',
    'maxLength',
    'maximum',
    'maxItems',
    'minLength',
    'minimum',
    'minItems',
    'required',
    'step',
    'description',
    'properties',
    'readOnly',
    'value',
    'visible',
    'enabled',
    'placeholder'];
class Scriptable extends BaseNode_1.BaseNode {
    constructor() {
        super(...arguments);
        this._events = {};
        this._rules = {};
    }
    get rules() {
        return this._jsonModel.rules || {};
    }
    getCompiledRule(eName, rule) {
        if (!(eName in this._rules)) {
            const eString = rule || this.rules[eName];
            if (typeof eString === 'string' && eString.length > 0) {
                try {
                    this._rules[eName] = this.ruleEngine.compileRule(eString);
                }
                catch (e) {
                    this.form.logger.error(`Unable to compile rule \`"${eName}" : "${eString}"\` Exception : ${e}`);
                }
            }
            else {
                throw new Error(`only expression strings are supported. ${typeof (eString)} types are not supported`);
            }
        }
        return this._rules[eName];
    }
    getCompiledEvent(eName) {
        var _a;
        if (!(eName in this._events)) {
            let eString = (_a = this._jsonModel.events) === null || _a === void 0 ? void 0 : _a[eName];
            if (typeof eString === 'string' && eString.length > 0) {
                eString = [eString];
            }
            if (typeof eString !== 'undefined' && eString.length > 0) {
                this._events[eName] = eString.map(x => {
                    try {
                        return this.ruleEngine.compileRule(x);
                    }
                    catch (e) {
                        this.form.logger.error(`Unable to compile expression \`"${eName}" : "${eString}"\` Exception : ${e}`);
                    }
                    return null;
                }).filter(x => x !== null);
            }
        }
        return this._events[eName] || [];
    }
    applyUpdates(updates) {
        Object.entries(updates).forEach(([key, value]) => {
            // @ts-ignore
            // the first check is to disable accessing this.value & this.items property
            // otherwise that will trigger dependency tracking
            if (key in dynamicProps || (key in this && typeof this[key] !== 'function')) {
                try {
                    // @ts-ignore
                    this[key] = value;
                }
                catch (e) {
                    console.error(e);
                }
            }
        });
    }
    executeAllRules(context) {
        const entries = Object.entries(this.rules);
        if (entries.length > 0) {
            const scope = this.getExpressionScope();
            const values = entries.map(([prop, rule]) => {
                const node = this.getCompiledRule(prop, rule);
                let newVal;
                if (node) {
                    newVal = this.ruleEngine.execute(node, scope, context, true);
                    if (dynamicProps.indexOf(prop) > -1) {
                        //@ts-ignore
                        this[prop] = newVal;
                    }
                }
                return [];
            }).filter(x => x.length == 2);
            this.applyUpdates(Object.fromEntries(values));
        }
    }
    getExpressionScope() {
        var _a;
        const target = {
            self: this.getRuleNode(),
            siblings: ((_a = this.parent) === null || _a === void 0 ? void 0 : _a.ruleNodeReference()) || {}
        };
        const scope = new Proxy(target, {
            get: (target, prop) => {
                if (prop === Symbol.toStringTag) {
                    return 'Object';
                }
                prop = prop;
                // The order of resolution is
                // 1. property
                // 2. sibling
                // 3. child
                if (prop.startsWith('$')) {
                    //this returns children as well, so adding an explicit check for property name
                    return target.self[prop];
                }
                else {
                    if (prop in target.siblings) {
                        return target.siblings[prop];
                    }
                    else {
                        return target.self[prop];
                    }
                }
            },
            has: (target, prop) => {
                prop = prop;
                const selfPropertyOrChild = target.self[prop];
                const sibling = target.siblings[prop];
                return typeof selfPropertyOrChild != 'undefined' || typeof sibling != 'undefined';
            }
        });
        return scope;
    }
    executeEvent(context, node) {
        let updates;
        if (node) {
            updates = this.ruleEngine.execute(node, this.getExpressionScope(), context);
        }
        if (typeof updates !== 'undefined') {
            this.applyUpdates(updates);
        }
    }
    /**
     * Executes the given rule
     * @param event
     * @param context
     * @private
     */
    executeRule(event, context) {
        if (typeof event.payload.ruleName === 'undefined') {
            this.executeAllRules(context);
        }
    }
    executeExpression(expr) {
        const ruleContext = {
            'form': this.form,
            '$form': this.form.getRuleNode(),
            '$field': this.getRuleNode(),
            'field': this
        };
        const node = this.ruleEngine.compileRule(expr);
        return this.ruleEngine.execute(node, this.getExpressionScope(), ruleContext);
    }
    /**
     * Executes the given action
     * @param action    {@link Action | event object}
     */
    executeAction(action) {
        const context = {
            'form': this.form,
            '$form': this.form.getRuleNode(),
            '$field': this.getRuleNode(),
            'field': this,
            '$event': {
                type: action.type,
                payload: action.payload,
                target: this.getRuleNode()
            }
        };
        const eventName = action.isCustomEvent ? `custom:${action.type}` : action.type;
        const funcName = action.isCustomEvent ? `custom_${action.type}` : action.type;
        const node = this.getCompiledEvent(eventName);
        //todo: apply all the updates at the end  or
        // not trigger the change event until the execution is finished
        node.forEach((n) => this.executeEvent(context, n));
        // @ts-ignore
        if (funcName in this && typeof this[funcName] === 'function') {
            //@ts-ignore
            this[funcName](action, context);
        }
        this.notifyDependents(action);
    }
}
exports.default = Scriptable;
