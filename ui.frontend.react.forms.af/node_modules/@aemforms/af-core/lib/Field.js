"use strict";
/*
 * Copyright 2022 Adobe, Inc.
 *
 * Your access and use of this software is governed by the Adobe Customer Feedback Program Terms and Conditions or other Beta License Agreement signed by your employer and Adobe, Inc.. This software is NOT open source and may not be used without one of the foregoing licenses. Even with a foregoing license, your access and use of this file is limited to the earlier of (a) 180 days, (b) general availability of the product(s) which utilize this software (i.e. AEM Forms), (c) January 1, 2023, (d) Adobe providing notice to you that you may no longer use the software or that your beta trial has otherwise ended.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL ADOBE NOR ITS THIRD PARTY PROVIDERS AND PARTNERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 */
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const types_1 = require("./types");
const ValidationUtils_1 = require("./utils/ValidationUtils");
const controller_1 = require("./controller");
const Scriptable_1 = __importDefault(require("./Scriptable"));
const SchemaUtils_1 = require("./utils/SchemaUtils");
const DataValue_1 = __importDefault(require("./data/DataValue"));
const BaseNode_1 = require("./BaseNode");
const EmptyDataValue_1 = __importDefault(require("./data/EmptyDataValue"));
/**
 * Defines a form object field which implements {@link FieldModel | field model} interface
 */
class Field extends Scriptable_1.default {
    /**
     * @param params
     * @param _options
     * @private
     */
    constructor(params, _options) {
        super(params, _options);
        this._applyDefaults();
        this.queueEvent(new controller_1.Initialize());
        this.queueEvent(new controller_1.ExecuteRule());
    }
    /**
     * @private
     */
    _initialize() {
        super._initialize();
        this.setupRuleNode();
    }
    _getDefaults() {
        return {
            readOnly: false,
            enabled: true,
            visible: true,
            type: this._getFallbackType()
        };
    }
    /**
     * Returns the fallback type to be used for this field, in case type is not defined. Otherwise returns
     * undefined
     * @protected
     */
    _getFallbackType() {
        const type = this._jsonModel.type;
        if (typeof type !== 'string') {
            const _enum = this.enum;
            return _enum && _enum.length > 0 ? typeof _enum[0] : 'string';
        }
    }
    _applyDefaults() {
        Object.entries(this._getDefaults()).map(([key, value]) => {
            //@ts-ignore
            if (this._jsonModel[key] === undefined && value !== undefined) {
                //@ts-ignore
                this._jsonModel[key] = value;
            }
        });
        const value = this._jsonModel.value;
        if (value === undefined) {
            this._jsonModel.value = this._jsonModel.default;
        }
        if (this._jsonModel.fieldType === undefined) {
            //@ts-ignore
            if (this._jsonModel.viewType) {
                //@ts-ignore
                if (this._jsonModel.viewType.startsWith('custom:')) {
                    this.form.logger.error('viewType property has been removed. For custom types, use :type property');
                }
                else {
                    this.form.logger.error('viewType property has been removed. Use fieldType property');
                }
                //@ts-ignore
                this._jsonModel.fieldType = this._jsonModel.viewType;
            }
            else {
                this._jsonModel.fieldType = (0, SchemaUtils_1.defaultFieldTypes)(this._jsonModel);
            }
        }
        if (this._jsonModel.enum === undefined) {
            const type = this._jsonModel.type;
            if (type === 'boolean') {
                this._jsonModel.enum = [true, false];
            }
        }
        if (typeof this._jsonModel.step !== 'number' || this._jsonModel.type !== 'number') {
            this._jsonModel.step = undefined;
        }
    }
    get readOnly() {
        return this._jsonModel.readOnly;
    }
    set readOnly(e) {
        this._setProperty('readOnly', e);
    }
    get enabled() {
        return this._jsonModel.enabled;
    }
    set enabled(e) {
        this._setProperty('enabled', e);
    }
    get valid() {
        return this._jsonModel.valid;
    }
    get emptyValue() {
        if (this._jsonModel.emptyValue === 'null') {
            return null;
        }
        else if (this._jsonModel.emptyValue === '' && this.type === 'string') {
            return '';
        }
        else {
            return undefined;
        }
    }
    get enum() {
        return this._jsonModel.enum;
    }
    set enum(e) {
        this._setProperty('enum', e);
    }
    get enumNames() {
        return this._jsonModel.enumNames;
    }
    set enumNames(e) {
        this._setProperty('enumNames', e);
    }
    get required() {
        return this._jsonModel.required || false;
    }
    set required(r) {
        this._setProperty('required', r);
    }
    get maximum() {
        return this._jsonModel.maximum;
    }
    set maximum(m) {
        this._setProperty('maximum', m);
    }
    get minimum() {
        return this._jsonModel.minimum;
    }
    set minimum(m) {
        this._setProperty('minimum', m);
    }
    /**
     * returns whether the value is empty. Empty value is either a '', undefined or null
     * @private
     */
    isEmpty() {
        return this._jsonModel.value === undefined || this._jsonModel.value === null || this._jsonModel.value === '';
    }
    get value() {
        //@ts-ignore
        this.ruleEngine.trackDependency(this);
        if (this._jsonModel.value === undefined) {
            return null;
        }
        else {
            return this._jsonModel.value;
        }
    }
    set value(v) {
        const Constraints = this._getConstraintObject();
        const typeRes = Constraints.type(this._jsonModel.type || 'string', v);
        const changes = this._setProperty('value', typeRes.value, false);
        if (changes.length > 0) {
            const dataNode = this.getDataNode();
            if (typeof dataNode !== 'undefined') {
                dataNode.setValue(this.isEmpty() ? this.emptyValue : this._jsonModel.value, this._jsonModel.value);
            }
            let updates;
            if (typeRes.valid) {
                updates = this.evaluateConstraints();
            }
            else {
                const changes = {
                    'valid': typeRes.valid,
                    'errorMessage': typeRes.valid ? '' : this.getErrorMessage('type')
                };
                updates = this._applyUpdates(['valid', 'errorMessage'], changes);
            }
            if (updates.valid) {
                this.triggerValidationEvent(updates);
            }
            const changeAction = new controller_1.Change({ changes: changes.concat(Object.values(updates)) });
            this.dispatch(changeAction);
        }
    }
    valueOf() {
        // @ts-ignore
        const obj = this[BaseNode_1.target];
        const actualField = obj === undefined ? this : obj;
        actualField.ruleEngine.trackDependency(actualField);
        return actualField._jsonModel.value || null;
    }
    toString() {
        var _a;
        // @ts-ignore
        const obj = this[BaseNode_1.target];
        const actualField = obj === undefined ? this : obj;
        return ((_a = actualField._jsonModel.value) === null || _a === void 0 ? void 0 : _a.toString()) || '';
    }
    /**
     * Returns the error message for a given constraint
     * @param constraint
     */
    getErrorMessage(constraint) {
        var _a;
        return ((_a = this._jsonModel.constraintMessages) === null || _a === void 0 ? void 0 : _a[constraint]) || '';
    }
    /**
     *
     * @private
     */
    _getConstraintObject() {
        return ValidationUtils_1.Constraints;
    }
    /**
     * returns whether the field is array type or not
     * @private
     */
    isArrayType() {
        return this.type ? this.type.indexOf('[]') > -1 : false;
    }
    /**
     *
     * @param value
     * @param constraints
     * @private
     */
    checkEnum(value, constraints) {
        if (this._jsonModel.enforceEnum === true && value != null) {
            const fn = constraints.enum;
            if (value instanceof Array && this.isArrayType()) {
                return value.every(x => fn(this.enum || [], x).valid);
            }
            else {
                return fn(this.enum || [], value).valid;
            }
        }
        return true;
    }
    /**
     * checks whether the value can be achieved by stepping the min/default value by the step constraint.
     * Basically to find a integer solution for n in the equation
     * initialValue + n * step = value
     * @param constraints
     * @private
     */
    checkStep() {
        const value = this._jsonModel.value;
        if (typeof this._jsonModel.step === 'number') {
            const initialValue = this._jsonModel.minimum || this._jsonModel.default || 0;
            return (value - initialValue) % this._jsonModel.step === 0;
        }
        return true;
    }
    /**
     * checks whether the validation expression returns a boolean value or not
     * @private
     */
    checkValidationExpression() {
        if (typeof this._jsonModel.validationExpression === 'string') {
            return this.executeExpression(this._jsonModel.validationExpression);
        }
        return true;
    }
    /**
     * Returns the applicable constraints for a given type
     * @private
     */
    getConstraints() {
        switch (this.type) {
            case 'string':
                switch (this.format) {
                    case 'date':
                        return ValidationUtils_1.ValidConstraints.date;
                    case 'binary':
                        return ValidationUtils_1.ValidConstraints.file;
                    case 'data-url':
                        return ValidationUtils_1.ValidConstraints.file;
                    default:
                        return ValidationUtils_1.ValidConstraints.string;
                }
            case 'number':
                return ValidationUtils_1.ValidConstraints.number;
        }
        if (this.isArrayType()) {
            return ValidationUtils_1.ValidConstraints.array;
        }
        return [];
    }
    /**
     * returns the format constraint
     */
    get format() {
        return this._jsonModel.format || '';
    }
    /**
     * @private
     */
    evaluateConstraints() {
        let constraint = 'type';
        const elem = this._jsonModel;
        const value = this._jsonModel.value;
        const Constraints = this._getConstraintObject();
        const supportedConstraints = this.getConstraints();
        let valid = true;
        if (valid) {
            valid = Constraints.required(this.required, value).valid &&
                (this.isArrayType() && this.required ? value.length > 0 : true);
            constraint = 'required';
        }
        if (valid) {
            const invalidConstraint = supportedConstraints.find(key => {
                if (key in elem) {
                    // @ts-ignore
                    const restriction = elem[key];
                    // @ts-ignore
                    const fn = Constraints[key];
                    if (value instanceof Array && this.isArrayType()) {
                        return value.some(x => !(fn(restriction, x).valid));
                    }
                    else if (typeof fn === 'function') {
                        return !fn(restriction, value).valid;
                    }
                    else {
                        return false;
                    }
                }
                else {
                    return false;
                }
            });
            if (invalidConstraint != null) {
                valid = false;
                constraint = invalidConstraint;
            }
            else {
                valid = this.checkEnum(value, Constraints);
                constraint = 'enum';
                if (valid && this.type === 'number') {
                    valid = this.checkStep();
                    constraint = 'step';
                }
                if (valid) {
                    valid = this.checkValidationExpression();
                    constraint = 'validationExpression';
                }
            }
        }
        if (!valid) {
            //@ts-ignore
            this.form.logger.log(`${constraint} constraint evaluation failed ${this[constraint]}. Received ${this._jsonModel.value}`);
        }
        const changes = {
            'valid': valid,
            'errorMessage': valid ? '' : this.getErrorMessage(constraint)
        };
        return this._applyUpdates(['valid', 'errorMessage'], changes);
    }
    triggerValidationEvent(changes) {
        if (changes.valid) {
            if (this.valid) {
                this.dispatch(new controller_1.Valid());
            }
            else {
                this.dispatch(new controller_1.Invalid());
            }
        }
    }
    /**
     * Checks whether there are any updates in the properties. If there are applies them to the
     * json model as well.
     * @param propNames
     * @param updates
     * @private
     */
    _applyUpdates(propNames, updates) {
        return propNames.reduce((acc, propertyName) => {
            //@ts-ignore
            const currentValue = updates[propertyName];
            const changes = this._setProperty(propertyName, currentValue, false);
            if (changes.length > 0) {
                acc[propertyName] = changes[0];
            }
            return acc;
        }, {});
    }
    /**
     * Validates the current form object
     */
    validate() {
        const changes = this.evaluateConstraints();
        if (changes.valid) {
            this.triggerValidationEvent(changes);
            this.notifyDependents(new controller_1.Change({ changes: Object.values(changes) }));
        }
        return this.valid ? [new types_1.ValidationError()] : [new types_1.ValidationError(this.id, [this._jsonModel.errorMessage])];
    }
    importData(contextualDataModel) {
        this._bindToDataModel(contextualDataModel);
        const dataNode = this.getDataNode();
        // only if the value has changed, queue change event
        if (dataNode !== undefined && dataNode !== EmptyDataValue_1.default && dataNode.$value !== this._jsonModel.value) {
            const changeAction = (0, controller_1.propertyChange)('value', dataNode.$value, this._jsonModel.value);
            this._jsonModel.value = dataNode.$value;
            this.queueEvent(changeAction);
        }
    }
    /**
     * @param name
     * @private
     */
    defaultDataModel(name) {
        return new DataValue_1.default(name, this.isEmpty() ? this.emptyValue : this._jsonModel.value, this.type || 'string');
    }
}
exports.default = Field;
