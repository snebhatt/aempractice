"use strict";
/*
 * Copyright 2022 Adobe, Inc.
 *
 * Your access and use of this software is governed by the Adobe Customer Feedback Program Terms and Conditions or other Beta License Agreement signed by your employer and Adobe, Inc.. This software is NOT open source and may not be used without one of the foregoing licenses. Even with a foregoing license, your access and use of this file is limited to the earlier of (a) 180 days, (b) general availability of the product(s) which utilize this software (i.e. AEM Forms), (c) January 1, 2023, (d) Adobe providing notice to you that you may no longer use the software or that your beta trial has otherwise ended.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL ADOBE NOR ITS THIRD PARTY PROVIDERS AND PARTNERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 */
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.Logger = void 0;
const Container_1 = __importDefault(require("./Container"));
const FormMetaData_1 = __importDefault(require("./FormMetaData"));
const Fieldset_1 = require("./Fieldset");
const EventQueue_1 = __importDefault(require("./controller/EventQueue"));
const FormUtils_1 = require("./utils/FormUtils");
const DataGroup_1 = __importDefault(require("./data/DataGroup"));
const FunctionRuntime_1 = require("./rules/FunctionRuntime");
const controller_1 = require("./controller");
const levels = {
    off: 0,
    info: 1,
    warn: 2,
    error: 3
};
/**
 * @private
 */
class Logger {
    constructor(logLevel = 'off') {
        this.logLevel = levels[logLevel];
    }
    info(msg) {
        this.log(msg, 'info');
    }
    warn(msg) {
        this.log(msg, 'warn');
    }
    error(msg) {
        this.log(msg, 'error');
    }
    log(msg, level) {
        if (this.logLevel !== 0 && this.logLevel <= levels[level]) {
            console[level](msg);
        }
    }
}
exports.Logger = Logger;
/**
 * Defines `form model` which implements {@link FormModel | form model}
 */
class Form extends Container_1.default {
    /**
     * @param n
     * @param _ruleEngine
     * @param _eventQueue
     * @param logLevel
     * @private
     */
    constructor(n, _ruleEngine, _eventQueue = new EventQueue_1.default(), logLevel = 'off') {
        //@ts-ignore
        super(n, {});
        this._ruleEngine = _ruleEngine;
        this._eventQueue = _eventQueue;
        /**
         * @private
         */
        this._fields = {};
        /**
         * @private
         */
        this._invalidFields = [];
        this.dataRefRegex = /("[^"]+?"|[^.]+?)(?:\.|$)/g;
        this._logger = new Logger(logLevel);
        this.queueEvent(new controller_1.Initialize());
        this.queueEvent(new controller_1.ExecuteRule());
        this._ids = (0, FormUtils_1.IdGenerator)();
        this._bindToDataModel(new DataGroup_1.default('$form', {}));
        this._initialize();
    }
    get logger() {
        return this._logger;
    }
    get metaData() {
        const metaData = this._jsonModel.metadata || {};
        return new FormMetaData_1.default(metaData);
    }
    get action() {
        return this._jsonModel.action;
    }
    _createChild(child) {
        return (0, Fieldset_1.createChild)(child, { form: this, parent: this });
    }
    importData(dataModel) {
        this._bindToDataModel(new DataGroup_1.default('$form', dataModel));
        this.syncDataAndFormModel(this.getDataNode());
        this._eventQueue.runPendingQueue();
    }
    exportData() {
        var _a;
        return (_a = this.getDataNode()) === null || _a === void 0 ? void 0 : _a.$value;
    }
    /**
     * Returns the current state of the form
     *
     * To access the form data and attachments, one needs to use the `data` and `attachments` property.
     * For example,
     * ```
     * const data = form.getState().data
     * const attachments = form.getState().attachments
     * ```
     */
    getState() {
        // eslint-disable-next-line @typescript-eslint/no-this-alias
        const self = this;
        const res = super.getState();
        res.id = '$form';
        Object.defineProperty(res, 'data', {
            get: function () {
                return self.exportData();
            }
        });
        Object.defineProperty(res, 'attachments', {
            get: function () {
                return (0, FormUtils_1.getAttachments)(self);
            }
        });
        return res;
    }
    get type() {
        return 'object';
    }
    isTransparent() {
        return false;
    }
    get form() {
        return this;
    }
    get ruleEngine() {
        return this._ruleEngine;
    }
    getUniqueId() {
        if (this._ids == null) {
            return '';
        }
        return this._ids.next().value;
    }
    /**
     * @param field
     * @private
     */
    fieldAdded(field) {
        this._fields[field.id] = field;
        field.subscribe((action) => {
            if (this._invalidFields.indexOf(action.target.id) === -1) {
                this._invalidFields.push(action.target.id);
            }
        }, 'invalid');
        field.subscribe((action) => {
            const index = this._invalidFields.indexOf(action.target.id);
            if (index > -1) {
                this._invalidFields.splice(index, 1);
            }
        }, 'valid');
        field.subscribe((action) => {
            //@ts-ignore
            const field = action.target.getState();
            if (field) {
                const fieldChangedAction = new controller_1.FieldChanged(action.payload.changes, field);
                this.dispatch(fieldChangedAction);
            }
        });
    }
    validate() {
        const validationErrors = super.validate();
        // trigger event on form so that user's can customize their application
        this.dispatch(new controller_1.ValidationComplete(validationErrors));
        return validationErrors;
    }
    /**
     * Checks if the given form is valid or not
     * @returns `true`, if form is valid, `false` otherwise
     */
    isValid() {
        return this._invalidFields.length === 0;
    }
    /**
     * @param field
     * @private
     */
    dispatch(action) {
        if (action.type === 'submit') {
            super.queueEvent(action);
            this._eventQueue.runPendingQueue();
        }
        else {
            super.dispatch(action);
        }
    }
    /**
     * @param action
     * @private
     */
    executeAction(action) {
        if (action.type !== 'submit' || this._invalidFields.length === 0) {
            super.executeAction(action);
        }
    }
    /**
     * @param action
     * @param context
     * @private
     */
    submit(action, context) {
        // if no errors, only then submit
        if (this.validate().length === 0) {
            (0, FunctionRuntime_1.submit)(context, action.payload.success, action.payload.error, action.payload.submit_as, action.payload.data);
        }
    }
    getElement(id) {
        if (id == this.id) {
            return this;
        }
        return this._fields[id];
    }
    /**
     * @private
     */
    getEventQueue() {
        return this._eventQueue;
    }
    get name() {
        return '$form';
    }
    get value() {
        return null;
    }
    get id() {
        return '$form';
    }
    get title() {
        return this._jsonModel.title || '';
    }
}
exports.default = Form;
