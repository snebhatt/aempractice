import { ConstraintsMessages, ContainerModel, FieldJson, FieldModel, FormModel, ValidationError } from './types';
import Scriptable from './Scriptable';
import DataValue from './data/DataValue';
import DataGroup from './data/DataGroup';
/**
 * Defines a form object field which implements {@link FieldModel | field model} interface
 */
declare class Field extends Scriptable<FieldJson> implements FieldModel {
    /**
     * @param params
     * @param _options
     * @private
     */
    constructor(params: FieldJson, _options: {
        form: FormModel;
        parent: ContainerModel;
    });
    /**
     * @private
     */
    _initialize(): any;
    protected _getDefaults(): {
        readOnly: boolean;
        enabled: boolean;
        visible: boolean;
        type: string | undefined;
    };
    /**
     * Returns the fallback type to be used for this field, in case type is not defined. Otherwise returns
     * undefined
     * @protected
     */
    protected _getFallbackType(): string | undefined;
    protected _applyDefaults(): void;
    get readOnly(): boolean | undefined;
    set readOnly(e: boolean | undefined);
    get enabled(): boolean | undefined;
    set enabled(e: boolean | undefined);
    get valid(): boolean | undefined;
    get emptyValue(): "" | null | undefined;
    get enum(): any[] | undefined;
    set enum(e: any[] | undefined);
    get enumNames(): string[] | undefined;
    set enumNames(e: string[] | undefined);
    get required(): boolean;
    set required(r: boolean);
    get maximum(): number | undefined;
    set maximum(m: number | undefined);
    get minimum(): number | undefined;
    set minimum(m: number | undefined);
    /**
     * returns whether the value is empty. Empty value is either a '', undefined or null
     * @private
     */
    private isEmpty;
    get value(): any;
    set value(v: any);
    valueOf(): any;
    toString(): any;
    /**
     * Returns the error message for a given constraint
     * @param constraint
     */
    getErrorMessage(constraint: keyof (ConstraintsMessages)): string;
    /**
     *
     * @private
     */
    _getConstraintObject(): {
        type: (constraint: string, inputVal: any) => {
            valid: boolean;
            value: any;
        };
        format: (constraint: string, input: string | null) => {
            value: string | null;
            valid: boolean;
        };
        minimum: (constraint: number, value: number) => {
            valid: boolean;
            value: number;
        };
        /**
         *
         * @param value
         * @param constraints
         * @private
         */
        maximum: (constraint: number, value: number) => {
            valid: boolean;
            value: number;
        };
        exclusiveMinimum: (constraint: number, value: number) => {
            valid: boolean;
            value: number;
        };
        exclusiveMaximum: (constraint: number, value: number) => {
            valid: boolean;
            value: number;
        };
        minItems: <T>(constraint: number, value: T[]) => {
            valid: boolean;
            value: T[];
        };
        maxItems: <T_1>(constraint: number, value: T_1[]) => {
            valid: boolean;
            value: T_1[];
        };
        uniqueItems: <T_2>(constraint: boolean, value: T_2[]) => {
            valid: boolean;
            value: T_2[];
        };
        minLength: (constraint: number, value: string) => {
            value: string;
            valid: boolean;
        };
        maxLength: (constraint: number, value: string) => {
            value: string;
            valid: boolean;
        };
        pattern: (constraint: string | RegExp, value: string) => {
            valid: boolean;
            value: string;
        };
        required: (constraint: boolean, value: any) => {
            valid: boolean;
            value: any;
        };
        enum: (constraint: any[], value: any) => {
            valid: boolean;
            value: any;
        };
    };
    /**
     * returns whether the field is array type or not
     * @private
     */
    private isArrayType;
    /**
     *
     * @param value
     * @param constraints
     * @private
     */
    private checkEnum;
    /**
     * checks whether the value can be achieved by stepping the min/default value by the step constraint.
     * Basically to find a integer solution for n in the equation
     * initialValue + n * step = value
     * @param constraints
     * @private
     */
    private checkStep;
    /**
     * checks whether the validation expression returns a boolean value or not
     * @private
     */
    private checkValidationExpression;
    /**
     * Returns the applicable constraints for a given type
     * @private
     */
    private getConstraints;
    /**
     * returns the format constraint
     */
    get format(): string;
    /**
     * @private
     */
    protected evaluateConstraints(): any;
    triggerValidationEvent(changes: any): void;
    /**
     * Checks whether there are any updates in the properties. If there are applies them to the
     * json model as well.
     * @param propNames
     * @param updates
     * @private
     */
    protected _applyUpdates(propNames: string[], updates: any): any;
    /**
     * Validates the current form object
     */
    validate(): ValidationError[];
    importData(contextualDataModel: DataGroup): void;
    /**
     * @param name
     * @private
     */
    defaultDataModel(name: string | number): DataValue;
}
export default Field;
