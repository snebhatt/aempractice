"use strict";
/*
 * Copyright 2022 Adobe, Inc.
 *
 * Your access and use of this software is governed by the Adobe Customer Feedback Program Terms and Conditions or other Beta License Agreement signed by your employer and Adobe, Inc.. This software is NOT open source and may not be used without one of the foregoing licenses. Even with a foregoing license, your access and use of this file is limited to the earlier of (a) 180 days, (b) general availability of the product(s) which utilize this software (i.e. AEM Forms), (c) January 1, 2023, (d) Adobe providing notice to you that you may no longer use the software or that your beta trial has otherwise ended.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL ADOBE NOR ITS THIRD PARTY PROVIDERS AND PARTNERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 */
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.submit = exports.request = void 0;
/**
 * Implementation of function runtime in rule engine
 */
//import {jsonString} from '../utils/JsonUtils';
const Controller_1 = require("../controller/Controller");
const Fetch_1 = require("../utils/Fetch");
const FileObject_1 = require("../FileObject");
const FormUtils_1 = require("../utils/FormUtils");
const JsonUtils_1 = require("../utils/JsonUtils");
/**
 * Implementation of generic request API. This API can be used to make external web request
 * @param context                   expression execution context(consists of current form, current field, current event)
 * @param uri                       request URI
 * @param httpVerb                  http verb (for example, GET or POST)
 * @param payload                   request payload
 * @param success                   success handler
 * @param error                     error handler
 * @param payloadContentType        content type of the request
 * @private
 */
const request = (context, uri, httpVerb, payload, success, error, payloadContentType) => __awaiter(void 0, void 0, void 0, function* () {
    const endpoint = uri;
    const requestOptions = {
        method: httpVerb
    };
    let result;
    let inputPayload;
    try {
        if (payload && payload instanceof FileObject_1.FileObject && payload.data instanceof File) {
            // todo: have to implement array type
            const formData = new FormData();
            formData.append(payload.name, payload.data);
            inputPayload = formData;
        }
        else if (payload instanceof FormData) {
            inputPayload = payload;
        }
        else if (payload && typeof payload === 'object' && Object.keys(payload).length > 0) {
            if (payloadContentType.length > 0) {
                requestOptions.headers = {
                    'Content-Type': payloadContentType // this should match content type of the payload
                };
            }
            inputPayload = JSON.stringify(payload);
        }
        result = yield (0, Fetch_1.request)(endpoint, inputPayload, requestOptions);
    }
    catch (e) {
        //todo: define error payload
        context.form.logger.error('Error invoking a rest API');
        context.form.dispatch(new Controller_1.CustomEvent(error, {}, true));
        return;
    }
    context.form.dispatch(new Controller_1.CustomEvent(success, result, true));
});
exports.request = request;
/**
 * Create multi part form data using form data and form attachments
 * @param data              form data
 * @param attachments       form events
 * @private
 */
// eslint-disable-next-line @typescript-eslint/no-unused-vars
const multipartFormData = (data, attachments) => {
    const formData = new FormData();
    Object.entries(data).forEach(([key, value]) => {
        if (value != null && typeof value === 'object') {
            formData.append(key, (0, JsonUtils_1.jsonString)(value));
        }
        else {
            formData.append(key, value);
        }
    });
    // const transformAttachment = (objValue: any, formData: any) : any => {
    //     const newValue = {
    //         ':name' : objValue.name,
    //         ':contentType' : objValue.mediaType,
    //         ':data' : objValue.data,
    //         ':bindRef' : objValue.dataRef
    //     };
    //     if (objValue?.data instanceof File) {
    //         let attIdentifier = `${objValue?.dataRef}/${objValue?.name}`;
    //         if (!attIdentifier.startsWith('/')) {
    //             attIdentifier = `/${attIdentifier}`;
    //         }
    //         formData.append(attIdentifier, objValue.data);
    //         newValue[':data'] = `#${attIdentifier}`;
    //     }
    //     return newValue;
    // };
    // @ts-ignore
    /*const submitAttachments = Object.keys(attachments).reduce((acc, curr) => {
        const objValue = attachments[curr];
        if(objValue && objValue instanceof Array) {
            return [...acc, ...objValue.map((x)=>transformAttachment(x, formData))];
        } else {
            return [...acc, transformAttachment(objValue, formData)];
        }
    }, []);
    if (submitAttachments?.length > 0) {
        formData.append(':attachments', jsonString(submitAttachments));
    }*/
    return formData;
};
const submit = (context, success, error, submitAs = 'multipart/form-data', input_data = null) => __awaiter(void 0, void 0, void 0, function* () {
    const endpoint = context.form.action;
    let data = input_data;
    if (typeof data != 'object' || data == null) {
        data = context.form.exportData();
    }
    // todo: have to implement sending of attachments here
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    const attachments = (0, FormUtils_1.getAttachments)(context.$form);
    let submitContentType = submitAs;
    let formData;
    if (Object.keys(attachments).length > 0 || submitAs === 'multipart/form-data') {
        formData = multipartFormData({ 'data': data }, attachments);
        submitContentType = 'multipart/form-data';
    }
    else {
        formData = { 'data': data };
    }
    // submitContentType = submitAs;
    // note: don't send multipart/form-data let browser decide on the content type
    yield (0, exports.request)(context, endpoint, 'POST', formData, success, error, submitContentType);
});
exports.submit = submit;
/**
 * Helper function to create an action
 * @param name          name of the event
 * @param payload       event payload
 * @param dispatch      true to trigger the event on all the fields in DFS order starting from the top level form element, false otherwise
 * @private
 */
const createAction = (name, payload = {}) => {
    switch (name) {
        case 'change':
            return new Controller_1.Change(payload);
        case 'submit':
            return new Controller_1.Submit(payload);
        case 'click':
            return new Controller_1.Click(payload);
        case 'addItem':
            return new Controller_1.AddItem(payload);
        case 'removeItem':
            return new Controller_1.RemoveItem(payload);
        default:
            console.error('invalid action');
    }
};
/**
 * Implementation of function runtime
 * @private
 */
class FunctionRuntimeImpl {
    getFunctions() {
        // todo: remove these once json-formula exposes a way to call them from custom functions
        function isArray(obj) {
            if (obj !== null) {
                return Object.prototype.toString.call(obj) === '[object Array]';
            }
            return false;
        }
        function valueOf(a) {
            if (a === null || a === undefined) {
                return a;
            }
            if (isArray(a)) {
                return a.map(i => valueOf(i));
            }
            return a.valueOf();
        }
        function toString(a) {
            if (a === null || a === undefined) {
                return '';
            }
            return a.toString();
        }
        return {
            validate: {
                _func: (args, data, interpreter) => {
                    const element = args[0];
                    if (typeof element === 'string' || typeof element === 'undefined') {
                        return interpreter.globals.form.validate();
                    }
                    else {
                        return interpreter.globals.form.getElement(element.$id).validate();
                    }
                },
                _signature: []
            },
            getData: {
                _func: (args, data, interpreter) => {
                    return interpreter.globals.form.exportData();
                },
                _signature: []
            },
            submitForm: {
                _func: (args, data, interpreter) => {
                    // success: string, error: string, submit_as: 'json' | 'multipart' = 'json', data: any = null
                    const success = toString(args[0]);
                    const error = toString(args[1]);
                    const submit_as = args.length > 2 ? toString(args[2]) : 'multipart/form-data';
                    const submit_data = args.length > 3 ? valueOf(args[3]) : null;
                    interpreter.globals.form.dispatch(new Controller_1.Submit({
                        success,
                        error,
                        submit_as,
                        data: submit_data
                    }));
                    return {};
                },
                _signature: []
            },
            // todo: only supports application/json for now
            request: {
                _func: (args, data, interpreter) => {
                    const uri = toString(args[0]);
                    const httpVerb = toString(args[1]);
                    const payload = valueOf(args[2]);
                    const success = valueOf(args[3]);
                    const error = valueOf(args[4]);
                    (0, exports.request)(interpreter.globals, uri, httpVerb, payload, success, error, 'application/json');
                    return {};
                },
                _signature: []
            },
            dispatchEvent: {
                _func: (args, data, interpreter) => {
                    const element = args[0];
                    let eventName = valueOf(args[1]);
                    let payload = args.length > 2 ? valueOf(args[2]) : undefined;
                    let dispatch = false;
                    if (typeof element === 'string') {
                        payload = eventName;
                        eventName = element;
                        dispatch = true;
                    }
                    let event;
                    if (eventName.startsWith('custom:')) {
                        event = new Controller_1.CustomEvent(eventName.substring('custom:'.length), payload, dispatch);
                    }
                    else {
                        event = createAction(eventName, payload);
                    }
                    if (event != null) {
                        if (typeof element === 'string') {
                            interpreter.globals.form.dispatch(event);
                        }
                        else {
                            interpreter.globals.form.getElement(element.$id).dispatch(event);
                        }
                    }
                    return {};
                },
                _signature: []
            }
        };
    }
}
const FunctionRuntime = new FunctionRuntimeImpl();
exports.default = FunctionRuntime;
