"use strict";
/*************************************************************************
 * Copyright 2022 Adobe
 * All Rights Reserved.
 *
 * NOTICE: Adobe permits you to use, modify, and distribute this file in
 * accordance with the terms of the Adobe license agreement accompanying
 * it. If you have received this file from a source other than Adobe,
 * then your use, modification, or distribution of it requires the prior
 * written permission of Adobe.
 **************************************************************************/
Object.defineProperty(exports, "__esModule", { value: true });
exports.CacheTTL = exports.CacheScope = void 0;
/**
 * APIs for managing a client side persisted cache.
 * Unified Shell will store the data against its own domain, which allows data caching
 * even when the actual app runs on a domain which is 3rd party to Unified Shell's.
 *
 * For example, the API will work in Chrome incognito when Unified Shell runs on an adobe.com domain
 * and the embedded applications run on the adobe.net domain.
 *
 * These APIs utilizes the [Browser Cache API](https://developer.mozilla.org/en-US/docs/Web/API/Cache) under the hood and are all run asynchronously.
 *
 * If migrating from Local Storage to Cache API, make sure all the app logic is async first.
 *
 * NOTE: This API should not be used to cache any PII data to comply with Adobe privacy policies.
 *
 * To consume this API, add the following import to your code.
 *
 * ```typescript
 * import cache from '@adobe/exc-app/cache';
 * ```
 *
 * The default export is an object of type [CacheAPI](../interfaces/_cache_.cacheapi.md)
 *
 * API reference: [scroll down](#index)
 *
 * ### Sample code
 *
 * ```typescript
 * import cache, {CacheTTL, CacheScope} from '@adobe/exc-app/cache';
 *
 * // By default, cached data is tied to the user and cached for a week.
 * await cache.set<MyType>({key: 'some-cache-key', value: myTypeInstance});
 *
 * // Both scope and expiry can be adjusted.
 * await cache.set<MyType>({key: 'some-cache-key', value: myTypeInstance, expiry: CacheTTL.DAY, scope: CacheScope.ORG});
 *
 * // It is also possible to bind cache data to the current IMS session, it will expire when the user logs out.
 * await cache.set<MyType>({key: 'some-cache-key', value: myTypeInstance, expiry: CacheTTL.IMS_SESSION});
 *
 * // Cache get
 * const myData: MyType = await cache.get<MyType>({key: 'some-cache-key'});
 *
 * // Get scope must be identical to the scope used for set - Always use the same scope for both.
 * const myData2: MyType = await cache.get<MyType>({key: 'some-cache-key', scope: CacheScope.ORG});
 *
 * // Cache delete.
 * await cache.delete({key: 'some-cache-key'});
 * ```
 * @packageDocumentation
 * @module cache
 */
const Global_1 = require("./src/Global");
/**
 * @ignore
 */
var CacheScope;
(function (CacheScope) {
    /**
     * Default - Same as USER
     */
    CacheScope["DEFAULT"] = "user";
    /**
     * Cache data at the IMS Org level.
     */
    CacheScope["ORG"] = "org";
    /**
     * Cache data at the AEP Sandbox level.
     */
    CacheScope["SANDBOX"] = "sandbox";
    /**
     * Cache data at the Sub Org level.
     */
    CacheScope["SUBORG"] = "suborg";
    /**
     * Cache data at the user level.
     */
    CacheScope["USER"] = "user"; // eslint-disable-line @typescript-eslint/no-duplicate-enum-values
})(CacheScope = exports.CacheScope || (exports.CacheScope = {}));
/**
 * @ignore
 */
var CacheTTL;
(function (CacheTTL) {
    /**
     * Disable caching for this value.
     */
    CacheTTL[CacheTTL["DONT_CACHE"] = 0] = "DONT_CACHE";
    /**
     * Cache data for the duration of the current IMS session only
     * Data will not be available once the user has logged in again.
     */
    CacheTTL[CacheTTL["IMS_SESSION"] = -1] = "IMS_SESSION";
    /**
     * Default - One week
     */
    CacheTTL[CacheTTL["DEFAULT"] = 604800] = "DEFAULT";
    /**
     * Cache data for an hour.
     */
    CacheTTL[CacheTTL["HOUR"] = 3600] = "HOUR";
    /**
     * Cache data for a day.
     */
    CacheTTL[CacheTTL["DAY"] = 86400] = "DAY";
    /**
     * Cache data for a week.
     */
    CacheTTL[CacheTTL["WEEK"] = 604800] = "WEEK";
    /**
     * Cache data for a month (30 days actual).
     */
    CacheTTL[CacheTTL["MONTH"] = 2592000] = "MONTH";
})(CacheTTL = exports.CacheTTL || (exports.CacheTTL = {}));
const cache = {
    delete: params => (0, Global_1.getImpl)('cache')().delete(params),
    get: params => (0, Global_1.getImpl)('cache')().get(params),
    set: params => (0, Global_1.getImpl)('cache')().set(params)
};
exports.default = cache;
//# sourceMappingURL=cache.js.map