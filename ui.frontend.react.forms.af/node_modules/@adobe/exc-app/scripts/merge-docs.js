/*************************************************************************
 * Copyright 2020 Adobe
 * All Rights Reserved.
 *
 * NOTICE: Adobe permits you to use, modify, and distribute this file in
 * accordance with the terms of the Adobe license agreement accompanying
 * it. If you have received this file from a source other than Adobe,
 * then your use, modification, or distribution of it requires the prior
 * written permission of Adobe.
 **************************************************************************/
/* eslint-disable @typescript-eslint/no-var-requires */
const glob = require('glob');
const {readFileSync, writeFileSync} = require('fs');
const {resolve} = require('path');
const fileNameToTitleElement = new Map();

// A helper from MDN to escape normal strings to work in RegExp
const escapeRegExp = string => string.replace(/[.*+?^${}()|[\]\\]/g, '\\$&');

/**
 * Takes a look at a file path, and determines what subfolder it is in. After that it returns
 * an object with a string that matches the keys of itself and relative paths for inner doc links
 * @param pathToInspect the path to a file
 * @returns a configuration object to compare paths simply
 */
const getPathRelativity = (pathToInspect) => {
  const fileIsInEnumsFolder = pathToInspect.includes('/enums/');
  const fileIsInModulesFolder = pathToInspect.includes('/modules/');
  const fileIsInInterfacesFolder = pathToInspect.includes('/interfaces/');
  return {
    currentLocation: fileIsInEnumsFolder ? 'enum' : fileIsInInterfacesFolder ? 'interface' : 'module',
    enum: fileIsInEnumsFolder ? '' : '../enums',
    interface: fileIsInInterfacesFolder ? '' : '../interfaces',
    module: fileIsInModulesFolder ? '' : '../modules'
  };
};

/**
 * Looks at the location of a file from our Map, compares it to the current file,
 * and creates a regex and replacement array. This array is the same as arguments
 * you would pass to a String.replace
 * @param pathMatch the folder path and built title of an md file
 * @param pathConfig the relative path config for the current md file
 * @returns a regex to search and the value to replace, should be spread into a replace
 */
const getRegexForPath = (pathMatch, pathConfig) => {
  const [pathFromRoot, titleOfPage] = pathMatch;
  const currentPathInfo = getPathRelativity(pathFromRoot);
  let pathAsItShouldBeInMarkdown = '';
  if (currentPathInfo.currentLocation === pathConfig.currentLocation) {
    pathAsItShouldBeInMarkdown = pathFromRoot.split('/').pop();
  } else {
    pathAsItShouldBeInMarkdown = pathConfig[currentPathInfo.currentLocation] + '/' + pathFromRoot.split('/').pop();
  }
  return [new RegExp(`\\(${escapeRegExp(pathAsItShouldBeInMarkdown)}`, 'gm'), `(#${titleOfPage}`];
};

/**
 * Reads through all of the typedoc md files, and unifies them.
 */
const combineThoseFiles = () => {
  const allReadmeFiles = glob.sync('./docs/**/*.md', {cwd: resolve(__dirname, '../')});
  const allFileContents = allReadmeFiles.map((path) => {
    const content = readFileSync(path, 'utf8');
    // replace the path with a title: /docs/enums/thing.md -> enums-thing.md
    const mdLinkFormat = path.split('./docs/')[1].split('/').join('-').split('.').join('');
    const formattedFileToTitle = path.split('./docs/')[1].split('/').join(' ');
    // build a map of filepath to newly built title so we can link to it
    fileNameToTitleElement.set(path, mdLinkFormat);
    const builtContent = path.endsWith('README.md') ? content : `# ${formattedFileToTitle}\n\n${content}`;
    // preprend title and prep to iterate again
    return {
      content: builtContent,
      path
    };
  }).map(({content, path}) => {
    // replace README.md links with #exc-app - the title of the readme
    const isReadme = path.endsWith('README.md');
    let rebuiltContent = content.replace(/..\/README\.md/g, '#exc-app');
    const fileFolderInfo = getPathRelativity(path);
    const currentPageTitle = fileNameToTitleElement.get(path);
    rebuiltContent = !isReadme ? rebuiltContent.replace(/### /gmi, '### `' + currentPageTitle + '` > ') : rebuiltContent;
    // for file each we found
    for (const possibleMatch of fileNameToTitleElement) {
      // create a RegEx to replace relative link with the new title we added
      // had to use regex so _all_ instances are replaced, not just the first one
      const replaceArgs = getRegexForPath(possibleMatch, fileFolderInfo);
      // apply the regex transform we built to fix the links
      rebuiltContent = rebuiltContent.replace(...replaceArgs);
    }
    rebuiltContent = rebuiltContent.split(currentPageTitle + '#').join(currentPageTitle + '-');
    return rebuiltContent;
  });
  // Get the root README.md, replace all module links
  const rootReadmeLocation = allReadmeFiles.findIndex(name => name.endsWith('docs/README.md'));
  // pull it out of all the other files
  let [baseReadme] = allFileContents.splice(rootReadmeLocation, 1);
  // fix it's module links
  baseReadme = baseReadme.replace(new RegExp(`\\(./modules/`, 'gm'), '(#modules-');
  baseReadme = baseReadme.replace(new RegExp(`\\.md`, 'gm'), 'md');
  // append all the rebuilt files to it
  baseReadme += allFileContents.reduce((accum, curr) => accum + '\n' + curr, '');
  const unifiedDocLocation = resolve(__dirname, '../');
  // rewrite the base README.md so it's more useful for external devs
  writeFileSync(unifiedDocLocation + '/README.md', baseReadme);
};

combineThoseFiles();
