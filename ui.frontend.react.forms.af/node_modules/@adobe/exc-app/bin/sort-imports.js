/*************************************************************************
 * Copyright 2020 Adobe
 * All Rights Reserved.
 *
 * NOTICE: Adobe permits you to use, modify, and distribute this file in
 * accordance with the terms of the Adobe license agreement accompanying
 * it. If you have received this file from a source other than Adobe,
 * then your use, modification, or distribution of it requires the prior
 * written permission of Adobe.
 **************************************************************************/

 module.exports = function(context) {
  const sourceCode = context.getSourceCode();
  let previousDeclaration = null;

  /**
   * Gets the local name of the first imported module.
   * @param {ASTNode} node the ImportDeclaration node.
   * @returns {?string} the local name of the first imported module.
   */
  function getFirstLocalMemberName(node) {
    if (node.specifiers[0]) {
      return node.specifiers[0].local.name.toLowerCase();
    }
    return null;
  }

  return {
    ImportDeclaration(node) {
      if (previousDeclaration) {
        let currentLocalMemberName = getFirstLocalMemberName(node),
          previousLocalMemberName = getFirstLocalMemberName(previousDeclaration);

        if (previousLocalMemberName && currentLocalMemberName && currentLocalMemberName < previousLocalMemberName) {
          context.report({
            node,
            message: 'Imports should be sorted alphabetically.'
          });
        }
      }

      const importSpecifiers = node.specifiers.filter(specifier => specifier.type === 'ImportSpecifier');
      const getSortableName = specifier => specifier.local.name.toLowerCase();
      const firstUnsortedIndex = importSpecifiers
        .map(getSortableName)
        .findIndex((name, index, array) => array[index - 1] > name);

      if (firstUnsortedIndex !== -1) {
        context.report({
          node: importSpecifiers[firstUnsortedIndex],
          message: "Member '{{memberName}}' of the import declaration should be sorted alphabetically.",
          data: {memberName: importSpecifiers[firstUnsortedIndex].local.name},
          fix(fixer) {
            return fixer.replaceTextRange(
              [importSpecifiers[0].range[0], importSpecifiers[importSpecifiers.length - 1].range[1]],
              importSpecifiers
                // Clone the importSpecifiers array to avoid mutating it
                .slice()

                // Sort the array into the desired order
                .sort((specifierA, specifierB) => {
                  const aName = getSortableName(specifierA);
                  const bName = getSortableName(specifierB);
                  return aName > bName ? 1 : -1;
                })

                // Build a string out of the sorted list of import specifiers and the text between the originals
                .reduce((sourceText, specifier, index) => {
                  const textAfterSpecifier =
                    index === importSpecifiers.length - 1
                      ? ''
                      : sourceCode
                          .getText()
                          .slice(importSpecifiers[index].range[1], importSpecifiers[index + 1].range[0]);

                  return sourceText + sourceCode.getText(specifier) + textAfterSpecifier;
                }, '')
            );
          }
        });
      }

      previousDeclaration = node;
    }
  };
};
