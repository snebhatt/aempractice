var $kYtlh$reactariainteractions = require("@react-aria/interactions");
var $kYtlh$reactstatelyvirtualizer = require("@react-stately/virtualizer");
var $kYtlh$reactariautils = require("@react-aria/utils");
var $kYtlh$react = require("react");
var $kYtlh$reactdom = require("react-dom");
var $kYtlh$reactariai18n = require("@react-aria/i18n");


function $parcel$export(e, n, v, s) {
  Object.defineProperty(e, n, {get: v, set: s, enumerable: true, configurable: true});
}

function $parcel$interopDefault(a) {
  return a && a.__esModule ? a.default : a;
}

$parcel$export(module.exports, "useVirtualizer", () => $e1fb6f3669e1c329$export$dd6d526d88b5a137);
$parcel$export(module.exports, "Virtualizer", () => $e1fb6f3669e1c329$export$89be5a243e59c4b2);
$parcel$export(module.exports, "useVirtualizerItem", () => $7d70e069fceb2deb$export$1da781778207e0a2);
$parcel$export(module.exports, "VirtualizerItem", () => $d6a26279cc31826b$export$6796df8ba7398521);
$parcel$export(module.exports, "layoutInfoToStyle", () => $d6a26279cc31826b$export$1481e64fbe01b8b3);
$parcel$export(module.exports, "ScrollView", () => $00ca8c0b29e3e07c$export$5665e3d6be6adea);
$parcel$export(module.exports, "getRTLOffsetType", () => $efdd61e59e023a1d$export$faf7630257ad4304);
$parcel$export(module.exports, "getScrollLeft", () => $efdd61e59e023a1d$export$1389d168952b34b5);
$parcel$export(module.exports, "setScrollLeft", () => $efdd61e59e023a1d$export$ed5fd5ffe5ab0ac);
/*
 * Copyright 2020 Adobe. All rights reserved.
 * This file is licensed to you under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License. You may obtain a copy
 * of the License at http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software distributed under
 * the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
 * OF ANY KIND, either express or implied. See the License for the specific language
 * governing permissions and limitations under the License.
 */ /*
 * Copyright 2020 Adobe. All rights reserved.
 * This file is licensed to you under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License. You may obtain a copy
 * of the License at http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software distributed under
 * the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
 * OF ANY KIND, either express or implied. See the License for the specific language
 * governing permissions and limitations under the License.
 */ 



/*
 * Copyright 2020 Adobe. All rights reserved.
 * This file is licensed to you under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License. You may obtain a copy
 * of the License at http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software distributed under
 * the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
 * OF ANY KIND, either express or implied. See the License for the specific language
 * governing permissions and limitations under the License.
 */ // @ts-ignore

/*
 * Copyright 2020 Adobe. All rights reserved.
 * This file is licensed to you under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License. You may obtain a copy
 * of the License at http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software distributed under
 * the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
 * OF ANY KIND, either express or implied. See the License for the specific language
 * governing permissions and limitations under the License.
 */ let $efdd61e59e023a1d$var$cachedRTLResult = null;
function $efdd61e59e023a1d$export$faf7630257ad4304(recalculate = false) {
    if ($efdd61e59e023a1d$var$cachedRTLResult === null || recalculate) {
        const outerDiv = document.createElement("div");
        const outerStyle = outerDiv.style;
        outerStyle.width = "50px";
        outerStyle.height = "50px";
        outerStyle.overflow = "scroll";
        outerStyle.direction = "rtl";
        const innerDiv = document.createElement("div");
        const innerStyle = innerDiv.style;
        innerStyle.width = "100px";
        innerStyle.height = "100px";
        outerDiv.appendChild(innerDiv);
        document.body.appendChild(outerDiv);
        if (outerDiv.scrollLeft > 0) $efdd61e59e023a1d$var$cachedRTLResult = "positive-descending";
        else {
            outerDiv.scrollLeft = 1;
            if (outerDiv.scrollLeft === 0) $efdd61e59e023a1d$var$cachedRTLResult = "negative";
            else $efdd61e59e023a1d$var$cachedRTLResult = "positive-ascending";
        }
        document.body.removeChild(outerDiv);
        return $efdd61e59e023a1d$var$cachedRTLResult;
    }
    return $efdd61e59e023a1d$var$cachedRTLResult;
}
function $efdd61e59e023a1d$export$1389d168952b34b5(node, direction) {
    let { scrollLeft: scrollLeft } = node;
    // scrollLeft in rtl locales differs across browsers, so normalize.
    // See comment by getRTLOffsetType below for details.
    if (direction === "rtl") {
        let { scrollWidth: scrollWidth, clientWidth: clientWidth } = node;
        switch($efdd61e59e023a1d$export$faf7630257ad4304()){
            case "negative":
                scrollLeft = -scrollLeft;
                break;
            case "positive-descending":
                scrollLeft = scrollWidth - clientWidth - scrollLeft;
                break;
        }
    }
    return scrollLeft;
}
function $efdd61e59e023a1d$export$ed5fd5ffe5ab0ac(node, direction, scrollLeft) {
    if (direction === "rtl") switch($efdd61e59e023a1d$export$faf7630257ad4304()){
        case "negative":
            scrollLeft = -scrollLeft;
            break;
        case "positive-ascending":
            break;
        default:
            {
                const { clientWidth: clientWidth, scrollWidth: scrollWidth } = node;
                scrollLeft = scrollWidth - clientWidth - scrollLeft;
                break;
            }
    }
    node.scrollLeft = scrollLeft;
}






let $00ca8c0b29e3e07c$var$isOldReact = (0, ($parcel$interopDefault($kYtlh$react))).version.startsWith("16.") || (0, ($parcel$interopDefault($kYtlh$react))).version.startsWith("17.");
function $00ca8c0b29e3e07c$var$ScrollView(props, ref) {
    let { contentSize: contentSize, onVisibleRectChange: onVisibleRectChange, children: children, innerStyle: innerStyle, sizeToFit: sizeToFit, onScrollStart: onScrollStart, onScrollEnd: onScrollEnd, scrollDirection: scrollDirection = "both", ...otherProps } = props;
    let defaultRef = (0, $kYtlh$react.useRef)();
    ref = ref || defaultRef;
    let state = (0, $kYtlh$react.useRef)({
        scrollTop: 0,
        scrollLeft: 0,
        scrollEndTime: 0,
        scrollTimeout: null,
        width: 0,
        height: 0,
        isScrolling: false
    }).current;
    let { direction: direction } = (0, $kYtlh$reactariai18n.useLocale)();
    let [isScrolling, setScrolling] = (0, $kYtlh$react.useState)(false);
    let onScroll = (0, $kYtlh$react.useCallback)((e)=>{
        if (e.target !== e.currentTarget) return;
        if (props.onScroll) props.onScroll(e);
        (0, $kYtlh$reactdom.flushSync)(()=>{
            let scrollTop = e.currentTarget.scrollTop;
            let scrollLeft = (0, $efdd61e59e023a1d$export$1389d168952b34b5)(e.currentTarget, direction);
            // Prevent rubber band scrolling from shaking when scrolling out of bounds
            state.scrollTop = Math.max(0, Math.min(scrollTop, contentSize.height - state.height));
            state.scrollLeft = Math.max(0, Math.min(scrollLeft, contentSize.width - state.width));
            onVisibleRectChange(new (0, $kYtlh$reactstatelyvirtualizer.Rect)(state.scrollLeft, state.scrollTop, state.width, state.height));
            if (!state.isScrolling) {
                state.isScrolling = true;
                setScrolling(true);
                if (onScrollStart) onScrollStart();
            }
            // So we don't constantly call clearTimeout and setTimeout,
            // keep track of the current timeout time and only reschedule
            // the timer when it is getting close.
            let now = Date.now();
            if (state.scrollEndTime <= now + 50) {
                state.scrollEndTime = now + 300;
                clearTimeout(state.scrollTimeout);
                state.scrollTimeout = setTimeout(()=>{
                    state.isScrolling = false;
                    setScrolling(false);
                    state.scrollTimeout = null;
                    if (onScrollEnd) onScrollEnd();
                }, 300);
            }
        });
    }, [
        props,
        direction,
        state,
        contentSize,
        onVisibleRectChange,
        onScrollStart,
        onScrollEnd
    ]);
    // eslint-disable-next-line arrow-body-style
    (0, $kYtlh$react.useEffect)(()=>{
        return ()=>{
            clearTimeout(state.scrollTimeout);
        };
    // eslint-disable-next-line react-hooks/exhaustive-deps
    }, []);
    let updateSize = (0, $kYtlh$react.useCallback)(()=>{
        let dom = ref.current;
        if (!dom) return;
        let w = dom.clientWidth;
        let h = dom.clientHeight;
        if (sizeToFit && contentSize.width > 0 && contentSize.height > 0) {
            if (sizeToFit === "width") w = Math.min(w, contentSize.width);
            else if (sizeToFit === "height") h = Math.min(h, contentSize.height);
        }
        if (state.width !== w || state.height !== h) {
            state.width = w;
            state.height = h;
            onVisibleRectChange(new (0, $kYtlh$reactstatelyvirtualizer.Rect)(state.scrollLeft, state.scrollTop, w, h));
        }
    }, [
        onVisibleRectChange,
        ref,
        state,
        sizeToFit,
        contentSize
    ]);
    (0, $kYtlh$reactariautils.useLayoutEffect)(()=>{
        updateSize();
    }, [
        updateSize
    ]);
    let raf = (0, $kYtlh$react.useRef)();
    let onResize = ()=>{
        var _raf;
        var _current;
        if ($00ca8c0b29e3e07c$var$isOldReact) (_current = (_raf = raf).current) !== null && _current !== void 0 ? _current : _raf.current = requestAnimationFrame(()=>{
            updateSize();
            raf.current = null;
        });
        else updateSize();
    };
    (0, $kYtlh$reactariautils.useResizeObserver)({
        ref: ref,
        onResize: onResize
    });
    (0, $kYtlh$react.useEffect)(()=>{
        return ()=>{
            if (raf.current) cancelAnimationFrame(raf.current);
        };
    }, []);
    let style = {
        // Reset padding so that relative positioning works correctly. Padding will be done in JS layout.
        padding: 0,
        ...otherProps.style
    };
    if (scrollDirection === "horizontal") {
        style.overflowX = "auto";
        style.overflowY = "hidden";
    } else if (scrollDirection === "vertical" || contentSize.width === state.width) {
        // Set overflow-x: hidden if content size is equal to the width of the scroll view.
        // This prevents horizontal scrollbars from flickering during resizing due to resize observer
        // firing slower than the frame rate, which may cause an infinite re-render loop.
        style.overflowY = "auto";
        style.overflowX = "hidden";
    } else style.overflow = "auto";
    innerStyle = {
        width: contentSize.width,
        height: contentSize.height,
        pointerEvents: isScrolling ? "none" : "auto",
        position: "relative",
        ...innerStyle
    };
    return /*#__PURE__*/ (0, ($parcel$interopDefault($kYtlh$react))).createElement("div", {
        ...otherProps,
        style: style,
        ref: ref,
        onScroll: onScroll
    }, /*#__PURE__*/ (0, ($parcel$interopDefault($kYtlh$react))).createElement("div", {
        role: "presentation",
        style: innerStyle
    }, children));
}
const $00ca8c0b29e3e07c$export$5665e3d6be6adea = /*#__PURE__*/ (0, ($parcel$interopDefault($kYtlh$react))).forwardRef($00ca8c0b29e3e07c$var$ScrollView);


/*
 * Copyright 2020 Adobe. All rights reserved.
 * This file is licensed to you under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License. You may obtain a copy
 * of the License at http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software distributed under
 * the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
 * OF ANY KIND, either express or implied. See the License for the specific language
 * governing permissions and limitations under the License.
 */ 

/*
 * Copyright 2020 Adobe. All rights reserved.
 * This file is licensed to you under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License. You may obtain a copy
 * of the License at http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software distributed under
 * the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
 * OF ANY KIND, either express or implied. See the License for the specific language
 * governing permissions and limitations under the License.
 */ 


function $7d70e069fceb2deb$export$1da781778207e0a2(options) {
    let { layoutInfo: layoutInfo, virtualizer: virtualizer, ref: ref } = options;
    let updateSize = (0, $kYtlh$react.useCallback)(()=>{
        let size = $7d70e069fceb2deb$var$getSize(ref.current);
        virtualizer.updateItemSize(layoutInfo.key, size);
    }, [
        virtualizer,
        layoutInfo.key,
        ref
    ]);
    (0, $kYtlh$reactariautils.useLayoutEffect)(()=>{
        if (layoutInfo.estimatedSize) updateSize();
    });
    return {
        updateSize: updateSize
    };
}
function $7d70e069fceb2deb$var$getSize(node) {
    // Reset height before measuring so we get the intrinsic size
    let height = node.style.height;
    node.style.height = "";
    let size = new (0, $kYtlh$reactstatelyvirtualizer.Size)(node.scrollWidth, node.scrollHeight);
    node.style.height = height;
    return size;
}


function $d6a26279cc31826b$export$6796df8ba7398521(props) {
    let { className: className, layoutInfo: layoutInfo, virtualizer: virtualizer, parent: parent, children: children } = props;
    let { direction: direction } = (0, $kYtlh$reactariai18n.useLocale)();
    let ref = (0, $kYtlh$react.useRef)();
    (0, $7d70e069fceb2deb$export$1da781778207e0a2)({
        layoutInfo: layoutInfo,
        virtualizer: virtualizer,
        ref: ref
    });
    return /*#__PURE__*/ (0, ($parcel$interopDefault($kYtlh$react))).createElement("div", {
        role: "presentation",
        ref: ref,
        className: className,
        style: $d6a26279cc31826b$export$1481e64fbe01b8b3(layoutInfo, direction, parent)
    }, children);
}
let $d6a26279cc31826b$var$cache = new WeakMap();
function $d6a26279cc31826b$export$1481e64fbe01b8b3(layoutInfo, dir, parent) {
    let xProperty = dir === "rtl" ? "right" : "left";
    let cached = $d6a26279cc31826b$var$cache.get(layoutInfo);
    if (cached && cached[xProperty] != null) {
        if (!parent) return cached;
        // Invalidate if the parent position changed.
        let top = layoutInfo.rect.y - parent.rect.y;
        let x = layoutInfo.rect.x - parent.rect.x;
        if (cached.top === top && cached[xProperty] === x) return cached;
    }
    let style = {
        position: layoutInfo.isSticky ? "sticky" : "absolute",
        // Sticky elements are positioned in normal document flow. Display inline-block so that they don't push other sticky columns onto the following rows.
        display: layoutInfo.isSticky ? "inline-block" : undefined,
        overflow: layoutInfo.allowOverflow ? "visible" : "hidden",
        top: layoutInfo.rect.y - (parent ? parent.rect.y : 0),
        [xProperty]: layoutInfo.rect.x - (parent ? parent.rect.x : 0),
        transition: "all",
        WebkitTransition: "all",
        WebkitTransitionDuration: "inherit",
        transitionDuration: "inherit",
        width: layoutInfo.rect.width,
        height: layoutInfo.rect.height,
        opacity: layoutInfo.opacity,
        zIndex: layoutInfo.zIndex,
        transform: layoutInfo.transform,
        contain: "size layout style"
    };
    $d6a26279cc31826b$var$cache.set(layoutInfo, style);
    return style;
}


function $e1fb6f3669e1c329$var$Virtualizer(props, ref) {
    let { children: renderView, renderWrapper: renderWrapper, layout: layout, collection: collection, sizeToFit: sizeToFit, scrollDirection: scrollDirection, transitionDuration: transitionDuration, isLoading: // eslint-disable-next-line @typescript-eslint/no-unused-vars
    isLoading, onLoadMore: // eslint-disable-next-line @typescript-eslint/no-unused-vars
    onLoadMore, focusedKey: // eslint-disable-next-line @typescript-eslint/no-unused-vars
    focusedKey, shouldUseVirtualFocus: // eslint-disable-next-line @typescript-eslint/no-unused-vars
    shouldUseVirtualFocus, scrollToItem: // eslint-disable-next-line @typescript-eslint/no-unused-vars
    scrollToItem, autoFocus: // eslint-disable-next-line @typescript-eslint/no-unused-vars
    autoFocus, ...otherProps } = props;
    let fallbackRef = (0, $kYtlh$react.useRef)();
    ref = ref || fallbackRef;
    let state = (0, $kYtlh$reactstatelyvirtualizer.useVirtualizerState)({
        transitionDuration: transitionDuration,
        layout: layout,
        collection: collection,
        renderView: renderView,
        renderWrapper: renderWrapper || $e1fb6f3669e1c329$var$defaultRenderWrapper,
        onVisibleRectChange (rect) {
            ref.current.scrollLeft = rect.x;
            ref.current.scrollTop = rect.y;
        }
    });
    let { virtualizerProps: virtualizerProps, scrollViewProps: scrollViewProps } = $e1fb6f3669e1c329$export$dd6d526d88b5a137(props, state, ref);
    return /*#__PURE__*/ (0, ($parcel$interopDefault($kYtlh$react))).createElement((0, $00ca8c0b29e3e07c$export$5665e3d6be6adea), {
        ...(0, $kYtlh$reactariautils.mergeProps)(otherProps, virtualizerProps, scrollViewProps),
        ref: ref,
        innerStyle: state.isAnimating ? {
            transition: `none ${state.virtualizer.transitionDuration}ms`
        } : undefined,
        contentSize: state.contentSize,
        onScrollStart: state.startScrolling,
        onScrollEnd: state.endScrolling,
        sizeToFit: sizeToFit,
        scrollDirection: scrollDirection
    }, state.visibleViews);
}
function $e1fb6f3669e1c329$export$dd6d526d88b5a137(props, state, ref) {
    let { focusedKey: focusedKey, scrollToItem: scrollToItem, shouldUseVirtualFocus: shouldUseVirtualFocus, isLoading: isLoading, onLoadMore: onLoadMore } = props;
    let { virtualizer: virtualizer } = state;
    // Scroll to the focusedKey when it changes. Actually focusing the focusedKey
    // is up to the implementation using Virtualizer since we don't have refs
    // to all of the item DOM nodes.
    let lastFocusedKey = (0, $kYtlh$react.useRef)(null);
    let isFocusWithin = (0, $kYtlh$react.useRef)(false);
    let autoFocus = (0, $kYtlh$react.useRef)(props.autoFocus);
    (0, $kYtlh$react.useEffect)(()=>{
        if (virtualizer.visibleRect.height === 0) return;
        // Only scroll the focusedKey into view if the modality is not pointer to avoid jumps in position when clicking/pressing tall items.
        let modality = (0, $kYtlh$reactariainteractions.getInteractionModality)();
        if (focusedKey !== lastFocusedKey.current && (modality !== "pointer" || autoFocus.current)) {
            autoFocus.current = false;
            if (scrollToItem) // If user provides scrolltoitem, then it is their responsibility to call scrollIntoViewport if desired
            // since we don't know if their scrollToItem may take some time to actually bring the active element into the virtualizer's visible rect.
            scrollToItem(focusedKey);
            else virtualizer.scrollToItem(focusedKey, {
                duration: 0
            });
        }
        lastFocusedKey.current = focusedKey;
    }, [
        focusedKey,
        virtualizer.visibleRect.height,
        virtualizer,
        lastFocusedKey,
        scrollToItem,
        ref
    ]);
    // Persist the focusedKey and prevent it from being removed from the DOM when scrolled out of view.
    virtualizer.persistedKeys = (0, $kYtlh$react.useMemo)(()=>focusedKey ? new Set([
            focusedKey
        ]) : new Set(), [
        focusedKey
    ]);
    let onFocus = (0, $kYtlh$react.useCallback)((e)=>{
        // If the focused item is scrolled out of view and is not in the DOM, the collection
        // will have tabIndex={0}. When tabbing in from outside, scroll the focused item into view.
        // Ignore focus events that bubble through portals (e.g. focus that happens on a menu popover child of the virtualizer)
        // Don't scroll focused key into view if modality is pointer to prevent sudden jump in position (e.g. CardView).
        let modality = (0, $kYtlh$reactariainteractions.getInteractionModality)();
        if (!isFocusWithin.current && ref.current.contains(e.target) && modality !== "pointer") {
            if (scrollToItem) scrollToItem(focusedKey);
            else virtualizer.scrollToItem(focusedKey, {
                duration: 0
            });
        }
        isFocusWithin.current = e.target !== ref.current;
    }, [
        ref,
        virtualizer,
        focusedKey,
        scrollToItem
    ]);
    let onBlur = (0, $kYtlh$react.useCallback)((e)=>{
        isFocusWithin.current = ref.current.contains(e.relatedTarget);
    }, [
        ref
    ]);
    // Set tabIndex to -1 if there is a focused key, otherwise 0 so that the collection
    // itself is tabbable. When the collection receives focus, we scroll the focused item back into
    // view, which will allow it to be properly focused. If using virtual focus, don't set a
    // tabIndex at all so that VoiceOver on iOS 14 doesn't try to move real DOM focus to the element anyway.
    let tabIndex;
    if (!shouldUseVirtualFocus) {
        // When there is no focusedKey the default tabIndex is 0. We include logic for empty collections too.
        // For collections that are empty, but have a link in the empty children we want to skip focusing this
        // and let focus move to the link similar to link moving to children.
        tabIndex = focusedKey != null ? -1 : 0;
        // If the collection is empty, we want the tabIndex provided from props (if any)
        // so that we handle when tabbable items are added to the empty state.
        if (virtualizer.collection.size === 0 && props.tabIndex != null) tabIndex = props.tabIndex;
    }
    // Handle scrolling, and call onLoadMore when nearing the bottom.
    let isLoadingRef = (0, $kYtlh$react.useRef)(isLoading);
    let prevProps = (0, $kYtlh$react.useRef)(props);
    let onVisibleRectChange = (0, $kYtlh$react.useCallback)((rect)=>{
        state.setVisibleRect(rect);
        if (!isLoadingRef.current && onLoadMore) {
            let scrollOffset = state.virtualizer.contentSize.height - rect.height * 2;
            if (rect.y > scrollOffset) {
                isLoadingRef.current = true;
                onLoadMore();
            }
        }
    }, [
        onLoadMore,
        state
    ]);
    let lastContentSize = (0, $kYtlh$react.useRef)(0);
    (0, $kYtlh$reactariautils.useLayoutEffect)(()=>{
        // If animating, wait until we're done.
        if (state.isAnimating) return;
        // Only update isLoadingRef if props object actually changed,
        // not if a local state change occurred.
        let wasLoading = isLoadingRef.current;
        if (props !== prevProps.current) {
            isLoadingRef.current = isLoading;
            prevProps.current = props;
        }
        let shouldLoadMore = !isLoadingRef.current && onLoadMore && state.contentSize.height > 0 && state.contentSize.height <= state.virtualizer.visibleRect.height && (wasLoading || state.contentSize.height !== lastContentSize.current);
        if (shouldLoadMore) {
            isLoadingRef.current = true;
            onLoadMore();
        }
        lastContentSize.current = state.contentSize.height;
    }, [
        state.contentSize,
        state.isAnimating,
        state.virtualizer,
        isLoading,
        onLoadMore,
        props
    ]);
    return {
        virtualizerProps: {
            tabIndex: tabIndex,
            onFocus: onFocus,
            onBlur: onBlur
        },
        scrollViewProps: {
            onVisibleRectChange: onVisibleRectChange
        }
    };
}
// forwardRef doesn't support generic parameters, so cast the result to the correct type
// https://stackoverflow.com/questions/58469229/react-with-typescript-generics-while-using-react-forwardref
const $e1fb6f3669e1c329$export$89be5a243e59c4b2 = /*#__PURE__*/ (0, ($parcel$interopDefault($kYtlh$react))).forwardRef($e1fb6f3669e1c329$var$Virtualizer);
function $e1fb6f3669e1c329$var$defaultRenderWrapper(parent, reusableView) {
    return /*#__PURE__*/ (0, ($parcel$interopDefault($kYtlh$react))).createElement((0, $d6a26279cc31826b$export$6796df8ba7398521), {
        key: reusableView.key,
        layoutInfo: reusableView.layoutInfo,
        virtualizer: reusableView.virtualizer,
        parent: parent === null || parent === void 0 ? void 0 : parent.layoutInfo
    }, reusableView.rendered);
}








//# sourceMappingURL=main.js.map
