import $7dfcac1a0c98c789$exports from "./ar-AE.mjs";
import $f311c26671219eca$exports from "./bg-BG.mjs";
import $1aa4ade186550f72$exports from "./cs-CZ.mjs";
import $b6b0ea1b94a7633c$exports from "./da-DK.mjs";
import $d10e4f47c744ad52$exports from "./de-DE.mjs";
import $b3d2bb9abce688ab$exports from "./el-GR.mjs";
import $f9b46437e610cca1$exports from "./en-US.mjs";
import $204b5c01bd3acf26$exports from "./es-ES.mjs";
import $110bdd83348ecbc0$exports from "./et-EE.mjs";
import $87d3ccd5e347c7cc$exports from "./fi-FI.mjs";
import $a5de891427686596$exports from "./fr-FR.mjs";
import $ad7f4c66d85b4494$exports from "./he-IL.mjs";
import $4aa59f3c6a796cae$exports from "./hr-HR.mjs";
import $d8d3646556c40586$exports from "./hu-HU.mjs";
import $982d558b45395246$exports from "./it-IT.mjs";
import $6a0cf387b9de036c$exports from "./ja-JP.mjs";
import $a97fefa2956f4bcb$exports from "./ko-KR.mjs";
import $5fb5837f94e1c150$exports from "./lt-LT.mjs";
import $5b2e5709864cc922$exports from "./lv-LV.mjs";
import $ee15bb8efb18cc69$exports from "./nb-NO.mjs";
import $1daf2d4602e26ac4$exports from "./nl-NL.mjs";
import $7115429b0f60511f$exports from "./pl-PL.mjs";
import $5edd453ae5d4a8bc$exports from "./pt-BR.mjs";
import $5f431994f708535e$exports from "./pt-PT.mjs";
import $107b5e2e45e971f1$exports from "./ro-RO.mjs";
import $d4b9c2f01c1892f7$exports from "./ru-RU.mjs";
import $dbdc1942894e83e4$exports from "./sk-SK.mjs";
import $fbaaaaebd547d998$exports from "./sl-SI.mjs";
import $a0caa33f1e264489$exports from "./sr-SP.mjs";
import $d576b66176f5c0ff$exports from "./sv-SE.mjs";
import $0681f168c13d8f2a$exports from "./tr-TR.mjs";
import $2bfbc1f42c1cf5a7$exports from "./uk-UA.mjs";
import $d0f488d433b55b8a$exports from "./zh-CN.mjs";
import $46168b0dce85301e$exports from "./zh-TW.mjs";
import {useInteractionModality as $fP8tg$useInteractionModality, getInteractionModality as $fP8tg$getInteractionModality, setInteractionModality as $fP8tg$setInteractionModality, useFocus as $fP8tg$useFocus} from "@react-aria/interactions";
import $fP8tg$react, {useRef as $fP8tg$useRef, useState as $fP8tg$useState, useEffect as $fP8tg$useEffect, useCallback as $fP8tg$useCallback, useImperativeHandle as $fP8tg$useImperativeHandle} from "react";
import {useGlobalListeners as $fP8tg$useGlobalListeners, useLayoutEffect as $fP8tg$useLayoutEffect, useDescription as $fP8tg$useDescription, isVirtualPointerEvent as $fP8tg$isVirtualPointerEvent, isVirtualClick as $fP8tg$isVirtualClick, useEffectEvent as $fP8tg$useEffectEvent, isMac as $fP8tg$isMac, isIPad as $fP8tg$isIPad, useId as $fP8tg$useId, mergeProps as $fP8tg$mergeProps, isScrollable as $fP8tg$isScrollable, getScrollParent as $fP8tg$getScrollParent, isWebKit as $fP8tg$isWebKit, isIOS as $fP8tg$isIOS, chain as $fP8tg$chain} from "@react-aria/utils";
import {useLocalizedStringFormatter as $fP8tg$useLocalizedStringFormatter, useLocale as $fP8tg$useLocale} from "@react-aria/i18n";
import {announce as $fP8tg$announce} from "@react-aria/live-announcer";
import {ariaHideOutside as $fP8tg$ariaHideOutside} from "@react-aria/overlays";
import {flushSync as $fP8tg$flushSync} from "react-dom";


function $parcel$interopDefault(a) {
  return a && a.__esModule ? a.default : a;
}
/*
 * Copyright 2020 Adobe. All rights reserved.
 * This file is licensed to you under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License. You may obtain a copy
 * of the License at http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software distributed under
 * the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
 * OF ANY KIND, either express or implied. See the License for the specific language
 * governing permissions and limitations under the License.
 */ /*
 * Copyright 2020 Adobe. All rights reserved.
 * This file is licensed to you under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License. You may obtain a copy
 * of the License at http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software distributed under
 * the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
 * OF ANY KIND, either express or implied. See the License for the specific language
 * governing permissions and limitations under the License.
 */ /*
 * Copyright 2020 Adobe. All rights reserved.
 * This file is licensed to you under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License. You may obtain a copy
 * of the License at http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software distributed under
 * the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
 * OF ANY KIND, either express or implied. See the License for the specific language
 * governing permissions and limitations under the License.
 */ var $103790afe9474d1c$export$60b7b4bcf3903d8e;
(function(DROP_OPERATION) {
    DROP_OPERATION[DROP_OPERATION["none"] = 0] = "none";
    DROP_OPERATION[DROP_OPERATION["cancel"] = 0] = "cancel";
    DROP_OPERATION[DROP_OPERATION["move"] = 1] = "move";
    DROP_OPERATION[DROP_OPERATION["copy"] = 2] = "copy";
    DROP_OPERATION[DROP_OPERATION["link"] = 4] = "link";
    DROP_OPERATION[DROP_OPERATION["all"] = 7] = "all";
})($103790afe9474d1c$export$60b7b4bcf3903d8e || ($103790afe9474d1c$export$60b7b4bcf3903d8e = {}));
const $103790afe9474d1c$export$9bbdfc78cf083e16 = {
    ...$103790afe9474d1c$export$60b7b4bcf3903d8e,
    copyMove: 3,
    copyLink: 6,
    linkMove: 5,
    all: 7,
    uninitialized: 7
};
const $103790afe9474d1c$export$dd0165308d8bff45 = $103790afe9474d1c$var$invert($103790afe9474d1c$export$9bbdfc78cf083e16);
$103790afe9474d1c$export$dd0165308d8bff45[7] = "all"; // ensure we don't map to 'uninitialized'.
const $103790afe9474d1c$export$d7ebf00f36b7a95e = $103790afe9474d1c$var$invert($103790afe9474d1c$export$60b7b4bcf3903d8e);
const $103790afe9474d1c$export$608ecc6f1b23c35d = {
    none: "cancel",
    link: "link",
    copy: "copy",
    move: "move"
};
const $103790afe9474d1c$export$5eacb0769d26d3b2 = $103790afe9474d1c$var$invert($103790afe9474d1c$export$608ecc6f1b23c35d);
function $103790afe9474d1c$var$invert(object) {
    let res = {};
    for(let key in object)res[object[key]] = key;
    return res;
}
const $103790afe9474d1c$export$4a7729b856e9a690 = new Set([
    "text/plain",
    "text/uri-list",
    "text/html"
]);
const $103790afe9474d1c$export$fd9f9fc120c5402d = "application/vnd.react-aria.items+json";
const $103790afe9474d1c$export$f8fc6581787339b3 = "application/octet-stream";



const $7252cd45fc48c07c$export$dfdf5deeaf27473f = new WeakMap();
const $7252cd45fc48c07c$export$990fced5dfac2637 = Symbol();
function $7252cd45fc48c07c$export$3093291712f09a77(state) {
    let { id: id } = $7252cd45fc48c07c$export$dfdf5deeaf27473f.get(state);
    if (!id) throw new Error("Droppable item outside a droppable collection");
    return id;
}
function $7252cd45fc48c07c$export$7e397efd01d3db27(state) {
    let { ref: ref } = $7252cd45fc48c07c$export$dfdf5deeaf27473f.get(state);
    if (!ref) throw new Error("Droppable item outside a droppable collection");
    return ref;
}
function $7252cd45fc48c07c$export$e1d41611756c6326(items) {
    let types = new Set();
    for (let item of items)for (let type of Object.keys(item))types.add(type);
    return types;
}
function $7252cd45fc48c07c$var$mapModality(modality) {
    if (!modality) modality = "virtual";
    if (modality === "pointer") modality = "virtual";
    if (modality === "virtual" && typeof window !== "undefined" && "ontouchstart" in window) modality = "touch";
    return modality;
}
function $7252cd45fc48c07c$export$49bac5d6d4b352ea() {
    return $7252cd45fc48c07c$var$mapModality((0, $fP8tg$useInteractionModality)());
}
function $7252cd45fc48c07c$export$1fb2158d224b542c() {
    return $7252cd45fc48c07c$var$mapModality((0, $fP8tg$getInteractionModality)());
}
function $7252cd45fc48c07c$export$f9c1490890ddd063(dataTransfer, items) {
    // The data transfer API doesn't support more than one item of a given type at once.
    // In addition, only a small set of types are supported natively for transfer between applications.
    // We allow for both multiple items, as well as multiple representations of a single item.
    // In order to make our API work with the native API, we serialize all items to JSON and
    // store as a single native item. We only need to do this if there is more than one item
    // of the same type, or if an item has more than one representation. Otherwise the native
    // API is sufficient.
    //
    // The DataTransferItemList API also theoretically supports adding files, which would enable
    // dragging binary data out of the browser onto the user's desktop for example. Unfortunately,
    // this does not currently work in any browser, so it is not currently supported by our API.
    // See e.g. https://bugs.chromium.org/p/chromium/issues/detail?id=438479.
    let groupedByType = new Map();
    let needsCustomData = false;
    let customData = [];
    for (let item of items){
        let types = Object.keys(item);
        if (types.length > 1) needsCustomData = true;
        let dataByType = {};
        for (let type of types){
            let typeItems = groupedByType.get(type);
            if (!typeItems) {
                typeItems = [];
                groupedByType.set(type, typeItems);
            } else needsCustomData = true;
            let data = item[type];
            dataByType[type] = data;
            typeItems.push(data);
        }
        customData.push(dataByType);
    }
    for (let [type, items] of groupedByType)if ((0, $103790afe9474d1c$export$4a7729b856e9a690).has(type)) {
        // Only one item of a given type can be set on a data transfer.
        // Join all of the items together separated by newlines.
        let data = items.join("\n");
        dataTransfer.items.add(data, type);
    } else // Set data to the first item so we have access to the list of types.
    dataTransfer.items.add(items[0], type);
    if (needsCustomData) {
        let data = JSON.stringify(customData);
        dataTransfer.items.add(data, (0, $103790afe9474d1c$export$fd9f9fc120c5402d));
    }
}
class $7252cd45fc48c07c$export$7f04ce188c91447c {
    has(type) {
        if (this.includesUnknownTypes || type === $7252cd45fc48c07c$export$990fced5dfac2637 && this.types.has((0, $103790afe9474d1c$export$f8fc6581787339b3))) return true;
        return typeof type === "string" && this.types.has(type);
    }
    constructor(dataTransfer){
        this.types = new Set();
        let hasFiles = false;
        for (let item of dataTransfer.items)if (item.type !== (0, $103790afe9474d1c$export$fd9f9fc120c5402d)) {
            if (item.kind === "file") hasFiles = true;
            if (item.type) this.types.add(item.type);
            else // Files with unknown types or extensions that don't map to a known mime type
            // are sometimes exposed as an empty string by the browser. Map to a generic
            // mime type instead. Note that this could also be a directory as there's no
            // way to determine if something is a file or directory until drop.
            this.types.add((0, $103790afe9474d1c$export$f8fc6581787339b3));
        }
        // In Safari, when dragging files, the dataTransfer.items list is empty, but dataTransfer.types contains "Files".
        // Unfortunately, this doesn't tell us what types of files the user is dragging, so we need to assume that any
        // type the user checks for is included. See https://bugs.webkit.org/show_bug.cgi?id=223517.
        this.includesUnknownTypes = !hasFiles && dataTransfer.types.includes("Files");
    }
}
function $7252cd45fc48c07c$export$d9e760437831f8b3(dataTransfer) {
    let items = [];
    // If our custom drag type is available, use that. This is a JSON serialized
    // representation of all items in the drag, set when there are multiple items
    // of the same type, or an individual item has multiple representations.
    let hasCustomType = false;
    if (dataTransfer.types.includes((0, $103790afe9474d1c$export$fd9f9fc120c5402d))) try {
        let data = dataTransfer.getData((0, $103790afe9474d1c$export$fd9f9fc120c5402d));
        let parsed = JSON.parse(data);
        for (let item of parsed)items.push({
            kind: "text",
            types: new Set(Object.keys(item)),
            getText: (type)=>Promise.resolve(item[type])
        });
        hasCustomType = true;
    } catch (e) {
    // ignore
    }
    // Otherwise, map native drag items to items of a single representation.
    if (!hasCustomType) {
        let stringItems = new Map();
        for (let item of dataTransfer.items){
            if (item.kind === "string") // The data for all formats must be read here because the data transfer gets
            // cleared out after the event handler finishes. If the item has an empty string
            // as a type, the mime type is unknown. Map to a generic mime type instead.
            stringItems.set(item.type || (0, $103790afe9474d1c$export$f8fc6581787339b3), dataTransfer.getData(item.type));
            else if (item.kind === "file") {
                // Despite the name, webkitGetAsEntry is also implemented in Firefox and Edge.
                // In the future, we may use getAsFileSystemHandle instead, but that's currently
                // only implemented in Chrome.
                if (typeof item.webkitGetAsEntry === "function") {
                    let entry = item.webkitGetAsEntry();
                    // eslint-disable-next-line max-depth
                    if (!entry) continue;
                    // eslint-disable-next-line max-depth
                    if (entry.isFile) items.push($7252cd45fc48c07c$var$createFileItem(item.getAsFile()));
                    else if (entry.isDirectory) items.push($7252cd45fc48c07c$var$createDirectoryItem(entry));
                } else // Assume it's a file.
                items.push($7252cd45fc48c07c$var$createFileItem(item.getAsFile()));
            }
        }
        // All string items are different representations of the same item. There's no way to have
        // multiple string items at once in the current DataTransfer API.
        if (stringItems.size > 0) items.push({
            kind: "text",
            types: new Set(stringItems.keys()),
            getText: (type)=>Promise.resolve(stringItems.get(type))
        });
    }
    return items;
}
function $7252cd45fc48c07c$var$blobToString(blob) {
    if (typeof blob.text === "function") return blob.text();
    // Safari doesn't have the Blob#text() method yet...
    return new Promise((resolve, reject)=>{
        let reader = new FileReader;
        reader.onload = ()=>{
            resolve(reader.result);
        };
        reader.onerror = reject;
        reader.readAsText(blob);
    });
}
function $7252cd45fc48c07c$var$createFileItem(file) {
    return {
        kind: "file",
        type: file.type || (0, $103790afe9474d1c$export$f8fc6581787339b3),
        name: file.name,
        getText: ()=>$7252cd45fc48c07c$var$blobToString(file),
        getFile: ()=>Promise.resolve(file)
    };
}
function $7252cd45fc48c07c$var$createDirectoryItem(entry) {
    return {
        kind: "directory",
        name: entry.name,
        getEntries: ()=>$7252cd45fc48c07c$var$getEntries(entry)
    };
}
async function* $7252cd45fc48c07c$var$getEntries(item) {
    let reader = item.createReader();
    // We must call readEntries repeatedly because there may be a limit to the
    // number of entries that are returned at once.
    let entries;
    do {
        entries = await new Promise((resolve, reject)=>{
            reader.readEntries(resolve, reject);
        });
        for (let entry of entries){
            if (entry.isFile) {
                let file = await $7252cd45fc48c07c$var$getEntryFile(entry);
                yield $7252cd45fc48c07c$var$createFileItem(file);
            } else if (entry.isDirectory) yield $7252cd45fc48c07c$var$createDirectoryItem(entry);
        }
    }while (entries.length > 0);
}
function $7252cd45fc48c07c$var$getEntryFile(entry) {
    return new Promise((resolve, reject)=>entry.file(resolve, reject));
}
function $7252cd45fc48c07c$export$97fd558bdc44bea1(dropItem) {
    return dropItem.kind === "text";
}
function $7252cd45fc48c07c$export$a144e1752ebe0aa(dropItem) {
    return dropItem.kind === "file";
}
function $7252cd45fc48c07c$export$2b40a62bdbe6b2b0(dropItem) {
    return dropItem.kind === "directory";
}
let $7252cd45fc48c07c$export$6ca6700462636d0b = {
    draggingKeys: new Set()
};
function $7252cd45fc48c07c$export$f2be18a910c0caa6(ref) {
    $7252cd45fc48c07c$export$6ca6700462636d0b.draggingCollectionRef = ref;
}
function $7252cd45fc48c07c$export$72cb63bdda528276(keys) {
    $7252cd45fc48c07c$export$6ca6700462636d0b.draggingKeys = keys;
}
function $7252cd45fc48c07c$export$dac8db29d42db9a1(ref) {
    $7252cd45fc48c07c$export$6ca6700462636d0b.dropCollectionRef = ref;
}
function $7252cd45fc48c07c$export$70936501603e6c57() {
    $7252cd45fc48c07c$export$6ca6700462636d0b = {
        draggingKeys: new Set()
    };
}
function $7252cd45fc48c07c$export$6c10d32b362bfa5f(state) {
    $7252cd45fc48c07c$export$6ca6700462636d0b = state;
}
function $7252cd45fc48c07c$export$78bf638634500fa5(ref) {
    let { draggingCollectionRef: draggingCollectionRef, dropCollectionRef: dropCollectionRef } = $7252cd45fc48c07c$export$6ca6700462636d0b;
    return (draggingCollectionRef === null || draggingCollectionRef === void 0 ? void 0 : draggingCollectionRef.current) != null && draggingCollectionRef.current === ((ref === null || ref === void 0 ? void 0 : ref.current) || (dropCollectionRef === null || dropCollectionRef === void 0 ? void 0 : dropCollectionRef.current));
}
let $7252cd45fc48c07c$export$8e6636520ac15722;
function $7252cd45fc48c07c$export$64f52ed7349ddb84(dropEffect) {
    $7252cd45fc48c07c$export$8e6636520ac15722 = dropEffect;
}
let $7252cd45fc48c07c$export$f0130eb70b6347b8 = (0, $103790afe9474d1c$export$60b7b4bcf3903d8e).none;
function $7252cd45fc48c07c$export$6539bc8c3a0a2d67(o) {
    $7252cd45fc48c07c$export$f0130eb70b6347b8 = o;
}


/*
 * Copyright 2020 Adobe. All rights reserved.
 * This file is licensed to you under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License. You may obtain a copy
 * of the License at http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software distributed under
 * the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
 * OF ANY KIND, either express or implied. See the License for the specific language
 * governing permissions and limitations under the License.
 */ 
/*
 * Copyright 2020 Adobe. All rights reserved.
 * This file is licensed to you under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License. You may obtain a copy
 * of the License at http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software distributed under
 * the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
 * OF ANY KIND, either express or implied. See the License for the specific language
 * governing permissions and limitations under the License.
 */ 





let $67560de7c78cb232$var$dropTargets = new Map();
let $67560de7c78cb232$var$dropItems = new Map();
let $67560de7c78cb232$var$dragSession = null;
let $67560de7c78cb232$var$subscriptions = new Set();
function $67560de7c78cb232$export$c28d9fb4a54e471a(target) {
    $67560de7c78cb232$var$dropTargets.set(target.element, target);
    $67560de7c78cb232$var$dragSession === null || $67560de7c78cb232$var$dragSession === void 0 ? void 0 : $67560de7c78cb232$var$dragSession.updateValidDropTargets();
    return ()=>{
        $67560de7c78cb232$var$dropTargets.delete(target.element);
        $67560de7c78cb232$var$dragSession === null || $67560de7c78cb232$var$dragSession === void 0 ? void 0 : $67560de7c78cb232$var$dragSession.updateValidDropTargets();
    };
}
function $67560de7c78cb232$export$aef80212ac99c003(item) {
    $67560de7c78cb232$var$dropItems.set(item.element, item);
    return ()=>{
        $67560de7c78cb232$var$dropItems.delete(item.element);
    };
}
function $67560de7c78cb232$export$549dbcf8649bf3b2(target, stringFormatter) {
    if ($67560de7c78cb232$var$dragSession) throw new Error("Cannot begin dragging while already dragging");
    $67560de7c78cb232$var$dragSession = new $67560de7c78cb232$var$DragSession(target, stringFormatter);
    requestAnimationFrame(()=>{
        $67560de7c78cb232$var$dragSession.setup();
        if ((0, $7252cd45fc48c07c$export$1fb2158d224b542c)() === "keyboard") $67560de7c78cb232$var$dragSession.next();
    });
    for (let cb of $67560de7c78cb232$var$subscriptions)cb();
}
function $67560de7c78cb232$export$418e185dd3f1b968() {
    let [session, setSession] = (0, $fP8tg$useState)($67560de7c78cb232$var$dragSession);
    (0, $fP8tg$useEffect)(()=>{
        let cb = ()=>setSession($67560de7c78cb232$var$dragSession);
        $67560de7c78cb232$var$subscriptions.add(cb);
        return ()=>{
            $67560de7c78cb232$var$subscriptions.delete(cb);
        };
    }, []);
    return session;
}
function $67560de7c78cb232$export$403bc76cbf68cf60() {
    return !!$67560de7c78cb232$var$dragSession;
}
function $67560de7c78cb232$var$endDragging() {
    $67560de7c78cb232$var$dragSession = null;
    for (let cb of $67560de7c78cb232$var$subscriptions)cb();
}
function $67560de7c78cb232$export$7454aff2e161f241(element) {
    for (let target of $67560de7c78cb232$var$dropTargets.keys()){
        if (target.contains(element)) return true;
    }
    return false;
}
const $67560de7c78cb232$var$CANCELED_EVENTS = [
    "pointerdown",
    "pointermove",
    "pointerenter",
    "pointerleave",
    "pointerover",
    "pointerout",
    "pointerup",
    "mousedown",
    "mousemove",
    "mouseenter",
    "mouseleave",
    "mouseover",
    "mouseout",
    "mouseup",
    "touchstart",
    "touchmove",
    "touchend",
    "focusin",
    "focusout"
];
const $67560de7c78cb232$var$CLICK_EVENTS = [
    "pointerup",
    "mouseup",
    "touchend"
];
const $67560de7c78cb232$var$MESSAGES = {
    keyboard: "dragStartedKeyboard",
    touch: "dragStartedTouch",
    virtual: "dragStartedVirtual"
};
class $67560de7c78cb232$var$DragSession {
    setup() {
        document.addEventListener("keydown", this.onKeyDown, true);
        document.addEventListener("keyup", this.onKeyUp, true);
        window.addEventListener("focus", this.onFocus, true);
        window.addEventListener("blur", this.onBlur, true);
        document.addEventListener("click", this.onClick, true);
        document.addEventListener("pointerdown", this.onPointerDown, true);
        for (let event of $67560de7c78cb232$var$CANCELED_EVENTS)document.addEventListener(event, this.cancelEvent, true);
        this.mutationObserver = new MutationObserver(()=>this.updateValidDropTargets());
        this.updateValidDropTargets();
        (0, $fP8tg$announce)(this.stringFormatter.format($67560de7c78cb232$var$MESSAGES[(0, $7252cd45fc48c07c$export$1fb2158d224b542c)()]));
    }
    teardown() {
        document.removeEventListener("keydown", this.onKeyDown, true);
        document.removeEventListener("keyup", this.onKeyUp, true);
        window.removeEventListener("focus", this.onFocus, true);
        window.removeEventListener("blur", this.onBlur, true);
        document.removeEventListener("click", this.onClick, true);
        document.removeEventListener("pointerdown", this.onPointerDown, true);
        for (let event of $67560de7c78cb232$var$CANCELED_EVENTS)document.removeEventListener(event, this.cancelEvent, true);
        this.mutationObserver.disconnect();
        this.restoreAriaHidden();
    }
    onKeyDown(e) {
        var _this_currentDropTarget;
        this.cancelEvent(e);
        if (e.key === "Escape") {
            this.cancel();
            return;
        }
        if (e.key === "Tab" && !(e.metaKey || e.altKey || e.ctrlKey)) {
            if (e.shiftKey) this.previous();
            else this.next();
        }
        if (typeof ((_this_currentDropTarget = this.currentDropTarget) === null || _this_currentDropTarget === void 0 ? void 0 : _this_currentDropTarget.onKeyDown) === "function") this.currentDropTarget.onKeyDown(e, this.dragTarget);
    }
    onKeyUp(e) {
        this.cancelEvent(e);
        if (e.key === "Enter") {
            if (e.altKey) this.activate();
            else this.drop();
        }
    }
    onFocus(e) {
        // Prevent focus events, except to the original drag target.
        if (e.target !== this.dragTarget.element) this.cancelEvent(e);
        // Ignore focus events on the window/document (JSDOM). Will be handled in onBlur, below.
        if (!(e.target instanceof HTMLElement) || e.target === this.dragTarget.element) return;
        let dropTarget = this.validDropTargets.find((target)=>target.element === e.target) || this.validDropTargets.find((target)=>target.element.contains(e.target));
        if (!dropTarget) {
            if (this.currentDropTarget) this.currentDropTarget.element.focus();
            else this.dragTarget.element.focus();
            return;
        }
        let item = $67560de7c78cb232$var$dropItems.get(e.target);
        this.setCurrentDropTarget(dropTarget, item);
    }
    onBlur(e) {
        if (e.target !== this.dragTarget.element) this.cancelEvent(e);
        // If nothing is gaining focus, or e.relatedTarget is the window/document (JSDOM),
        // restore focus back to the current drop target if any, or the original drag target.
        if (!e.relatedTarget || !(e.relatedTarget instanceof HTMLElement)) {
            if (this.currentDropTarget) this.currentDropTarget.element.focus();
            else this.dragTarget.element.focus();
        }
    }
    onClick(e) {
        this.cancelEvent(e);
        if ((0, $fP8tg$isVirtualClick)(e) || this.isVirtualClick) {
            if (e.target === this.dragTarget.element) {
                this.cancel();
                return;
            }
            let dropTarget = this.validDropTargets.find((target)=>target.element.contains(e.target));
            if (dropTarget) {
                let item = $67560de7c78cb232$var$dropItems.get(e.target);
                this.setCurrentDropTarget(dropTarget, item);
                this.drop(item);
            }
        }
    }
    onPointerDown(e) {
        // Android Talkback double tap has e.detail = 1 for onClick. Detect the virtual click in onPointerDown before onClick fires
        // so we can properly perform cancel and drop operations.
        this.cancelEvent(e);
        this.isVirtualClick = (0, $fP8tg$isVirtualPointerEvent)(e);
    }
    cancelEvent(e) {
        var _this_dragTarget;
        // Allow focusin and focusout on the drag target so focus ring works properly.
        if ((e.type === "focusin" || e.type === "focusout") && e.target === ((_this_dragTarget = this.dragTarget) === null || _this_dragTarget === void 0 ? void 0 : _this_dragTarget.element)) return;
        // Allow default for events that might cancel a click event
        if (!$67560de7c78cb232$var$CLICK_EVENTS.includes(e.type)) e.preventDefault();
        e.stopPropagation();
        e.stopImmediatePropagation();
    }
    updateValidDropTargets() {
        if (!this.mutationObserver) return;
        this.mutationObserver.disconnect();
        if (this.restoreAriaHidden) this.restoreAriaHidden();
        this.validDropTargets = $67560de7c78cb232$var$findValidDropTargets(this.dragTarget);
        // Shuffle drop target order based on starting drag target.
        if (this.validDropTargets.length > 0) {
            let nearestIndex = this.findNearestDropTarget();
            this.validDropTargets = [
                ...this.validDropTargets.slice(nearestIndex),
                ...this.validDropTargets.slice(0, nearestIndex)
            ];
        }
        if (this.currentDropTarget && !this.validDropTargets.includes(this.currentDropTarget)) this.setCurrentDropTarget(this.validDropTargets[0]);
        // Find valid drop items within collections
        let types = (0, $7252cd45fc48c07c$export$e1d41611756c6326)(this.dragTarget.items);
        let validDropItems = [
            ...$67560de7c78cb232$var$dropItems.values()
        ].filter((item)=>{
            if (typeof item.getDropOperation === "function") return item.getDropOperation(types, this.dragTarget.allowedDropOperations) !== "cancel";
            return true;
        });
        // Filter out drop targets that contain valid items. We don't want to stop hiding elements
        // other than the drop items that exist inside the collection.
        let visibleDropTargets = this.validDropTargets.filter((target)=>!validDropItems.some((item)=>target.element.contains(item.element)));
        this.restoreAriaHidden = (0, $fP8tg$ariaHideOutside)([
            this.dragTarget.element,
            ...validDropItems.map((item)=>item.element),
            ...visibleDropTargets.map((target)=>target.element)
        ]);
        this.mutationObserver.observe(document.body, {
            subtree: true,
            attributes: true,
            attributeFilter: [
                "aria-hidden"
            ]
        });
    }
    next() {
        if (!this.currentDropTarget) {
            this.setCurrentDropTarget(this.validDropTargets[0]);
            return;
        }
        let index = this.validDropTargets.indexOf(this.currentDropTarget);
        if (index < 0) {
            this.setCurrentDropTarget(this.validDropTargets[0]);
            return;
        }
        // If we've reached the end of the valid drop targets, cycle back to the original drag target.
        // This lets the user cancel the drag in case they don't have an Escape key (e.g. iPad keyboard case).
        if (index === this.validDropTargets.length - 1) {
            if (!this.dragTarget.element.closest('[aria-hidden="true"]')) {
                this.setCurrentDropTarget(null);
                this.dragTarget.element.focus();
            } else this.setCurrentDropTarget(this.validDropTargets[0]);
        } else this.setCurrentDropTarget(this.validDropTargets[index + 1]);
    }
    previous() {
        if (!this.currentDropTarget) {
            this.setCurrentDropTarget(this.validDropTargets[this.validDropTargets.length - 1]);
            return;
        }
        let index = this.validDropTargets.indexOf(this.currentDropTarget);
        if (index < 0) {
            this.setCurrentDropTarget(this.validDropTargets[this.validDropTargets.length - 1]);
            return;
        }
        // If we've reached the start of the valid drop targets, cycle back to the original drag target.
        // This lets the user cancel the drag in case they don't have an Escape key (e.g. iPad keyboard case).
        if (index === 0) {
            if (!this.dragTarget.element.closest('[aria-hidden="true"]')) {
                this.setCurrentDropTarget(null);
                this.dragTarget.element.focus();
            } else this.setCurrentDropTarget(this.validDropTargets[this.validDropTargets.length - 1]);
        } else this.setCurrentDropTarget(this.validDropTargets[index - 1]);
    }
    findNearestDropTarget() {
        let dragTargetRect = this.dragTarget.element.getBoundingClientRect();
        let minDistance = Infinity;
        let nearest = -1;
        for(let i = 0; i < this.validDropTargets.length; i++){
            let dropTarget = this.validDropTargets[i];
            let rect = dropTarget.element.getBoundingClientRect();
            let dx = rect.left - dragTargetRect.left;
            let dy = rect.top - dragTargetRect.top;
            let dist = dx * dx + dy * dy;
            if (dist < minDistance) {
                minDistance = dist;
                nearest = i;
            }
        }
        return nearest;
    }
    setCurrentDropTarget(dropTarget, item) {
        if (dropTarget !== this.currentDropTarget) {
            if (this.currentDropTarget && typeof this.currentDropTarget.onDropExit === "function") {
                let rect = this.currentDropTarget.element.getBoundingClientRect();
                this.currentDropTarget.onDropExit({
                    type: "dropexit",
                    x: rect.left + rect.width / 2,
                    y: rect.top + rect.height / 2
                });
            }
            this.currentDropTarget = dropTarget;
            if (dropTarget) {
                if (typeof dropTarget.onDropEnter === "function") {
                    let rect = dropTarget.element.getBoundingClientRect();
                    dropTarget.onDropEnter({
                        type: "dropenter",
                        x: rect.left + rect.width / 2,
                        y: rect.top + rect.height / 2
                    }, this.dragTarget);
                }
                if (!item) dropTarget === null || dropTarget === void 0 ? void 0 : dropTarget.element.focus();
            }
        }
        if (item !== this.currentDropItem) {
            if (item && typeof this.currentDropTarget.onDropTargetEnter === "function") this.currentDropTarget.onDropTargetEnter(item === null || item === void 0 ? void 0 : item.target);
            item === null || item === void 0 ? void 0 : item.element.focus();
            this.currentDropItem = item;
            // Announce first drop target after drag start announcement finishes.
            // Otherwise, it will never get announced because drag start announcement is assertive.
            if (!this.initialFocused) {
                (0, $fP8tg$announce)(item === null || item === void 0 ? void 0 : item.element.getAttribute("aria-label"), "polite");
                this.initialFocused = true;
            }
        }
    }
    end() {
        this.teardown();
        $67560de7c78cb232$var$endDragging();
        if (typeof this.dragTarget.onDragEnd === "function") {
            let target = this.currentDropTarget && this.dropOperation !== "cancel" ? this.currentDropTarget : this.dragTarget;
            let rect = target.element.getBoundingClientRect();
            this.dragTarget.onDragEnd({
                type: "dragend",
                x: rect.x + rect.width / 2,
                y: rect.y + rect.height / 2,
                dropOperation: this.dropOperation || "cancel"
            });
        }
        // Blur and re-focus the drop target so that the focus ring appears.
        if (this.currentDropTarget) {
            // Since we cancel all focus events in drag sessions, refire blur to make sure state gets updated so drag target doesn't think it's still focused
            // i.e. When you from one list to another during a drag session, we need the blur to fire on the first list after the drag.
            if (!this.dragTarget.element.contains(this.currentDropTarget.element)) {
                this.dragTarget.element.dispatchEvent(new FocusEvent("blur"));
                this.dragTarget.element.dispatchEvent(new FocusEvent("focusout", {
                    bubbles: true
                }));
            }
            // Re-focus the focusedKey upon reorder. This requires a React rerender between blurring and focusing.
            (0, $fP8tg$flushSync)(()=>{
                this.currentDropTarget.element.blur();
            });
            this.currentDropTarget.element.focus();
        }
        this.setCurrentDropTarget(null);
    }
    cancel() {
        this.setCurrentDropTarget(null);
        this.end();
        if (!this.dragTarget.element.closest('[aria-hidden="true"]')) this.dragTarget.element.focus();
        (0, $fP8tg$announce)(this.stringFormatter.format("dropCanceled"));
    }
    drop(item) {
        if (!this.currentDropTarget) {
            this.cancel();
            return;
        }
        if (typeof (item === null || item === void 0 ? void 0 : item.getDropOperation) === "function") {
            let types = (0, $7252cd45fc48c07c$export$e1d41611756c6326)(this.dragTarget.items);
            this.dropOperation = item.getDropOperation(types, this.dragTarget.allowedDropOperations);
        } else if (typeof this.currentDropTarget.getDropOperation === "function") {
            let types = (0, $7252cd45fc48c07c$export$e1d41611756c6326)(this.dragTarget.items);
            this.dropOperation = this.currentDropTarget.getDropOperation(types, this.dragTarget.allowedDropOperations);
        } else // TODO: show menu ??
        this.dropOperation = this.dragTarget.allowedDropOperations[0];
        if (typeof this.currentDropTarget.onDrop === "function") {
            let items = this.dragTarget.items.map((item)=>({
                    kind: "text",
                    types: new Set(Object.keys(item)),
                    getText: (type)=>Promise.resolve(item[type])
                }));
            let rect = this.currentDropTarget.element.getBoundingClientRect();
            this.currentDropTarget.onDrop({
                type: "drop",
                x: rect.left + rect.width / 2,
                y: rect.top + rect.height / 2,
                items: items,
                dropOperation: this.dropOperation
            }, item === null || item === void 0 ? void 0 : item.target);
        }
        this.end();
        (0, $fP8tg$announce)(this.stringFormatter.format("dropComplete"));
    }
    activate() {
        if (this.currentDropTarget && typeof this.currentDropTarget.onDropActivate === "function") {
            let rect = this.currentDropTarget.element.getBoundingClientRect();
            this.currentDropTarget.onDropActivate({
                type: "dropactivate",
                x: rect.left + rect.width / 2,
                y: rect.top + rect.height / 2
            });
        }
    }
    constructor(target, stringFormatter){
        this.dragTarget = target;
        this.stringFormatter = stringFormatter;
        this.onKeyDown = this.onKeyDown.bind(this);
        this.onKeyUp = this.onKeyUp.bind(this);
        this.onFocus = this.onFocus.bind(this);
        this.onBlur = this.onBlur.bind(this);
        this.onClick = this.onClick.bind(this);
        this.onPointerDown = this.onPointerDown.bind(this);
        this.cancelEvent = this.cancelEvent.bind(this);
        this.initialFocused = false;
    }
}
function $67560de7c78cb232$var$findValidDropTargets(options) {
    let types = (0, $7252cd45fc48c07c$export$e1d41611756c6326)(options.items);
    return [
        ...$67560de7c78cb232$var$dropTargets.values()
    ].filter((target)=>{
        if (target.element.closest('[aria-hidden="true"]')) return false;
        if (typeof target.getDropOperation === "function") return target.getDropOperation(types, options.allowedDropOperations) !== "cancel";
        return true;
    });
}




var $865c2eb7c00a83f1$exports = {};


































$865c2eb7c00a83f1$exports = {
    "ar-AE": $7dfcac1a0c98c789$exports,
    "bg-BG": $f311c26671219eca$exports,
    "cs-CZ": $1aa4ade186550f72$exports,
    "da-DK": $b6b0ea1b94a7633c$exports,
    "de-DE": $d10e4f47c744ad52$exports,
    "el-GR": $b3d2bb9abce688ab$exports,
    "en-US": $f9b46437e610cca1$exports,
    "es-ES": $204b5c01bd3acf26$exports,
    "et-EE": $110bdd83348ecbc0$exports,
    "fi-FI": $87d3ccd5e347c7cc$exports,
    "fr-FR": $a5de891427686596$exports,
    "he-IL": $ad7f4c66d85b4494$exports,
    "hr-HR": $4aa59f3c6a796cae$exports,
    "hu-HU": $d8d3646556c40586$exports,
    "it-IT": $982d558b45395246$exports,
    "ja-JP": $6a0cf387b9de036c$exports,
    "ko-KR": $a97fefa2956f4bcb$exports,
    "lt-LT": $5fb5837f94e1c150$exports,
    "lv-LV": $5b2e5709864cc922$exports,
    "nb-NO": $ee15bb8efb18cc69$exports,
    "nl-NL": $1daf2d4602e26ac4$exports,
    "pl-PL": $7115429b0f60511f$exports,
    "pt-BR": $5edd453ae5d4a8bc$exports,
    "pt-PT": $5f431994f708535e$exports,
    "ro-RO": $107b5e2e45e971f1$exports,
    "ru-RU": $d4b9c2f01c1892f7$exports,
    "sk-SK": $dbdc1942894e83e4$exports,
    "sl-SI": $fbaaaaebd547d998$exports,
    "sr-SP": $a0caa33f1e264489$exports,
    "sv-SE": $d576b66176f5c0ff$exports,
    "tr-TR": $0681f168c13d8f2a$exports,
    "uk-UA": $2bfbc1f42c1cf5a7$exports,
    "zh-CN": $d0f488d433b55b8a$exports,
    "zh-TW": $46168b0dce85301e$exports
};




const $8253ed7ece74b463$var$MESSAGES = {
    keyboard: {
        start: "dragDescriptionKeyboard",
        end: "endDragKeyboard"
    },
    touch: {
        start: "dragDescriptionTouch",
        end: "endDragTouch"
    },
    virtual: {
        start: "dragDescriptionVirtual",
        end: "endDragVirtual"
    }
};
function $8253ed7ece74b463$export$7941f8aafa4b6021(options) {
    let { hasDragButton: hasDragButton } = options;
    let stringFormatter = (0, $fP8tg$useLocalizedStringFormatter)((0, (/*@__PURE__*/$parcel$interopDefault($865c2eb7c00a83f1$exports))), "@react-aria/dnd");
    let state = (0, $fP8tg$useRef)({
        options: options,
        x: 0,
        y: 0
    }).current;
    state.options = options;
    let isDraggingRef = (0, $fP8tg$useRef)(false);
    let [isDragging, setDraggingState] = (0, $fP8tg$useState)(false);
    let setDragging = (isDragging)=>{
        isDraggingRef.current = isDragging;
        setDraggingState(isDragging);
    };
    let { addGlobalListener: addGlobalListener, removeAllGlobalListeners: removeAllGlobalListeners } = (0, $fP8tg$useGlobalListeners)();
    let modalityOnPointerDown = (0, $fP8tg$useRef)(null);
    let onDragStart = (e)=>{
        var _options_preview;
        if (e.defaultPrevented) return;
        // Prevent the drag event from propagating to any parent draggables
        e.stopPropagation();
        // If this drag was initiated by a mobile screen reader (e.g. VoiceOver or TalkBack), enter virtual dragging mode.
        if (modalityOnPointerDown.current === "virtual") {
            e.preventDefault();
            startDragging(e.target);
            modalityOnPointerDown.current = null;
            return;
        }
        if (typeof options.onDragStart === "function") options.onDragStart({
            type: "dragstart",
            x: e.clientX,
            y: e.clientY
        });
        let items = options.getItems();
        (0, $7252cd45fc48c07c$export$f9c1490890ddd063)(e.dataTransfer, items);
        let allowed = (0, $103790afe9474d1c$export$60b7b4bcf3903d8e).all;
        if (typeof options.getAllowedDropOperations === "function") {
            let allowedOperations = options.getAllowedDropOperations();
            allowed = (0, $103790afe9474d1c$export$60b7b4bcf3903d8e).none;
            for (let operation of allowedOperations)allowed |= (0, $103790afe9474d1c$export$60b7b4bcf3903d8e)[operation] || (0, $103790afe9474d1c$export$60b7b4bcf3903d8e).none;
        }
        (0, $7252cd45fc48c07c$export$6539bc8c3a0a2d67)(allowed);
        e.dataTransfer.effectAllowed = (0, $103790afe9474d1c$export$dd0165308d8bff45)[allowed] || "none";
        // If there is a preview option, use it to render a custom preview image that will
        // appear under the pointer while dragging. If not, the element itself is dragged by the browser.
        if (typeof ((_options_preview = options.preview) === null || _options_preview === void 0 ? void 0 : _options_preview.current) === "function") options.preview.current(items, (node)=>{
            // Compute the offset that the preview will appear under the mouse.
            // If possible, this is based on the point the user clicked on the target.
            // If the preview is much smaller, then just use the center point of the preview.
            let size = node.getBoundingClientRect();
            let rect = e.currentTarget.getBoundingClientRect();
            let x = e.clientX - rect.x;
            let y = e.clientY - rect.y;
            if (x > size.width || y > size.height) {
                x = size.width / 2;
                y = size.height / 2;
            }
            // Rounding height to an even number prevents blurry preview seen on some screens
            let height = 2 * Math.round(size.height / 2);
            node.style.height = `${height}px`;
            e.dataTransfer.setDragImage(node, x, y);
        });
        // Enforce that drops are handled by useDrop.
        addGlobalListener(window, "drop", (e)=>{
            e.preventDefault();
            e.stopPropagation();
            console.warn("Drags initiated from the React Aria useDrag hook may only be dropped on a target created with useDrop. This ensures that a keyboard and screen reader accessible alternative is available.");
        }, {
            once: true
        });
        state.x = e.clientX;
        state.y = e.clientY;
        // Wait a frame before we set dragging to true so that the browser has time to
        // render the preview image before we update the element that has been dragged.
        requestAnimationFrame(()=>{
            setDragging(true);
        });
    };
    let onDrag = (e)=>{
        // Prevent the drag event from propagating to any parent draggables
        e.stopPropagation();
        if (e.clientX === state.x && e.clientY === state.y) return;
        if (typeof options.onDragMove === "function") options.onDragMove({
            type: "dragmove",
            x: e.clientX,
            y: e.clientY
        });
        state.x = e.clientX;
        state.y = e.clientY;
    };
    let onDragEnd = (e)=>{
        // Prevent the drag event from propagating to any parent draggables
        e.stopPropagation();
        if (typeof options.onDragEnd === "function") {
            let event = {
                type: "dragend",
                x: e.clientX,
                y: e.clientY,
                dropOperation: (0, $103790afe9474d1c$export$608ecc6f1b23c35d)[e.dataTransfer.dropEffect]
            };
            // Chrome Android always returns none as its dropEffect so we use the drop effect set in useDrop via
            // onDragEnter/onDragOver instead. https://bugs.chromium.org/p/chromium/issues/detail?id=1353951
            if (0, $7252cd45fc48c07c$export$8e6636520ac15722) event.dropOperation = (0, $103790afe9474d1c$export$608ecc6f1b23c35d)[0, $7252cd45fc48c07c$export$8e6636520ac15722];
            options.onDragEnd(event);
        }
        setDragging(false);
        removeAllGlobalListeners();
        (0, $7252cd45fc48c07c$export$6539bc8c3a0a2d67)((0, $103790afe9474d1c$export$60b7b4bcf3903d8e).none);
        (0, $7252cd45fc48c07c$export$64f52ed7349ddb84)(undefined);
    };
    // If the dragged element is removed from the DOM via onDrop, onDragEnd won't fire: https://bugzilla.mozilla.org/show_bug.cgi?id=460801
    // In this case, we need to manually call onDragEnd on cleanup
    // eslint-disable-next-line arrow-body-style
    (0, $fP8tg$useLayoutEffect)(()=>{
        return ()=>{
            if (isDraggingRef.current) {
                if (typeof state.options.onDragEnd === "function") {
                    let event = {
                        type: "dragend",
                        x: 0,
                        y: 0,
                        dropOperation: (0, $103790afe9474d1c$export$608ecc6f1b23c35d)[(0, $7252cd45fc48c07c$export$8e6636520ac15722) || "none"]
                    };
                    state.options.onDragEnd(event);
                }
                setDragging(false);
                (0, $7252cd45fc48c07c$export$6539bc8c3a0a2d67)((0, $103790afe9474d1c$export$60b7b4bcf3903d8e).none);
                (0, $7252cd45fc48c07c$export$64f52ed7349ddb84)(undefined);
            }
        };
    }, [
        state
    ]);
    let onPress = (e)=>{
        if (e.pointerType !== "keyboard" && e.pointerType !== "virtual") return;
        startDragging(e.target);
    };
    let startDragging = (target)=>{
        if (typeof state.options.onDragStart === "function") {
            let rect = target.getBoundingClientRect();
            state.options.onDragStart({
                type: "dragstart",
                x: rect.x + rect.width / 2,
                y: rect.y + rect.height / 2
            });
        }
        $67560de7c78cb232$export$549dbcf8649bf3b2({
            element: target,
            items: state.options.getItems(),
            allowedDropOperations: typeof state.options.getAllowedDropOperations === "function" ? state.options.getAllowedDropOperations() : [
                "move",
                "copy",
                "link"
            ],
            onDragEnd (e) {
                setDragging(false);
                if (typeof state.options.onDragEnd === "function") state.options.onDragEnd(e);
            }
        }, stringFormatter);
        setDragging(true);
    };
    let modality = (0, $7252cd45fc48c07c$export$49bac5d6d4b352ea)();
    let message = !isDragging ? $8253ed7ece74b463$var$MESSAGES[modality].start : $8253ed7ece74b463$var$MESSAGES[modality].end;
    let descriptionProps = (0, $fP8tg$useDescription)(stringFormatter.format(message));
    let interactions;
    if (!hasDragButton) // If there's no separate button to trigger accessible drag and drop mode,
    // then add event handlers to the draggable element itself to start dragging.
    // For keyboard, we use the Enter key in a capturing listener to prevent other
    // events such as selection from also occurring. We attempt to infer whether a
    // pointer event (e.g. long press) came from a touch screen reader, and then initiate
    // dragging in the native onDragStart listener above.
    interactions = {
        ...descriptionProps,
        onPointerDown (e) {
            modalityOnPointerDown.current = (0, $fP8tg$isVirtualPointerEvent)(e.nativeEvent) ? "virtual" : e.pointerType;
            // Try to detect virtual drag passthrough gestures.
            if (e.width < 1 && e.height < 1) // iOS VoiceOver.
            modalityOnPointerDown.current = "virtual";
            else {
                let rect = e.currentTarget.getBoundingClientRect();
                let offsetX = e.clientX - rect.x;
                let offsetY = e.clientY - rect.y;
                let centerX = rect.width / 2;
                let centerY = rect.height / 2;
                if (Math.abs(offsetX - centerX) <= 0.5 && Math.abs(offsetY - centerY) <= 0.5) // Android TalkBack.
                modalityOnPointerDown.current = "virtual";
                else modalityOnPointerDown.current = e.pointerType;
            }
        },
        onKeyDownCapture (e) {
            if (e.target === e.currentTarget && e.key === "Enter") {
                e.preventDefault();
                e.stopPropagation();
            }
        },
        onKeyUpCapture (e) {
            if (e.target === e.currentTarget && e.key === "Enter") {
                e.preventDefault();
                e.stopPropagation();
                startDragging(e.target);
            }
        },
        onClick (e) {
            // Handle NVDA/JAWS in browse mode, and touch screen readers. In this case, no keyboard events are fired.
            if ((0, $fP8tg$isVirtualClick)(e.nativeEvent) || modalityOnPointerDown.current === "virtual") {
                e.preventDefault();
                e.stopPropagation();
                startDragging(e.target);
            }
        }
    };
    return {
        dragProps: {
            ...interactions,
            draggable: "true",
            onDragStart: onDragStart,
            onDrag: onDrag,
            onDragEnd: onDragEnd
        },
        dragButtonProps: {
            ...descriptionProps,
            onPress: onPress
        },
        isDragging: isDragging
    };
}


/*
 * Copyright 2020 Adobe. All rights reserved.
 * This file is licensed to you under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License. You may obtain a copy
 * of the License at http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software distributed under
 * the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
 * OF ANY KIND, either express or implied. See the License for the specific language
 * governing permissions and limitations under the License.
 */ 




/*
 * Copyright 2020 Adobe. All rights reserved.
 * This file is licensed to you under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License. You may obtain a copy
 * of the License at http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software distributed under
 * the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
 * OF ANY KIND, either express or implied. See the License for the specific language
 * governing permissions and limitations under the License.
 */ 




const $224594fe3e57ff1e$var$MESSAGES = {
    keyboard: "dropDescriptionKeyboard",
    touch: "dropDescriptionTouch",
    virtual: "dropDescriptionVirtual"
};
function $224594fe3e57ff1e$export$62447ad3d2ec7da6() {
    let stringFormatter = (0, $fP8tg$useLocalizedStringFormatter)((0, (/*@__PURE__*/$parcel$interopDefault($865c2eb7c00a83f1$exports))), "@react-aria/dnd");
    let modality = (0, $7252cd45fc48c07c$export$49bac5d6d4b352ea)();
    let dragSession = $67560de7c78cb232$export$418e185dd3f1b968();
    let descriptionProps = (0, $fP8tg$useDescription)(dragSession ? stringFormatter.format($224594fe3e57ff1e$var$MESSAGES[modality]) : "");
    return {
        dropProps: {
            ...descriptionProps,
            // Mobile Safari does not properly bubble click events on elements except links or inputs
            // unless there is an onclick handler bound directly to the element itself. By adding this
            // handler, React will take care of adding that for us, and we are able to handle document
            // level click events in the DragManager.
            // See https://www.quirksmode.org/blog/archives/2010/09/click_event_del.html
            onClick: ()=>{}
        }
    };
}


const $5c06e4929e123553$var$DROP_ACTIVATE_TIMEOUT = 800;
function $5c06e4929e123553$export$ccdee5eaf73cf661(options) {
    let { hasDropButton: hasDropButton } = options;
    let [isDropTarget, setDropTarget] = (0, $fP8tg$useState)(false);
    let state = (0, $fP8tg$useRef)({
        x: 0,
        y: 0,
        dragOverElements: new Set(),
        dropEffect: "none",
        allowedOperations: (0, $103790afe9474d1c$export$60b7b4bcf3903d8e).all,
        dropActivateTimer: null
    }).current;
    let fireDropEnter = (e)=>{
        setDropTarget(true);
        if (typeof options.onDropEnter === "function") {
            let rect = e.currentTarget.getBoundingClientRect();
            options.onDropEnter({
                type: "dropenter",
                x: e.clientX - rect.x,
                y: e.clientY - rect.y
            });
        }
    };
    let fireDropExit = (e)=>{
        setDropTarget(false);
        if (typeof options.onDropExit === "function") {
            let rect = e.currentTarget.getBoundingClientRect();
            options.onDropExit({
                type: "dropexit",
                x: e.clientX - rect.x,
                y: e.clientY - rect.y
            });
        }
    };
    let onDragOver = (e)=>{
        e.preventDefault();
        e.stopPropagation();
        let allowedOperations = $5c06e4929e123553$var$getAllowedOperations(e);
        if (e.clientX === state.x && e.clientY === state.y && allowedOperations === state.allowedOperations) {
            e.dataTransfer.dropEffect = state.dropEffect;
            return;
        }
        state.x = e.clientX;
        state.y = e.clientY;
        let prevDropEffect = state.dropEffect;
        // Update drop effect if allowed drop operations changed (e.g. user pressed modifier key).
        if (allowedOperations !== state.allowedOperations) {
            let allowedOps = $5c06e4929e123553$var$allowedOperationsToArray(allowedOperations);
            let dropOperation = allowedOps[0];
            if (typeof options.getDropOperation === "function") {
                let types = new (0, $7252cd45fc48c07c$export$7f04ce188c91447c)(e.dataTransfer);
                dropOperation = $5c06e4929e123553$var$getDropOperation(allowedOperations, options.getDropOperation(types, allowedOps));
            }
            state.dropEffect = (0, $103790afe9474d1c$export$5eacb0769d26d3b2)[dropOperation] || "none";
        }
        if (typeof options.getDropOperationForPoint === "function") {
            let types = new (0, $7252cd45fc48c07c$export$7f04ce188c91447c)(e.dataTransfer);
            let rect = e.currentTarget.getBoundingClientRect();
            let dropOperation = $5c06e4929e123553$var$getDropOperation(allowedOperations, options.getDropOperationForPoint(types, $5c06e4929e123553$var$allowedOperationsToArray(allowedOperations), state.x - rect.x, state.y - rect.y));
            state.dropEffect = (0, $103790afe9474d1c$export$5eacb0769d26d3b2)[dropOperation] || "none";
        }
        state.allowedOperations = allowedOperations;
        e.dataTransfer.dropEffect = state.dropEffect;
        // If the drop operation changes, update state and fire events appropriately.
        if (state.dropEffect === "none" && prevDropEffect !== "none") fireDropExit(e);
        else if (state.dropEffect !== "none" && prevDropEffect === "none") fireDropEnter(e);
        if (typeof options.onDropMove === "function" && state.dropEffect !== "none") {
            let rect = e.currentTarget.getBoundingClientRect();
            options.onDropMove({
                type: "dropmove",
                x: state.x - rect.x,
                y: state.y - rect.y
            });
        }
        clearTimeout(state.dropActivateTimer);
        if (typeof options.onDropActivate === "function" && state.dropEffect !== "none") {
            let rect = e.currentTarget.getBoundingClientRect();
            state.dropActivateTimer = setTimeout(()=>{
                options.onDropActivate({
                    type: "dropactivate",
                    x: state.x - rect.x,
                    y: state.y - rect.y
                });
            }, $5c06e4929e123553$var$DROP_ACTIVATE_TIMEOUT);
        }
    };
    let onDragEnter = (e)=>{
        e.preventDefault();
        e.stopPropagation();
        state.dragOverElements.add(e.target);
        if (state.dragOverElements.size > 1) return;
        let allowedOperationsBits = $5c06e4929e123553$var$getAllowedOperations(e);
        let allowedOperations = $5c06e4929e123553$var$allowedOperationsToArray(allowedOperationsBits);
        let dropOperation = allowedOperations[0];
        if (typeof options.getDropOperation === "function") {
            let types = new (0, $7252cd45fc48c07c$export$7f04ce188c91447c)(e.dataTransfer);
            dropOperation = $5c06e4929e123553$var$getDropOperation(allowedOperationsBits, options.getDropOperation(types, allowedOperations));
        }
        if (typeof options.getDropOperationForPoint === "function") {
            let types = new (0, $7252cd45fc48c07c$export$7f04ce188c91447c)(e.dataTransfer);
            let rect = e.currentTarget.getBoundingClientRect();
            dropOperation = $5c06e4929e123553$var$getDropOperation(allowedOperationsBits, options.getDropOperationForPoint(types, allowedOperations, e.clientX - rect.x, e.clientY - rect.y));
        }
        state.x = e.clientX;
        state.y = e.clientY;
        state.allowedOperations = allowedOperationsBits;
        state.dropEffect = (0, $103790afe9474d1c$export$5eacb0769d26d3b2)[dropOperation] || "none";
        e.dataTransfer.dropEffect = state.dropEffect;
        if (dropOperation !== "cancel") fireDropEnter(e);
    };
    let onDragLeave = (e)=>{
        e.preventDefault();
        e.stopPropagation();
        // We would use e.relatedTarget to detect if the drag is still inside the drop target,
        // but it is always null in WebKit. https://bugs.webkit.org/show_bug.cgi?id=66547
        // Instead, we track all of the targets of dragenter events in a set, and remove them
        // in dragleave. When the set becomes empty, we've left the drop target completely.
        // We must also remove any elements that are no longer in the DOM, because dragleave
        // events will never be fired for these. This can happen, for example, with drop
        // indicators between items, which disappear when the drop target changes.
        state.dragOverElements.delete(e.target);
        for (let element of state.dragOverElements)if (!e.currentTarget.contains(element)) state.dragOverElements.delete(element);
        if (state.dragOverElements.size > 0) return;
        if (state.dropEffect !== "none") fireDropExit(e);
        clearTimeout(state.dropActivateTimer);
    };
    let onDrop = (e)=>{
        e.preventDefault();
        e.stopPropagation();
        // Track drop effect in global state for Chrome Android. https://bugs.chromium.org/p/chromium/issues/detail?id=1353951
        // Android onDragEnd always returns "none" as its drop effect.
        (0, $7252cd45fc48c07c$export$64f52ed7349ddb84)(state.dropEffect);
        if (typeof options.onDrop === "function") {
            let dropOperation = (0, $103790afe9474d1c$export$608ecc6f1b23c35d)[state.dropEffect];
            let items = (0, $7252cd45fc48c07c$export$d9e760437831f8b3)(e.dataTransfer);
            let rect = e.currentTarget.getBoundingClientRect();
            let event = {
                type: "drop",
                x: e.clientX - rect.x,
                y: e.clientY - rect.y,
                items: items,
                dropOperation: dropOperation
            };
            options.onDrop(event);
        }
        let dndStateSnapshot = {
            ...(0, $7252cd45fc48c07c$export$6ca6700462636d0b)
        };
        state.dragOverElements.clear();
        fireDropExit(e);
        clearTimeout(state.dropActivateTimer);
        // If there wasn't a collection being tracked as a dragged collection, then we are in a case where a non RSP drag is dropped on a
        // RSP collection and thus we don't need to preserve the global drop effect
        if (dndStateSnapshot.draggingCollectionRef == null) (0, $7252cd45fc48c07c$export$64f52ed7349ddb84)(undefined);
        else // Otherwise we need to preserve the global dnd state for onDragEnd's isInternal check.
        // At the moment fireDropExit may clear dropCollectionRef (i.e. useDroppableCollection's provided onDropExit, required to clear dropCollectionRef when exiting a valid drop target)
        (0, $7252cd45fc48c07c$export$6c10d32b362bfa5f)(dndStateSnapshot);
    };
    let onDropEnter = (0, $fP8tg$useEffectEvent)((e)=>{
        if (typeof options.onDropEnter === "function") options.onDropEnter(e);
    });
    let onDropExit = (0, $fP8tg$useEffectEvent)((e)=>{
        if (typeof options.onDropExit === "function") options.onDropExit(e);
    });
    let onDropActivate = (0, $fP8tg$useEffectEvent)((e)=>{
        if (typeof options.onDropActivate === "function") options.onDropActivate(e);
    });
    let onKeyboardDrop = (0, $fP8tg$useEffectEvent)((e)=>{
        if (typeof options.onDrop === "function") options.onDrop(e);
    });
    let getDropOperationKeyboard = (0, $fP8tg$useEffectEvent)((types, allowedOperations)=>{
        if (options.getDropOperation) return options.getDropOperation(types, allowedOperations);
        return allowedOperations[0];
    });
    let { ref: ref } = options;
    (0, $fP8tg$useLayoutEffect)(()=>$67560de7c78cb232$export$c28d9fb4a54e471a({
            element: ref.current,
            getDropOperation: getDropOperationKeyboard,
            onDropEnter (e) {
                setDropTarget(true);
                onDropEnter(e);
            },
            onDropExit (e) {
                setDropTarget(false);
                onDropExit(e);
            },
            onDrop: onKeyboardDrop,
            onDropActivate: onDropActivate
        }), [
        ref,
        getDropOperationKeyboard,
        onDropEnter,
        onDropExit,
        onKeyboardDrop,
        onDropActivate
    ]);
    let { dropProps: dropProps } = (0, $224594fe3e57ff1e$export$62447ad3d2ec7da6)();
    return {
        dropProps: {
            ...!hasDropButton && dropProps,
            onDragEnter: onDragEnter,
            onDragOver: onDragOver,
            onDragLeave: onDragLeave,
            onDrop: onDrop
        },
        dropButtonProps: {
            ...hasDropButton && dropProps
        },
        isDropTarget: isDropTarget
    };
}
function $5c06e4929e123553$var$getAllowedOperations(e) {
    let allowedOperations = (0, $103790afe9474d1c$export$9bbdfc78cf083e16)[e.dataTransfer.effectAllowed];
    // WebKit always sets effectAllowed to "copyMove" on macOS, and "all" on iOS, regardless of what was
    // set during the dragstart event: https://bugs.webkit.org/show_bug.cgi?id=178058
    //
    // Android Chrome also sets effectAllowed to "copyMove" in all cases: https://bugs.chromium.org/p/chromium/issues/detail?id=1359182
    //
    // If the drag started within the page, we can use a global variable to get the real allowed operations.
    // This needs to be intersected with the actual effectAllowed, which may have been filtered based on modifier keys.
    // Unfortunately, this means that link operations do not work at all in Safari.
    if (0, $7252cd45fc48c07c$export$f0130eb70b6347b8) allowedOperations &= (0, $7252cd45fc48c07c$export$f0130eb70b6347b8);
    // Chrome and Safari on macOS will automatically filter effectAllowed when pressing modifier keys,
    // allowing the user to switch between move, link, and copy operations. Firefox on macOS and all
    // Windows browsers do not do this, so do it ourselves instead. The exact keys are platform dependent.
    // https://ux.stackexchange.com/questions/83748/what-are-the-most-common-modifier-keys-for-dragging-objects-with-a-mouse
    //
    // Note that none of these modifiers are ever set in WebKit due to a bug: https://bugs.webkit.org/show_bug.cgi?id=77465
    // However, Safari does update effectAllowed correctly, so we can just rely on that.
    let allowedModifiers = (0, $103790afe9474d1c$export$60b7b4bcf3903d8e).none;
    if ((0, $fP8tg$isMac)()) {
        if (e.altKey) allowedModifiers |= (0, $103790afe9474d1c$export$60b7b4bcf3903d8e).copy;
        // Chrome and Safari both use the Control key for link, even though Finder uses Command + Option.
        // iPadOS doesn't support link operations and will not fire the drop event at all if dropEffect is set to link.
        // https://bugs.webkit.org/show_bug.cgi?id=244701
        if (e.ctrlKey && !(0, $fP8tg$isIPad)()) allowedModifiers |= (0, $103790afe9474d1c$export$60b7b4bcf3903d8e).link;
        if (e.metaKey) allowedModifiers |= (0, $103790afe9474d1c$export$60b7b4bcf3903d8e).move;
    } else {
        if (e.altKey) allowedModifiers |= (0, $103790afe9474d1c$export$60b7b4bcf3903d8e).link;
        if (e.shiftKey) allowedModifiers |= (0, $103790afe9474d1c$export$60b7b4bcf3903d8e).move;
        if (e.ctrlKey) allowedModifiers |= (0, $103790afe9474d1c$export$60b7b4bcf3903d8e).copy;
    }
    if (allowedModifiers) return allowedOperations & allowedModifiers;
    return allowedOperations;
}
function $5c06e4929e123553$var$allowedOperationsToArray(allowedOperationsBits) {
    let allowedOperations = [];
    if (allowedOperationsBits & (0, $103790afe9474d1c$export$60b7b4bcf3903d8e).move) allowedOperations.push("move");
    if (allowedOperationsBits & (0, $103790afe9474d1c$export$60b7b4bcf3903d8e).copy) allowedOperations.push("copy");
    if (allowedOperationsBits & (0, $103790afe9474d1c$export$60b7b4bcf3903d8e).link) allowedOperations.push("link");
    return allowedOperations;
}
function $5c06e4929e123553$var$getDropOperation(allowedOperations, operation) {
    let op = (0, $103790afe9474d1c$export$60b7b4bcf3903d8e)[operation];
    return allowedOperations & op ? operation : "cancel";
}


/*
 * Copyright 2020 Adobe. All rights reserved.
 * This file is licensed to you under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License. You may obtain a copy
 * of the License at http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software distributed under
 * the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
 * OF ANY KIND, either express or implied. See the License for the specific language
 * governing permissions and limitations under the License.
 */ 




/*
 * Copyright 2020 Adobe. All rights reserved.
 * This file is licensed to you under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License. You may obtain a copy
 * of the License at http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software distributed under
 * the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
 * OF ANY KIND, either express or implied. See the License for the specific language
 * governing permissions and limitations under the License.
 */ 

const $80d9daea3067eff3$var$AUTOSCROLL_AREA_SIZE = 20;
function $80d9daea3067eff3$export$6323452ca4533ed8(ref) {
    let scrollableRef = (0, $fP8tg$useRef)(null);
    let scrollableX = (0, $fP8tg$useRef)(true);
    let scrollableY = (0, $fP8tg$useRef)(true);
    (0, $fP8tg$useEffect)(()=>{
        if (ref.current) {
            scrollableRef.current = (0, $fP8tg$isScrollable)(ref.current) ? ref.current : (0, $fP8tg$getScrollParent)(ref.current);
            let style = window.getComputedStyle(scrollableRef.current);
            scrollableX.current = /(auto|scroll)/.test(style.overflowX);
            scrollableY.current = /(auto|scroll)/.test(style.overflowY);
        }
    }, [
        ref
    ]);
    let state = (0, $fP8tg$useRef)({
        timer: null,
        dx: 0,
        dy: 0
    }).current;
    (0, $fP8tg$useEffect)(()=>{
        return ()=>{
            if (state.timer) {
                cancelAnimationFrame(state.timer);
                state.timer = null;
            }
        };
    // state will become a new object, so it's ok to use in the dependency array for unmount
    }, [
        state
    ]);
    let scroll = (0, $fP8tg$useCallback)(()=>{
        if (scrollableX.current) scrollableRef.current.scrollLeft += state.dx;
        if (scrollableY.current) scrollableRef.current.scrollTop += state.dy;
        if (state.timer) state.timer = requestAnimationFrame(scroll);
    }, [
        scrollableRef,
        state
    ]);
    return {
        move (x, y) {
            // Most browsers auto scroll natively, but WebKit on macOS does not (iOS does ).
            // https://bugs.webkit.org/show_bug.cgi?id=222636
            if (!(0, $fP8tg$isWebKit)() || (0, $fP8tg$isIOS)() || !scrollableRef.current) return;
            let box = scrollableRef.current.getBoundingClientRect();
            let left = $80d9daea3067eff3$var$AUTOSCROLL_AREA_SIZE;
            let top = $80d9daea3067eff3$var$AUTOSCROLL_AREA_SIZE;
            let bottom = box.height - $80d9daea3067eff3$var$AUTOSCROLL_AREA_SIZE;
            let right = box.width - $80d9daea3067eff3$var$AUTOSCROLL_AREA_SIZE;
            if (x < left || x > right || y < top || y > bottom) {
                if (x < left) state.dx = x - left;
                else if (x > right) state.dx = x - right;
                if (y < top) state.dy = y - top;
                else if (y > bottom) state.dy = y - bottom;
                if (!state.timer) state.timer = requestAnimationFrame(scroll);
            } else this.stop();
        },
        stop () {
            if (state.timer) {
                cancelAnimationFrame(state.timer);
                state.timer = null;
            }
        }
    };
}




const $4b52e4eff84e5217$var$DROP_POSITIONS = [
    "before",
    "on",
    "after"
];
const $4b52e4eff84e5217$var$DROP_POSITIONS_RTL = [
    "after",
    "on",
    "before"
];
function $4b52e4eff84e5217$export$f4e2f423c21f7b04(props, state, ref) {
    let localState = (0, $fP8tg$useRef)({
        props: props,
        state: state,
        nextTarget: null,
        dropOperation: null
    }).current;
    localState.props = props;
    localState.state = state;
    let defaultOnDrop = (0, $fP8tg$useCallback)(async (e)=>{
        let { onInsert: onInsert, onRootDrop: onRootDrop, onItemDrop: onItemDrop, onReorder: onReorder, acceptedDragTypes: acceptedDragTypes = "all", shouldAcceptItemDrop: shouldAcceptItemDrop } = localState.props;
        let { draggingKeys: draggingKeys } = (0, $7252cd45fc48c07c$export$6ca6700462636d0b);
        let isInternal = (0, $7252cd45fc48c07c$export$78bf638634500fa5)(ref);
        let { target: target, dropOperation: dropOperation, items: items } = e;
        let filteredItems = items;
        if (acceptedDragTypes !== "all" || shouldAcceptItemDrop) filteredItems = items.filter((item)=>{
            let itemTypes;
            if (item.kind === "directory") itemTypes = new Set([
                (0, $7252cd45fc48c07c$export$990fced5dfac2637)
            ]);
            else itemTypes = item.kind === "file" ? new Set([
                item.type
            ]) : item.types;
            if (acceptedDragTypes === "all" || acceptedDragTypes.some((type)=>itemTypes.has(type))) {
                // If we are performing a on item drop, check if the item in question accepts the dropped item since the item may have heavier restrictions
                // than the droppable collection itself
                if (target.type === "item" && target.dropPosition === "on" && shouldAcceptItemDrop) return shouldAcceptItemDrop(target, itemTypes);
                return true;
            }
            return false;
        });
        if (filteredItems.length > 0) {
            if (target.type === "root" && onRootDrop) await onRootDrop({
                items: filteredItems,
                dropOperation: dropOperation
            });
            if (target.type === "item") {
                if (target.dropPosition === "on" && onItemDrop) await onItemDrop({
                    items: filteredItems,
                    dropOperation: dropOperation,
                    isInternal: isInternal,
                    target: target
                });
                if (target.dropPosition !== "on") {
                    if (!isInternal && onInsert) await onInsert({
                        items: filteredItems,
                        dropOperation: dropOperation,
                        target: target
                    });
                    if (isInternal && onReorder) await onReorder({
                        keys: draggingKeys,
                        dropOperation: dropOperation,
                        target: target
                    });
                }
            }
        }
    }, [
        localState,
        ref
    ]);
    let autoScroll = (0, $80d9daea3067eff3$export$6323452ca4533ed8)(ref);
    let { dropProps: dropProps } = (0, $5c06e4929e123553$export$ccdee5eaf73cf661)({
        ref: ref,
        onDropEnter () {
            state.setTarget(localState.nextTarget);
        },
        onDropMove (e) {
            state.setTarget(localState.nextTarget);
            autoScroll.move(e.x, e.y);
        },
        getDropOperationForPoint (types, allowedOperations, x, y) {
            let { draggingKeys: draggingKeys, dropCollectionRef: dropCollectionRef } = (0, $7252cd45fc48c07c$export$6ca6700462636d0b);
            let isInternal = (0, $7252cd45fc48c07c$export$78bf638634500fa5)(ref);
            let isValidDropTarget = (target)=>state.getDropOperation({
                    target: target,
                    types: types,
                    allowedOperations: allowedOperations,
                    isInternal: isInternal,
                    draggingKeys: draggingKeys
                }) !== "cancel";
            let target = props.dropTargetDelegate.getDropTargetFromPoint(x, y, isValidDropTarget);
            if (!target) {
                localState.dropOperation = "cancel";
                localState.nextTarget = null;
                return "cancel";
            }
            localState.dropOperation = state.getDropOperation({
                target: target,
                types: types,
                allowedOperations: allowedOperations,
                isInternal: isInternal,
                draggingKeys: draggingKeys
            });
            // If the target doesn't accept the drop, see if the root accepts it instead.
            if (localState.dropOperation === "cancel") {
                let rootTarget = {
                    type: "root"
                };
                let dropOperation = state.getDropOperation({
                    target: rootTarget,
                    types: types,
                    allowedOperations: allowedOperations,
                    isInternal: isInternal,
                    draggingKeys: draggingKeys
                });
                if (dropOperation !== "cancel") {
                    target = rootTarget;
                    localState.dropOperation = dropOperation;
                }
            }
            // Only set dropCollectionRef if there is a valid drop target since we cleanup dropCollectionRef in onDropExit
            // which only runs when leaving a valid drop target or if the dropEffect become none (mouse dnd only).
            if (target && localState.dropOperation !== "cancel" && (ref === null || ref === void 0 ? void 0 : ref.current) !== (dropCollectionRef === null || dropCollectionRef === void 0 ? void 0 : dropCollectionRef.current)) (0, $7252cd45fc48c07c$export$dac8db29d42db9a1)(ref);
            localState.nextTarget = localState.dropOperation === "cancel" ? null : target;
            return localState.dropOperation;
        },
        onDropExit () {
            (0, $7252cd45fc48c07c$export$dac8db29d42db9a1)(undefined);
            state.setTarget(null);
            autoScroll.stop();
        },
        onDropActivate (e) {
            var _state_target, _state_target1;
            if (((_state_target = state.target) === null || _state_target === void 0 ? void 0 : _state_target.type) === "item" && ((_state_target1 = state.target) === null || _state_target1 === void 0 ? void 0 : _state_target1.dropPosition) === "on" && typeof props.onDropActivate === "function") props.onDropActivate({
                type: "dropactivate",
                x: e.x,
                y: e.y,
                target: state.target
            });
        },
        onDrop (e) {
            (0, $7252cd45fc48c07c$export$dac8db29d42db9a1)(ref);
            if (state.target) onDrop(e, state.target);
            // If there wasn't a collection being tracked as a dragged collection, then we are in a case where a non RSP drag is dropped on a
            // RSP collection and thus we don't need to preserve the global DnD state for onDragEnd
            let { draggingCollectionRef: draggingCollectionRef } = (0, $7252cd45fc48c07c$export$6ca6700462636d0b);
            if (draggingCollectionRef == null) (0, $7252cd45fc48c07c$export$70936501603e6c57)();
        }
    });
    let droppingState = (0, $fP8tg$useRef)(null);
    let onDrop = (0, $fP8tg$useCallback)((e, target)=>{
        var _state_collection_getItem;
        let { state: state } = localState;
        // Focus the collection.
        state.selectionManager.setFocused(true);
        // Save some state of the collection/selection before the drop occurs so we can compare later.
        let focusedKey = state.selectionManager.focusedKey;
        // If parent key was dragged, we want to use it instead (i.e. focus row instead of cell after dropping)
        if ((0, $7252cd45fc48c07c$export$6ca6700462636d0b).draggingKeys.has((_state_collection_getItem = state.collection.getItem(focusedKey)) === null || _state_collection_getItem === void 0 ? void 0 : _state_collection_getItem.parentKey)) {
            focusedKey = state.collection.getItem(focusedKey).parentKey;
            state.selectionManager.setFocusedKey(focusedKey);
        }
        droppingState.current = {
            timeout: null,
            focusedKey: focusedKey,
            collection: state.collection,
            selectedKeys: state.selectionManager.selectedKeys
        };
        let onDropFn = localState.props.onDrop || defaultOnDrop;
        onDropFn({
            type: "drop",
            x: e.x,
            y: e.y,
            target: target,
            items: e.items,
            dropOperation: e.dropOperation
        });
        // Wait for a short time period after the onDrop is called to allow the data to be read asynchronously
        // and for React to re-render. If an insert occurs during this time, it will be selected/focused below.
        // If items are not "immediately" inserted by the onDrop handler, the application will need to handle
        // selecting and focusing those items themselves.
        droppingState.current.timeout = setTimeout(()=>{
            // If focus didn't move already (e.g. due to an insert), and the user dropped on an item,
            // focus that item and show the focus ring to give the user feedback that the drop occurred.
            // Also show the focus ring if the focused key is not selected, e.g. in case of a reorder.
            let { state: state } = localState;
            if (target.type === "item" && target.dropPosition === "on" && state.collection.getItem(target.key) != null) {
                state.selectionManager.setFocusedKey(target.key);
                state.selectionManager.setFocused(true);
                (0, $fP8tg$setInteractionModality)("keyboard");
            } else if (!state.selectionManager.isSelected(focusedKey)) (0, $fP8tg$setInteractionModality)("keyboard");
            droppingState.current = null;
        }, 50);
    }, [
        localState,
        defaultOnDrop
    ]);
    // eslint-disable-next-line arrow-body-style
    (0, $fP8tg$useEffect)(()=>{
        return ()=>{
            if (droppingState.current) clearTimeout(droppingState.current.timeout);
        };
    }, []);
    (0, $fP8tg$useLayoutEffect)(()=>{
        // If an insert occurs during a drop, we want to immediately select these items to give
        // feedback to the user that a drop occurred. Only do this if the selection didn't change
        // since the drop started so we don't override if the user or application did something.
        if (droppingState.current && state.selectionManager.isFocused && state.collection.size > droppingState.current.collection.size && state.selectionManager.isSelectionEqual(droppingState.current.selectedKeys)) {
            let newKeys = new Set();
            for (let key of state.collection.getKeys())if (!droppingState.current.collection.getItem(key)) newKeys.add(key);
            state.selectionManager.setSelectedKeys(newKeys);
            // If the focused item didn't change since the drop occurred, also focus the first
            // inserted item. If selection is disabled, then also show the focus ring so there
            // is some indication that items were added.
            if (state.selectionManager.focusedKey === droppingState.current.focusedKey) {
                let first = newKeys.keys().next().value;
                let item = state.collection.getItem(first);
                // If this is a cell, focus the parent row.
                if ((item === null || item === void 0 ? void 0 : item.type) === "cell") first = item.parentKey;
                state.selectionManager.setFocusedKey(first);
                if (state.selectionManager.selectionMode === "none") (0, $fP8tg$setInteractionModality)("keyboard");
            }
            droppingState.current = null;
        }
    });
    let { direction: direction } = (0, $fP8tg$useLocale)();
    (0, $fP8tg$useEffect)(()=>{
        let getNextTarget = (target, wrap = true, horizontal = false)=>{
            if (!target) return {
                type: "root"
            };
            let { keyboardDelegate: keyboardDelegate } = localState.props;
            let nextKey;
            if ((target === null || target === void 0 ? void 0 : target.type) === "item") nextKey = horizontal ? keyboardDelegate.getKeyRightOf(target.key) : keyboardDelegate.getKeyBelow(target.key);
            else nextKey = horizontal && direction === "rtl" ? keyboardDelegate.getLastKey() : keyboardDelegate.getFirstKey();
            let dropPositions = horizontal && direction === "rtl" ? $4b52e4eff84e5217$var$DROP_POSITIONS_RTL : $4b52e4eff84e5217$var$DROP_POSITIONS;
            let dropPosition = dropPositions[0];
            if (target.type === "item") {
                // If the the keyboard delegate returned the next key in the collection,
                // first try the other positions in the current key. Otherwise (e.g. in a grid layout),
                // jump to the same drop position in the new key.
                let nextCollectionKey = horizontal && direction === "rtl" ? localState.state.collection.getKeyBefore(target.key) : localState.state.collection.getKeyAfter(target.key);
                if (nextKey == null || nextKey === nextCollectionKey) {
                    let positionIndex = dropPositions.indexOf(target.dropPosition);
                    let nextDropPosition = dropPositions[positionIndex + 1];
                    if (positionIndex < dropPositions.length - 1 && !(nextDropPosition === dropPositions[2] && nextKey != null)) return {
                        type: "item",
                        key: target.key,
                        dropPosition: nextDropPosition
                    };
                    // If the last drop position was 'after', then 'before' on the next key is equivalent.
                    // Switch to 'on' instead.
                    if (target.dropPosition === dropPositions[2]) dropPosition = "on";
                } else dropPosition = target.dropPosition;
            }
            if (nextKey == null) {
                if (wrap) return {
                    type: "root"
                };
                return null;
            }
            return {
                type: "item",
                key: nextKey,
                dropPosition: dropPosition
            };
        };
        let getPreviousTarget = (target, wrap = true, horizontal = false)=>{
            let { keyboardDelegate: keyboardDelegate } = localState.props;
            let nextKey;
            if ((target === null || target === void 0 ? void 0 : target.type) === "item") nextKey = horizontal ? keyboardDelegate.getKeyLeftOf(target.key) : keyboardDelegate.getKeyAbove(target.key);
            else nextKey = horizontal && direction === "rtl" ? keyboardDelegate.getFirstKey() : keyboardDelegate.getLastKey();
            let dropPositions = horizontal && direction === "rtl" ? $4b52e4eff84e5217$var$DROP_POSITIONS_RTL : $4b52e4eff84e5217$var$DROP_POSITIONS;
            let dropPosition = !target || target.type === "root" ? dropPositions[2] : "on";
            if ((target === null || target === void 0 ? void 0 : target.type) === "item") {
                // If the the keyboard delegate returned the previous key in the collection,
                // first try the other positions in the current key. Otherwise (e.g. in a grid layout),
                // jump to the same drop position in the new key.
                let prevCollectionKey = horizontal && direction === "rtl" ? localState.state.collection.getKeyAfter(target.key) : localState.state.collection.getKeyBefore(target.key);
                if (nextKey == null || nextKey === prevCollectionKey) {
                    let positionIndex = dropPositions.indexOf(target.dropPosition);
                    let nextDropPosition = dropPositions[positionIndex - 1];
                    if (positionIndex > 0 && nextDropPosition !== dropPositions[2]) return {
                        type: "item",
                        key: target.key,
                        dropPosition: nextDropPosition
                    };
                    // If the last drop position was 'before', then 'after' on the previous key is equivalent.
                    // Switch to 'on' instead.
                    if (target.dropPosition === dropPositions[0]) dropPosition = "on";
                } else dropPosition = target.dropPosition;
            }
            if (nextKey == null) {
                if (wrap) return {
                    type: "root"
                };
                return null;
            }
            return {
                type: "item",
                key: nextKey,
                dropPosition: dropPosition
            };
        };
        let nextValidTarget = (target, types, allowedDropOperations, getNextTarget, wrap = true)=>{
            let seenRoot = 0;
            let operation;
            let { draggingKeys: draggingKeys } = (0, $7252cd45fc48c07c$export$6ca6700462636d0b);
            let isInternal = (0, $7252cd45fc48c07c$export$78bf638634500fa5)(ref);
            do {
                let nextTarget = getNextTarget(target, wrap);
                if (!nextTarget) return null;
                target = nextTarget;
                operation = localState.state.getDropOperation({
                    target: nextTarget,
                    types: types,
                    allowedOperations: allowedDropOperations,
                    isInternal: isInternal,
                    draggingKeys: draggingKeys
                });
                if (target.type === "root") seenRoot++;
            }while (operation === "cancel" && !localState.state.isDropTarget(target) && seenRoot < 2);
            if (operation === "cancel") return null;
            return target;
        };
        return $67560de7c78cb232$export$c28d9fb4a54e471a({
            element: ref.current,
            getDropOperation (types, allowedOperations) {
                if (localState.state.target) {
                    let { draggingKeys: draggingKeys } = (0, $7252cd45fc48c07c$export$6ca6700462636d0b);
                    let isInternal = (0, $7252cd45fc48c07c$export$78bf638634500fa5)(ref);
                    return localState.state.getDropOperation({
                        target: localState.state.target,
                        types: types,
                        allowedOperations: allowedOperations,
                        isInternal: isInternal,
                        draggingKeys: draggingKeys
                    });
                }
                // Check if any of the targets accept the drop.
                // TODO: should we have a faster way of doing this or e.g. for pagination?
                let target = nextValidTarget(null, types, allowedOperations, getNextTarget);
                return target ? "move" : "cancel";
            },
            onDropEnter (e, drag) {
                let types = (0, $7252cd45fc48c07c$export$e1d41611756c6326)(drag.items);
                let selectionManager = localState.state.selectionManager;
                let target;
                // Update the drop collection ref tracker for useDroppableItem's getDropOperation isInternal check
                (0, $7252cd45fc48c07c$export$dac8db29d42db9a1)(ref);
                // When entering the droppable collection for the first time, the default drop target
                // is after the focused key.
                let key = selectionManager.focusedKey;
                let dropPosition = "after";
                // If the focused key is a cell, get the parent item instead.
                // For now, we assume that individual cells cannot be dropped on.
                let item = localState.state.collection.getItem(key);
                if ((item === null || item === void 0 ? void 0 : item.type) === "cell") key = item.parentKey;
                // If the focused item is also selected, the default drop target is after the last selected item.
                // But if the focused key is the first selected item, then default to before the first selected item.
                // This is to make reordering lists slightly easier. If you select top down, we assume you want to
                // move the items down. If you select bottom up, we assume you want to move the items up.
                if (selectionManager.isSelected(key)) {
                    if (selectionManager.selectedKeys.size > 1 && selectionManager.firstSelectedKey === key) dropPosition = "before";
                    else key = selectionManager.lastSelectedKey;
                }
                if (key != null) {
                    target = {
                        type: "item",
                        key: key,
                        dropPosition: dropPosition
                    };
                    let { draggingKeys: draggingKeys } = (0, $7252cd45fc48c07c$export$6ca6700462636d0b);
                    let isInternal = (0, $7252cd45fc48c07c$export$78bf638634500fa5)(ref);
                    var _nextValidTarget;
                    // If the default target is not valid, find the next one that is.
                    if (localState.state.getDropOperation({
                        target: target,
                        types: types,
                        allowedOperations: drag.allowedDropOperations,
                        isInternal: isInternal,
                        draggingKeys: draggingKeys
                    }) === "cancel") target = (_nextValidTarget = nextValidTarget(target, types, drag.allowedDropOperations, getNextTarget, false)) !== null && _nextValidTarget !== void 0 ? _nextValidTarget : nextValidTarget(target, types, drag.allowedDropOperations, getPreviousTarget, false);
                }
                // If no focused key, then start from the root.
                if (!target) target = nextValidTarget(null, types, drag.allowedDropOperations, getNextTarget);
                localState.state.setTarget(target);
            },
            onDropExit () {
                (0, $7252cd45fc48c07c$export$dac8db29d42db9a1)(undefined);
                localState.state.setTarget(null);
            },
            onDropTargetEnter (target) {
                localState.state.setTarget(target);
            },
            onDropActivate (e) {
                var _localState_state_target, _localState_state_target1;
                if (((_localState_state_target = localState.state.target) === null || _localState_state_target === void 0 ? void 0 : _localState_state_target.type) === "item" && ((_localState_state_target1 = localState.state.target) === null || _localState_state_target1 === void 0 ? void 0 : _localState_state_target1.dropPosition) === "on" && typeof localState.props.onDropActivate === "function") localState.props.onDropActivate({
                    type: "dropactivate",
                    x: e.x,
                    y: e.y,
                    target: localState.state.target
                });
            },
            onDrop (e, target) {
                (0, $7252cd45fc48c07c$export$dac8db29d42db9a1)(ref);
                if (localState.state.target) onDrop(e, target || localState.state.target);
            },
            onKeyDown (e, drag) {
                let { keyboardDelegate: keyboardDelegate } = localState.props;
                let types = (0, $7252cd45fc48c07c$export$e1d41611756c6326)(drag.items);
                switch(e.key){
                    case "ArrowDown":
                        if (keyboardDelegate.getKeyBelow) {
                            let target = nextValidTarget(localState.state.target, types, drag.allowedDropOperations, getNextTarget);
                            localState.state.setTarget(target);
                        }
                        break;
                    case "ArrowUp":
                        if (keyboardDelegate.getKeyAbove) {
                            let target = nextValidTarget(localState.state.target, types, drag.allowedDropOperations, getPreviousTarget);
                            localState.state.setTarget(target);
                        }
                        break;
                    case "ArrowLeft":
                        if (keyboardDelegate.getKeyLeftOf) {
                            let target = nextValidTarget(localState.state.target, types, drag.allowedDropOperations, (target, wrap)=>getPreviousTarget(target, wrap, true));
                            localState.state.setTarget(target);
                        }
                        break;
                    case "ArrowRight":
                        if (keyboardDelegate.getKeyRightOf) {
                            let target = nextValidTarget(localState.state.target, types, drag.allowedDropOperations, (target, wrap)=>getNextTarget(target, wrap, true));
                            localState.state.setTarget(target);
                        }
                        break;
                    case "Home":
                        if (keyboardDelegate.getFirstKey) {
                            let target = nextValidTarget(null, types, drag.allowedDropOperations, getNextTarget);
                            localState.state.setTarget(target);
                        }
                        break;
                    case "End":
                        if (keyboardDelegate.getLastKey) {
                            let target = nextValidTarget(null, types, drag.allowedDropOperations, getPreviousTarget);
                            localState.state.setTarget(target);
                        }
                        break;
                    case "PageDown":
                        if (keyboardDelegate.getKeyPageBelow) {
                            let target = localState.state.target;
                            if (!target) target = nextValidTarget(null, types, drag.allowedDropOperations, getNextTarget);
                            else {
                                // If on the root, go to the item a page below the top. Otherwise a page below the current item.
                                let nextKey = keyboardDelegate.getKeyPageBelow(target.type === "item" ? target.key : keyboardDelegate.getFirstKey());
                                let dropPosition = target.type === "item" ? target.dropPosition : "after";
                                // If there is no next key, or we are starting on the last key, jump to the last possible position.
                                if (nextKey == null || target.type === "item" && target.key === keyboardDelegate.getLastKey()) {
                                    nextKey = keyboardDelegate.getLastKey();
                                    dropPosition = "after";
                                }
                                target = {
                                    type: "item",
                                    key: nextKey,
                                    dropPosition: dropPosition
                                };
                                // If the target does not accept the drop, find the next valid target.
                                // If no next valid target, find the previous valid target.
                                let { draggingCollectionRef: draggingCollectionRef, draggingKeys: draggingKeys } = (0, $7252cd45fc48c07c$export$6ca6700462636d0b);
                                let isInternal = (draggingCollectionRef === null || draggingCollectionRef === void 0 ? void 0 : draggingCollectionRef.current) === (ref === null || ref === void 0 ? void 0 : ref.current);
                                let operation = localState.state.getDropOperation({
                                    target: target,
                                    types: types,
                                    allowedOperations: drag.allowedDropOperations,
                                    isInternal: isInternal,
                                    draggingKeys: draggingKeys
                                });
                                var _nextValidTarget;
                                if (operation === "cancel") target = (_nextValidTarget = nextValidTarget(target, types, drag.allowedDropOperations, getNextTarget, false)) !== null && _nextValidTarget !== void 0 ? _nextValidTarget : nextValidTarget(target, types, drag.allowedDropOperations, getPreviousTarget, false);
                            }
                            localState.state.setTarget(target !== null && target !== void 0 ? target : localState.state.target);
                        }
                        break;
                    case "PageUp":
                        {
                            if (!keyboardDelegate.getKeyPageAbove) break;
                            let target = localState.state.target;
                            if (!target) target = nextValidTarget(null, types, drag.allowedDropOperations, getPreviousTarget);
                            else if (target.type === "item") {
                                // If at the top already, switch to the root. Otherwise navigate a page up.
                                if (target.key === keyboardDelegate.getFirstKey()) target = {
                                    type: "root"
                                };
                                else {
                                    let nextKey = keyboardDelegate.getKeyPageAbove(target.key);
                                    let dropPosition = target.dropPosition;
                                    if (nextKey == null) {
                                        nextKey = keyboardDelegate.getFirstKey();
                                        dropPosition = "before";
                                    }
                                    target = {
                                        type: "item",
                                        key: nextKey,
                                        dropPosition: dropPosition
                                    };
                                }
                                // If the target does not accept the drop, find the previous valid target.
                                // If no next valid target, find the next valid target.
                                let { draggingKeys: draggingKeys } = (0, $7252cd45fc48c07c$export$6ca6700462636d0b);
                                let isInternal = (0, $7252cd45fc48c07c$export$78bf638634500fa5)(ref);
                                let operation = localState.state.getDropOperation({
                                    target: target,
                                    types: types,
                                    allowedOperations: drag.allowedDropOperations,
                                    isInternal: isInternal,
                                    draggingKeys: draggingKeys
                                });
                                var _nextValidTarget1;
                                if (operation === "cancel") target = (_nextValidTarget1 = nextValidTarget(target, types, drag.allowedDropOperations, getPreviousTarget, false)) !== null && _nextValidTarget1 !== void 0 ? _nextValidTarget1 : nextValidTarget(target, types, drag.allowedDropOperations, getNextTarget, false);
                            }
                            localState.state.setTarget(target !== null && target !== void 0 ? target : localState.state.target);
                            break;
                        }
                }
            }
        });
    }, [
        localState,
        ref,
        onDrop,
        direction
    ]);
    let id = (0, $fP8tg$useId)();
    (0, $7252cd45fc48c07c$export$dfdf5deeaf27473f).set(state, {
        id: id,
        ref: ref
    });
    return {
        collectionProps: (0, $fP8tg$mergeProps)(dropProps, {
            id: id,
            // Remove description from collection element. If dropping on the entire collection,
            // there should be a drop indicator that has this description, so no need to double announce.
            "aria-describedby": null
        })
    };
}


/*
 * Copyright 2020 Adobe. All rights reserved.
 * This file is licensed to you under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License. You may obtain a copy
 * of the License at http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software distributed under
 * the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
 * OF ANY KIND, either express or implied. See the License for the specific language
 * governing permissions and limitations under the License.
 */ 



function $bfaab576ce1c580e$export$f7b0c5d28b66b6a5(options, state, ref) {
    let { dropProps: dropProps } = (0, $224594fe3e57ff1e$export$62447ad3d2ec7da6)();
    let droppableCollectionRef = (0, $7252cd45fc48c07c$export$7e397efd01d3db27)(state);
    (0, $fP8tg$useEffect)(()=>{
        if (ref.current) return $67560de7c78cb232$export$aef80212ac99c003({
            element: ref.current,
            target: options.target,
            getDropOperation (types, allowedOperations) {
                let { draggingKeys: draggingKeys } = (0, $7252cd45fc48c07c$export$6ca6700462636d0b);
                let isInternal = (0, $7252cd45fc48c07c$export$78bf638634500fa5)(droppableCollectionRef);
                return state.getDropOperation({
                    target: options.target,
                    types: types,
                    allowedOperations: allowedOperations,
                    isInternal: isInternal,
                    draggingKeys: draggingKeys
                });
            }
        });
    }, [
        ref,
        options.target,
        state,
        droppableCollectionRef
    ]);
    let dragSession = $67560de7c78cb232$export$418e185dd3f1b968();
    let { draggingKeys: draggingKeys } = (0, $7252cd45fc48c07c$export$6ca6700462636d0b);
    let isInternal = (0, $7252cd45fc48c07c$export$78bf638634500fa5)(droppableCollectionRef);
    let isValidDropTarget = dragSession && state.getDropOperation({
        target: options.target,
        types: (0, $7252cd45fc48c07c$export$e1d41611756c6326)(dragSession.dragTarget.items),
        allowedOperations: dragSession.dragTarget.allowedDropOperations,
        isInternal: isInternal,
        draggingKeys: draggingKeys
    }) !== "cancel";
    let isDropTarget = state.isDropTarget(options.target);
    (0, $fP8tg$useEffect)(()=>{
        if (dragSession && isDropTarget && ref.current) ref.current.focus();
    }, [
        isDropTarget,
        dragSession,
        ref
    ]);
    return {
        dropProps: {
            ...dropProps,
            "aria-hidden": !dragSession || isValidDropTarget ? undefined : "true"
        },
        isDropTarget: isDropTarget
    };
}


/*
 * Copyright 2020 Adobe. All rights reserved.
 * This file is licensed to you under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License. You may obtain a copy
 * of the License at http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software distributed under
 * the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
 * OF ANY KIND, either express or implied. See the License for the specific language
 * governing permissions and limitations under the License.
 */ 





function $ddf25448c71fc93a$export$8d0e41d2815afac5(props, state, ref) {
    let { target: target } = props;
    let { collection: collection } = state;
    let stringFormatter = (0, $fP8tg$useLocalizedStringFormatter)((0, (/*@__PURE__*/$parcel$interopDefault($865c2eb7c00a83f1$exports))), "@react-aria/dnd");
    let dragSession = $67560de7c78cb232$export$418e185dd3f1b968();
    let { dropProps: dropProps } = (0, $bfaab576ce1c580e$export$f7b0c5d28b66b6a5)(props, state, ref);
    let id = (0, $fP8tg$useId)();
    let getText = (key)=>{
        var _collection_getTextValue, _collection_getItem;
        var _collection_getTextValue1;
        return (_collection_getTextValue1 = (_collection_getTextValue = collection.getTextValue) === null || _collection_getTextValue === void 0 ? void 0 : _collection_getTextValue.call(collection, key)) !== null && _collection_getTextValue1 !== void 0 ? _collection_getTextValue1 : (_collection_getItem = collection.getItem(key)) === null || _collection_getItem === void 0 ? void 0 : _collection_getItem.textValue;
    };
    let label = "";
    let labelledBy;
    if (target.type === "root") {
        label = stringFormatter.format("dropOnRoot");
        labelledBy = `${id} ${(0, $7252cd45fc48c07c$export$3093291712f09a77)(state)}`;
    } else if (target.dropPosition === "on") label = stringFormatter.format("dropOnItem", {
        itemText: getText(target.key)
    });
    else {
        let before;
        let after;
        if (collection.getFirstKey() === target.key && target.dropPosition === "before") before = null;
        else before = target.dropPosition === "before" ? collection.getKeyBefore(target.key) : target.key;
        if (collection.getLastKey() === target.key && target.dropPosition === "after") after = null;
        else after = target.dropPosition === "after" ? collection.getKeyAfter(target.key) : target.key;
        if (before && after) label = stringFormatter.format("insertBetween", {
            beforeItemText: getText(before),
            afterItemText: getText(after)
        });
        else if (before) label = stringFormatter.format("insertAfter", {
            itemText: getText(before)
        });
        else if (after) label = stringFormatter.format("insertBefore", {
            itemText: getText(after)
        });
    }
    let isDropTarget = state.isDropTarget(target);
    let ariaHidden = !dragSession ? "true" : dropProps["aria-hidden"];
    return {
        dropIndicatorProps: {
            ...dropProps,
            id: id,
            "aria-roledescription": stringFormatter.format("dropIndicator"),
            "aria-label": label,
            "aria-labelledby": labelledBy,
            "aria-hidden": ariaHidden,
            tabIndex: -1
        },
        isDropTarget: isDropTarget,
        // If aria-hidden, we are either not in a drag session or the drop target is invalid.
        // In that case, there's no need to render anything at all unless we need to show the indicator visually.
        // This can happen when dragging using the native DnD API as opposed to keyboard dragging.
        isHidden: !isDropTarget && !!ariaHidden
    };
}


/*
 * Copyright 2020 Adobe. All rights reserved.
 * This file is licensed to you under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License. You may obtain a copy
 * of the License at http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software distributed under
 * the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
 * OF ANY KIND, either express or implied. See the License for the specific language
 * governing permissions and limitations under the License.
 */ 




const $fd98cf7cbf233429$var$MESSAGES = {
    keyboard: {
        selected: "dragSelectedKeyboard",
        notSelected: "dragDescriptionKeyboard"
    },
    touch: {
        selected: "dragSelectedLongPress",
        notSelected: "dragDescriptionLongPress"
    },
    virtual: {
        selected: "dragDescriptionVirtual",
        notSelected: "dragDescriptionVirtual"
    }
};
function $fd98cf7cbf233429$export$b35afafff42da2d9(props, state) {
    let stringFormatter = (0, $fP8tg$useLocalizedStringFormatter)((0, (/*@__PURE__*/$parcel$interopDefault($865c2eb7c00a83f1$exports))), "@react-aria/dnd");
    let isDisabled = state.selectionManager.isDisabled(props.key);
    let { dragProps: dragProps, dragButtonProps: dragButtonProps } = (0, $8253ed7ece74b463$export$7941f8aafa4b6021)({
        getItems () {
            return state.getItems(props.key);
        },
        preview: state.preview,
        getAllowedDropOperations: state.getAllowedDropOperations,
        hasDragButton: props.hasDragButton,
        onDragStart (e) {
            state.startDrag(props.key, e);
            // Track draggingKeys for useDroppableCollection's default onDrop handler and useDroppableCollectionState's default getDropOperation
            (0, $7252cd45fc48c07c$export$72cb63bdda528276)(state.draggingKeys);
        },
        onDragMove (e) {
            state.moveDrag(e);
        },
        onDragEnd (e) {
            let { dropOperation: dropOperation } = e;
            let isInternal = dropOperation === "cancel" ? false : (0, $7252cd45fc48c07c$export$78bf638634500fa5)();
            state.endDrag({
                ...e,
                keys: state.draggingKeys,
                isInternal: isInternal
            });
            (0, $7252cd45fc48c07c$export$70936501603e6c57)();
        }
    });
    let item = state.collection.getItem(props.key);
    let numKeysForDrag = state.getKeysForDrag(props.key).size;
    let isSelected = numKeysForDrag > 1 && state.selectionManager.isSelected(props.key);
    let dragButtonLabel;
    let description;
    // Override description to include selected item count.
    let modality = (0, $7252cd45fc48c07c$export$49bac5d6d4b352ea)();
    if (!props.hasDragButton && state.selectionManager.selectionMode !== "none") {
        let msg = $fd98cf7cbf233429$var$MESSAGES[modality][isSelected ? "selected" : "notSelected"];
        if (props.hasAction && modality === "keyboard") msg += "Alt";
        if (isSelected) description = stringFormatter.format(msg, {
            count: numKeysForDrag
        });
        else description = stringFormatter.format(msg);
        // Remove the onClick handler from useDrag. Long pressing will be required on touch devices,
        // and NVDA/JAWS are always in forms mode within collection components.
        delete dragProps.onClick;
    } else if (isSelected) dragButtonLabel = stringFormatter.format("dragSelectedItems", {
        count: numKeysForDrag
    });
    else {
        var _state_collection_getTextValue, _state_collection;
        var _state_collection_getTextValue1, _ref;
        let itemText = (_ref = (_state_collection_getTextValue1 = (_state_collection_getTextValue = (_state_collection = state.collection).getTextValue) === null || _state_collection_getTextValue === void 0 ? void 0 : _state_collection_getTextValue.call(_state_collection, props.key)) !== null && _state_collection_getTextValue1 !== void 0 ? _state_collection_getTextValue1 : item === null || item === void 0 ? void 0 : item.textValue) !== null && _ref !== void 0 ? _ref : "";
        dragButtonLabel = stringFormatter.format("dragItem", {
            itemText: itemText
        });
    }
    let descriptionProps = (0, $fP8tg$useDescription)(description);
    if (description) Object.assign(dragProps, descriptionProps);
    if (!props.hasDragButton && props.hasAction) {
        let { onKeyDownCapture: onKeyDownCapture, onKeyUpCapture: onKeyUpCapture } = dragProps;
        if (modality === "touch") // Remove long press description if an action is present, because in that case long pressing selects the item.
        delete dragProps["aria-describedby"];
        // Require Alt key if there is a conflicting action.
        dragProps.onKeyDownCapture = (e)=>{
            if (e.altKey) onKeyDownCapture(e);
        };
        dragProps.onKeyUpCapture = (e)=>{
            if (e.altKey) onKeyUpCapture(e);
        };
    }
    return {
        dragProps: isDisabled ? {} : dragProps,
        dragButtonProps: {
            ...dragButtonProps,
            isDisabled: isDisabled,
            "aria-label": dragButtonLabel
        }
    };
}


/*
 * Copyright 2022 Adobe. All rights reserved.
 * This file is licensed to you under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License. You may obtain a copy
 * of the License at http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software distributed under
 * the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
 * OF ANY KIND, either express or implied. See the License for the specific language
 * governing permissions and limitations under the License.
 */ 
function $4ac1fdc3a0fcd564$export$2962a7984b2f0a80(props, state, ref) {
    // Update global DnD state if this keys within this collection are dragged
    let { draggingCollectionRef: draggingCollectionRef } = (0, $7252cd45fc48c07c$export$6ca6700462636d0b);
    if (state.draggingKeys.size > 0 && (draggingCollectionRef === null || draggingCollectionRef === void 0 ? void 0 : draggingCollectionRef.current) !== ref.current) (0, $7252cd45fc48c07c$export$f2be18a910c0caa6)(ref);
}


/*
 * Copyright 2020 Adobe. All rights reserved.
 * This file is licensed to you under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License. You may obtain a copy
 * of the License at http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software distributed under
 * the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
 * OF ANY KIND, either express or implied. See the License for the specific language
 * governing permissions and limitations under the License.
 */ 



const $9fcc7f0d70d084ee$var$globalEvents = new Map();
function $9fcc7f0d70d084ee$var$addGlobalEventListener(event, fn) {
    let eventData = $9fcc7f0d70d084ee$var$globalEvents.get(event);
    if (!eventData) {
        let handlers = new Set();
        let listener = (e)=>{
            for (let handler of handlers)handler(e);
        };
        eventData = {
            listener: listener,
            handlers: handlers
        };
        $9fcc7f0d70d084ee$var$globalEvents.set(event, eventData);
        document.addEventListener(event, listener);
    }
    eventData.handlers.add(fn);
    return ()=>{
        eventData.handlers.delete(fn);
        if (eventData.handlers.size === 0) {
            document.removeEventListener(event, eventData.listener);
            $9fcc7f0d70d084ee$var$globalEvents.delete(event);
        }
    };
}
function $9fcc7f0d70d084ee$export$2314ca2a3e892862(options) {
    let isFocusedRef = (0, $fP8tg$useRef)(false);
    let { focusProps: focusProps } = (0, $fP8tg$useFocus)({
        onFocusChange: (isFocused)=>{
            isFocusedRef.current = isFocused;
        }
    });
    let onBeforeCopy = (0, $fP8tg$useEffectEvent)((e)=>{
        // Enable the "Copy" menu item in Safari if this element is focused and copying is supported.
        if (isFocusedRef.current && options.getItems) e.preventDefault();
    });
    let onCopy = (0, $fP8tg$useEffectEvent)((e)=>{
        var _options_onCopy;
        if (!isFocusedRef.current || !options.getItems) return;
        e.preventDefault();
        (0, $7252cd45fc48c07c$export$f9c1490890ddd063)(e.clipboardData, options.getItems());
        (_options_onCopy = options.onCopy) === null || _options_onCopy === void 0 ? void 0 : _options_onCopy.call(options);
    });
    let onBeforeCut = (0, $fP8tg$useEffectEvent)((e)=>{
        if (isFocusedRef.current && options.onCut && options.getItems) e.preventDefault();
    });
    let onCut = (0, $fP8tg$useEffectEvent)((e)=>{
        if (!isFocusedRef.current || !options.onCut || !options.getItems) return;
        e.preventDefault();
        (0, $7252cd45fc48c07c$export$f9c1490890ddd063)(e.clipboardData, options.getItems());
        options.onCut();
    });
    let onBeforePaste = (0, $fP8tg$useEffectEvent)((e)=>{
        // Unfortunately, e.clipboardData.types is not available in this event so we always
        // have to enable the Paste menu item even if the type of data is unsupported.
        if (isFocusedRef.current && options.onPaste) e.preventDefault();
    });
    let onPaste = (0, $fP8tg$useEffectEvent)((e)=>{
        if (!isFocusedRef.current || !options.onPaste) return;
        e.preventDefault();
        let items = (0, $7252cd45fc48c07c$export$d9e760437831f8b3)(e.clipboardData);
        options.onPaste(items);
    });
    (0, $fP8tg$useEffect)(()=>{
        return (0, $fP8tg$chain)($9fcc7f0d70d084ee$var$addGlobalEventListener("beforecopy", onBeforeCopy), $9fcc7f0d70d084ee$var$addGlobalEventListener("copy", onCopy), $9fcc7f0d70d084ee$var$addGlobalEventListener("beforecut", onBeforeCut), $9fcc7f0d70d084ee$var$addGlobalEventListener("cut", onCut), $9fcc7f0d70d084ee$var$addGlobalEventListener("beforepaste", onBeforePaste), $9fcc7f0d70d084ee$var$addGlobalEventListener("paste", onPaste));
    }, [
        onBeforeCopy,
        onCopy,
        onBeforeCut,
        onCut,
        onBeforePaste,
        onPaste
    ]);
    return {
        clipboardProps: focusProps
    };
}


/*
 * Copyright 2020 Adobe. All rights reserved.
 * This file is licensed to you under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License. You may obtain a copy
 * of the License at http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software distributed under
 * the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
 * OF ANY KIND, either express or implied. See the License for the specific language
 * governing permissions and limitations under the License.
 */ 

function $ad0e3f3d9c50e4ba$var$DragPreview(props, ref) {
    let render = props.children;
    let [children, setChildren] = (0, $fP8tg$useState)(null);
    let domRef = (0, $fP8tg$useRef)(null);
    (0, $fP8tg$useImperativeHandle)(ref, ()=>(items, callback)=>{
            // This will be called during the onDragStart event by useDrag. We need to render the
            // preview synchronously before this event returns so we can call event.dataTransfer.setDragImage.
            (0, $fP8tg$flushSync)(()=>{
                setChildren(render(items));
            });
            // Yield back to useDrag to set the drag image.
            callback(domRef.current);
            // Remove the preview from the DOM after a frame so the browser has time to paint.
            requestAnimationFrame(()=>{
                setChildren(null);
            });
        }, [
        render
    ]);
    if (!children) return null;
    return /*#__PURE__*/ (0, $fP8tg$react).createElement("div", {
        style: {
            zIndex: -100,
            position: "absolute",
            top: 0,
            left: -100000
        },
        ref: domRef
    }, children);
}
let $ad0e3f3d9c50e4ba$export$905ab40ac2179daa = /*#__PURE__*/ (0, $fP8tg$react).forwardRef($ad0e3f3d9c50e4ba$var$DragPreview);


class $3ca85212bf8898e4$export$fbd65d14c79e28cc {
    getPrimaryStart(rect) {
        return this.orientation === "horizontal" ? rect.left : rect.top;
    }
    getPrimaryEnd(rect) {
        return this.orientation === "horizontal" ? rect.right : rect.bottom;
    }
    getSecondaryStart(rect) {
        return this.orientation === "horizontal" ? rect.top : rect.left;
    }
    getSecondaryEnd(rect) {
        return this.orientation === "horizontal" ? rect.bottom : rect.right;
    }
    getFlowStart(rect) {
        return this.layout === "stack" ? this.getPrimaryStart(rect) : this.getSecondaryStart(rect);
    }
    getFlowEnd(rect) {
        return this.layout === "stack" ? this.getPrimaryEnd(rect) : this.getSecondaryEnd(rect);
    }
    getFlowSize(rect) {
        return this.getFlowEnd(rect) - this.getFlowStart(rect);
    }
    getDropTargetFromPoint(x, y, isValidDropTarget) {
        if (this.collection.size === 0) return {
            type: "root"
        };
        let rect = this.ref.current.getBoundingClientRect();
        let primary = this.orientation === "horizontal" ? x : y;
        let secondary = this.orientation === "horizontal" ? y : x;
        primary += this.getPrimaryStart(rect);
        secondary += this.getSecondaryStart(rect);
        let flow = this.layout === "stack" ? primary : secondary;
        let isPrimaryRTL = this.orientation === "horizontal" && this.direction === "rtl";
        let isSecondaryRTL = this.layout === "grid" && this.orientation === "vertical" && this.direction === "rtl";
        let isFlowRTL = this.layout === "stack" ? isPrimaryRTL : isSecondaryRTL;
        let elements = this.ref.current.querySelectorAll("[data-key]");
        let elementMap = new Map();
        for (let item of elements)if (item instanceof HTMLElement) elementMap.set(item.dataset.key, item);
        let items = [
            ...this.collection
        ];
        let low = 0;
        let high = items.length;
        while(low < high){
            let mid = Math.floor((low + high) / 2);
            let item = items[mid];
            let element = elementMap.get(String(item.key));
            let rect = element.getBoundingClientRect();
            let update = (isGreater)=>{
                if (isGreater) low = mid + 1;
                else high = mid;
            };
            if (primary < this.getPrimaryStart(rect)) update(isPrimaryRTL);
            else if (primary > this.getPrimaryEnd(rect)) update(!isPrimaryRTL);
            else if (secondary < this.getSecondaryStart(rect)) update(isSecondaryRTL);
            else if (secondary > this.getSecondaryEnd(rect)) update(!isSecondaryRTL);
            else {
                let target = {
                    type: "item",
                    key: item.key,
                    dropPosition: "on"
                };
                if (isValidDropTarget(target)) {
                    // Otherwise, if dropping on the item is accepted, try the before/after positions if within 5px
                    // of the start or end of the item.
                    if (flow <= this.getFlowStart(rect) + 5 && isValidDropTarget({
                        ...target,
                        dropPosition: "before"
                    })) target.dropPosition = isFlowRTL ? "after" : "before";
                    else if (flow >= this.getFlowEnd(rect) - 5 && isValidDropTarget({
                        ...target,
                        dropPosition: "after"
                    })) target.dropPosition = isFlowRTL ? "before" : "after";
                } else {
                    // If dropping on the item isn't accepted, try the target before or after depending on the position.
                    let mid = this.getFlowStart(rect) + this.getFlowSize(rect) / 2;
                    if (flow <= mid && isValidDropTarget({
                        ...target,
                        dropPosition: "before"
                    })) target.dropPosition = isFlowRTL ? "after" : "before";
                    else if (flow >= mid && isValidDropTarget({
                        ...target,
                        dropPosition: "after"
                    })) target.dropPosition = isFlowRTL ? "before" : "after";
                }
                return target;
            }
        }
        let item = items[Math.min(low, items.length - 1)];
        let element = elementMap.get(String(item.key));
        rect = element.getBoundingClientRect();
        if (primary < this.getPrimaryStart(rect) || Math.abs(flow - this.getFlowStart(rect)) < Math.abs(flow - this.getFlowEnd(rect))) return {
            type: "item",
            key: item.key,
            dropPosition: isFlowRTL ? "after" : "before"
        };
        return {
            type: "item",
            key: item.key,
            dropPosition: isFlowRTL ? "before" : "after"
        };
    }
    constructor(collection, ref, options){
        this.collection = collection;
        this.ref = ref;
        this.layout = (options === null || options === void 0 ? void 0 : options.layout) || "stack";
        this.orientation = (options === null || options === void 0 ? void 0 : options.orientation) || "vertical";
        this.direction = (options === null || options === void 0 ? void 0 : options.direction) || "ltr";
    }
}





export {$7252cd45fc48c07c$export$990fced5dfac2637 as DIRECTORY_DRAG_TYPE, $8253ed7ece74b463$export$7941f8aafa4b6021 as useDrag, $5c06e4929e123553$export$ccdee5eaf73cf661 as useDrop, $4b52e4eff84e5217$export$f4e2f423c21f7b04 as useDroppableCollection, $bfaab576ce1c580e$export$f7b0c5d28b66b6a5 as useDroppableItem, $ddf25448c71fc93a$export$8d0e41d2815afac5 as useDropIndicator, $fd98cf7cbf233429$export$b35afafff42da2d9 as useDraggableItem, $4ac1fdc3a0fcd564$export$2962a7984b2f0a80 as useDraggableCollection, $9fcc7f0d70d084ee$export$2314ca2a3e892862 as useClipboard, $ad0e3f3d9c50e4ba$export$905ab40ac2179daa as DragPreview, $3ca85212bf8898e4$export$fbd65d14c79e28cc as ListDropTargetDelegate, $67560de7c78cb232$export$403bc76cbf68cf60 as isVirtualDragging, $7252cd45fc48c07c$export$2b40a62bdbe6b2b0 as isDirectoryDropItem, $7252cd45fc48c07c$export$a144e1752ebe0aa as isFileDropItem, $7252cd45fc48c07c$export$97fd558bdc44bea1 as isTextDropItem};
//# sourceMappingURL=module.js.map
