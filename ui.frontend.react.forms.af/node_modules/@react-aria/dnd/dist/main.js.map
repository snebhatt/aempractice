{"mappings":"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","sources":["packages/@react-aria/dnd/src/index.ts","packages/@react-aria/dnd/src/utils.ts","packages/@react-aria/dnd/src/constants.ts","packages/@react-aria/dnd/src/useDrag.ts","packages/@react-aria/dnd/src/DragManager.ts","packages/@react-aria/dnd/src/*.js","packages/@react-aria/dnd/src/useDrop.ts","packages/@react-aria/dnd/src/useVirtualDrop.ts","packages/@react-aria/dnd/src/useDroppableCollection.ts","packages/@react-aria/dnd/src/useAutoScroll.ts","packages/@react-aria/dnd/src/useDroppableItem.ts","packages/@react-aria/dnd/src/useDropIndicator.ts","packages/@react-aria/dnd/src/useDraggableItem.ts","packages/@react-aria/dnd/src/useDraggableCollection.ts","packages/@react-aria/dnd/src/useClipboard.ts","packages/@react-aria/dnd/src/DragPreview.tsx","packages/@react-aria/dnd/src/ListDropTargetDelegate.ts"],"sourcesContent":["/*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */\n\nexport type {DroppableCollectionOptions, DroppableCollectionResult} from './useDroppableCollection';\nexport type {DroppableItemOptions, DroppableItemResult} from './useDroppableItem';\nexport type {DropIndicatorProps, DropIndicatorAria} from './useDropIndicator';\nexport type {DraggableItemProps, DraggableItemResult} from './useDraggableItem';\nexport type {DraggableCollectionOptions} from './useDraggableCollection';\nexport type {DragPreviewProps} from './DragPreview';\nexport type {DragOptions, DragResult} from './useDrag';\nexport type {DropOptions, DropResult} from './useDrop';\nexport type {ClipboardProps, ClipboardResult} from './useClipboard';\nexport type {\n  DirectoryDropItem,\n  DragEndEvent,\n  DraggableCollectionEndEvent,\n  DraggableCollectionMoveEvent,\n  DraggableCollectionStartEvent,\n  DragItem,\n  DragMoveEvent,\n  DragPreviewRenderer,\n  DragStartEvent,\n  DragTypes,\n  DropEnterEvent,\n  DropEvent,\n  DropExitEvent,\n  DropItem,\n  DropMoveEvent,\n  DropOperation,\n  DroppableCollectionDropEvent,\n  DroppableCollectionEnterEvent,\n  DroppableCollectionExitEvent,\n  DroppableCollectionInsertDropEvent,\n  DroppableCollectionMoveEvent,\n  DroppableCollectionOnItemDropEvent,\n  DroppableCollectionReorderEvent,\n  DroppableCollectionRootDropEvent,\n  DropPosition,\n  DropTarget,\n  DropTargetDelegate,\n  FileDropItem,\n  ItemDropTarget,\n  RootDropTarget,\n  TextDropItem\n} from '@react-types/shared';\n\nexport {DIRECTORY_DRAG_TYPE} from './utils';\nexport {useDrag} from './useDrag';\nexport {useDrop} from './useDrop';\nexport {useDroppableCollection} from './useDroppableCollection';\nexport {useDroppableItem} from './useDroppableItem';\nexport {useDropIndicator} from './useDropIndicator';\nexport {useDraggableItem} from './useDraggableItem';\nexport {useDraggableCollection} from './useDraggableCollection';\nexport {useClipboard} from './useClipboard';\nexport {DragPreview} from './DragPreview';\nexport {ListDropTargetDelegate} from './ListDropTargetDelegate';\nexport {isVirtualDragging} from './DragManager';\nexport {isDirectoryDropItem, isFileDropItem, isTextDropItem} from './utils';\n","/*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */\n\nimport {CUSTOM_DRAG_TYPE, DROP_OPERATION, GENERIC_TYPE, NATIVE_DRAG_TYPES} from './constants';\nimport {DirectoryDropItem, DragItem, DropItem, FileDropItem, DragTypes as IDragTypes, Key, TextDropItem} from '@react-types/shared';\nimport {DroppableCollectionState} from '@react-stately/dnd';\nimport {getInteractionModality, useInteractionModality} from '@react-aria/interactions';\nimport {RefObject} from 'react';\n\ninterface DroppableCollectionMap {\n  id: string,\n  ref: RefObject<HTMLElement>\n}\n\nexport const droppableCollectionMap = new WeakMap<DroppableCollectionState, DroppableCollectionMap>();\nexport const DIRECTORY_DRAG_TYPE = Symbol();\n\nexport function getDroppableCollectionId(state: DroppableCollectionState) {\n  let {id} = droppableCollectionMap.get(state);\n  if (!id) {\n    throw new Error('Droppable item outside a droppable collection');\n  }\n\n  return id;\n}\n\nexport function getDroppableCollectionRef(state: DroppableCollectionState) {\n  let {ref} = droppableCollectionMap.get(state);\n  if (!ref) {\n    throw new Error('Droppable item outside a droppable collection');\n  }\n\n  return ref;\n}\n\nexport function getTypes(items: DragItem[]): Set<string> {\n  let types = new Set<string>();\n  for (let item of items) {\n    for (let type of Object.keys(item)) {\n      types.add(type);\n    }\n  }\n\n  return types;\n}\n\nfunction mapModality(modality: string) {\n  if (!modality) {\n    modality = 'virtual';\n  }\n\n  if (modality === 'pointer') {\n    modality = 'virtual';\n  }\n\n  if (modality === 'virtual' &&  (typeof window !== 'undefined' && 'ontouchstart' in window)) {\n    modality = 'touch';\n  }\n\n  return modality;\n}\n\nexport function useDragModality() {\n  return mapModality(useInteractionModality());\n}\n\nexport function getDragModality() {\n  return mapModality(getInteractionModality());\n}\n\nexport function writeToDataTransfer(dataTransfer: DataTransfer, items: DragItem[]) {\n  // The data transfer API doesn't support more than one item of a given type at once.\n  // In addition, only a small set of types are supported natively for transfer between applications.\n  // We allow for both multiple items, as well as multiple representations of a single item.\n  // In order to make our API work with the native API, we serialize all items to JSON and\n  // store as a single native item. We only need to do this if there is more than one item\n  // of the same type, or if an item has more than one representation. Otherwise the native\n  // API is sufficient.\n  //\n  // The DataTransferItemList API also theoretically supports adding files, which would enable\n  // dragging binary data out of the browser onto the user's desktop for example. Unfortunately,\n  // this does not currently work in any browser, so it is not currently supported by our API.\n  // See e.g. https://bugs.chromium.org/p/chromium/issues/detail?id=438479.\n  let groupedByType = new Map<string, string[]>();\n  let needsCustomData = false;\n  let customData = [];\n  for (let item of items) {\n    let types = Object.keys(item);\n    if (types.length > 1) {\n      needsCustomData = true;\n    }\n\n    let dataByType = {};\n    for (let type of types) {\n      let typeItems = groupedByType.get(type);\n      if (!typeItems) {\n        typeItems = [];\n        groupedByType.set(type, typeItems);\n      } else {\n        needsCustomData = true;\n      }\n\n      let data = item[type];\n      dataByType[type] = data;\n      typeItems.push(data);\n    }\n\n    customData.push(dataByType);\n  }\n\n  for (let [type, items] of groupedByType) {\n    if (NATIVE_DRAG_TYPES.has(type)) {\n      // Only one item of a given type can be set on a data transfer.\n      // Join all of the items together separated by newlines.\n      let data = items.join('\\n');\n      dataTransfer.items.add(data, type);\n    } else {\n      // Set data to the first item so we have access to the list of types.\n      dataTransfer.items.add(items[0], type);\n    }\n  }\n\n  if (needsCustomData) {\n    let data = JSON.stringify(customData);\n    dataTransfer.items.add(data, CUSTOM_DRAG_TYPE);\n  }\n}\n\nexport class DragTypes implements IDragTypes {\n  private types: Set<string>;\n  private includesUnknownTypes: boolean;\n\n  constructor(dataTransfer: DataTransfer) {\n    this.types = new Set<string>();\n\n    let hasFiles = false;\n    for (let item of dataTransfer.items) {\n      if (item.type !== CUSTOM_DRAG_TYPE) {\n        if (item.kind === 'file') {\n          hasFiles = true;\n        }\n\n        if (item.type) {\n          this.types.add(item.type);\n        } else {\n          // Files with unknown types or extensions that don't map to a known mime type\n          // are sometimes exposed as an empty string by the browser. Map to a generic\n          // mime type instead. Note that this could also be a directory as there's no\n          // way to determine if something is a file or directory until drop.\n          this.types.add(GENERIC_TYPE);\n        }\n      }\n    }\n\n    // In Safari, when dragging files, the dataTransfer.items list is empty, but dataTransfer.types contains \"Files\".\n    // Unfortunately, this doesn't tell us what types of files the user is dragging, so we need to assume that any\n    // type the user checks for is included. See https://bugs.webkit.org/show_bug.cgi?id=223517.\n    this.includesUnknownTypes = !hasFiles && dataTransfer.types.includes('Files');\n  }\n\n  has(type: string | symbol) {\n    if (this.includesUnknownTypes || (type === DIRECTORY_DRAG_TYPE && this.types.has(GENERIC_TYPE))) {\n      return true;\n    }\n\n    return typeof type === 'string' && this.types.has(type);\n  }\n}\n\nexport function readFromDataTransfer(dataTransfer: DataTransfer) {\n  let items: DropItem[] = [];\n\n  // If our custom drag type is available, use that. This is a JSON serialized\n  // representation of all items in the drag, set when there are multiple items\n  // of the same type, or an individual item has multiple representations.\n  let hasCustomType = false;\n  if (dataTransfer.types.includes(CUSTOM_DRAG_TYPE)) {\n    try {\n      let data = dataTransfer.getData(CUSTOM_DRAG_TYPE);\n      let parsed = JSON.parse(data);\n      for (let item of parsed) {\n        items.push({\n          kind: 'text',\n          types: new Set(Object.keys(item)),\n          getText: (type) => Promise.resolve(item[type])\n        });\n      }\n\n      hasCustomType = true;\n    } catch (e) {\n      // ignore\n    }\n  }\n\n  // Otherwise, map native drag items to items of a single representation.\n  if (!hasCustomType) {\n    let stringItems = new Map();\n    for (let item of dataTransfer.items) {\n      if (item.kind === 'string') {\n        // The data for all formats must be read here because the data transfer gets\n        // cleared out after the event handler finishes. If the item has an empty string\n        // as a type, the mime type is unknown. Map to a generic mime type instead.\n        stringItems.set(item.type || GENERIC_TYPE, dataTransfer.getData(item.type));\n      } else if (item.kind === 'file') {\n        // Despite the name, webkitGetAsEntry is also implemented in Firefox and Edge.\n        // In the future, we may use getAsFileSystemHandle instead, but that's currently\n        // only implemented in Chrome.\n        if (typeof item.webkitGetAsEntry === 'function') {\n          let entry: FileSystemEntry = item.webkitGetAsEntry();\n          // eslint-disable-next-line max-depth\n          if (!entry) {\n            // For some reason, Firefox includes an item with type image/png when copy\n            // and pasting any file or directory (no matter the type), but returns `null` for both\n            // item.getAsFile() and item.webkitGetAsEntry(). Safari works as expected. Ignore this\n            // item if this happens. See https://bugzilla.mozilla.org/show_bug.cgi?id=1699743.\n            // This was recently fixed in Chrome Canary: https://bugs.chromium.org/p/chromium/issues/detail?id=1175483.\n            continue;\n          }\n\n          // eslint-disable-next-line max-depth\n          if (entry.isFile) {\n            items.push(createFileItem(item.getAsFile()));\n          } else if (entry.isDirectory) {\n            items.push(createDirectoryItem(entry));\n          }\n        } else {\n          // Assume it's a file.\n          items.push(createFileItem(item.getAsFile()));\n        }\n      }\n    }\n\n    // All string items are different representations of the same item. There's no way to have\n    // multiple string items at once in the current DataTransfer API.\n    if (stringItems.size > 0) {\n      items.push({\n        kind: 'text',\n        types: new Set(stringItems.keys()),\n        getText: (type) => Promise.resolve(stringItems.get(type))\n      });\n    }\n  }\n\n  return items;\n}\n\nfunction blobToString(blob: Blob): Promise<string> {\n  if (typeof blob.text === 'function') {\n    return blob.text();\n  }\n\n  // Safari doesn't have the Blob#text() method yet...\n  return new Promise((resolve, reject) => {\n    let reader = new FileReader;\n    reader.onload = () => {\n      resolve(reader.result as string);\n    };\n\n    reader.onerror = reject;\n    reader.readAsText(blob);\n  });\n}\n\nfunction createFileItem(file: File): FileDropItem {\n  return {\n    kind: 'file',\n    type: file.type || GENERIC_TYPE,\n    name: file.name,\n    getText: () => blobToString(file),\n    getFile: () => Promise.resolve(file)\n  };\n}\n\nfunction createDirectoryItem(entry: any): DirectoryDropItem {\n  return {\n    kind: 'directory',\n    name: entry.name,\n    getEntries: () => getEntries(entry)\n  };\n}\n\nasync function *getEntries(item: FileSystemDirectoryEntry): AsyncIterable<FileDropItem | DirectoryDropItem> {\n  let reader = item.createReader();\n\n  // We must call readEntries repeatedly because there may be a limit to the\n  // number of entries that are returned at once.\n  let entries: FileSystemEntry[];\n  do {\n    entries = await new Promise((resolve, reject) => {\n      reader.readEntries(resolve, reject);\n    });\n\n    for (let entry of entries) {\n      if (entry.isFile) {\n        let file = await getEntryFile(entry as FileSystemFileEntry);\n        yield createFileItem(file);\n      } else if (entry.isDirectory) {\n        yield createDirectoryItem(entry);\n      }\n    }\n  } while (entries.length > 0);\n}\n\nfunction getEntryFile(entry: FileSystemFileEntry): Promise<File> {\n  return new Promise((resolve, reject) => entry.file(resolve, reject));\n}\n\n/** Returns whether a drop item contains text data. */\nexport function isTextDropItem(dropItem: DropItem): dropItem is TextDropItem {\n  return dropItem.kind === 'text';\n}\n\n/** Returns whether a drop item is a file. */\nexport function isFileDropItem(dropItem: DropItem): dropItem is FileDropItem {\n  return dropItem.kind === 'file';\n}\n\n/** Returns whether a drop item is a directory. */\nexport function isDirectoryDropItem(dropItem: DropItem): dropItem is DirectoryDropItem {\n  return dropItem.kind === 'directory';\n}\n\n// Global DnD collection state tracker.\nexport interface DnDState {\n  /** A ref for the  of the drag items in the current drag session if any. */\n  draggingCollectionRef?: RefObject<HTMLElement>,\n  /** The set of currently dragged keys. */\n  draggingKeys: Set<Key>,\n  /** A ref for the collection that is targeted for a drop operation, if any. */\n  dropCollectionRef?: RefObject<HTMLElement>\n}\n\nexport let globalDndState: DnDState = {draggingKeys: new Set()};\n\nexport function setDraggingCollectionRef(ref: RefObject<HTMLElement>) {\n  globalDndState.draggingCollectionRef = ref;\n}\n\nexport function setDraggingKeys(keys: Set<Key>) {\n  globalDndState.draggingKeys = keys;\n}\n\nexport function setDropCollectionRef(ref: RefObject<HTMLElement>) {\n  globalDndState.dropCollectionRef = ref;\n}\n\nexport function clearGlobalDnDState() {\n  globalDndState = {draggingKeys: new Set()};\n}\n\nexport function setGlobalDnDState(state: DnDState) {\n  globalDndState = state;\n}\n\n// Util function to check if the current dragging collection ref is the same as the current targeted droppable collection ref.\n// Allows a droppable ref arg in case the global drop collection ref hasn't been set\nexport function isInternalDropOperation(ref?: RefObject<HTMLElement>) {\n  let {draggingCollectionRef, dropCollectionRef} = globalDndState;\n  return draggingCollectionRef?.current != null && draggingCollectionRef.current === (ref?.current || dropCollectionRef?.current);\n}\n\ntype DropEffect = 'none' | 'copy' | 'link' | 'move';\nexport let globalDropEffect: DropEffect;\nexport function setGlobalDropEffect(dropEffect: DropEffect) {\n  globalDropEffect = dropEffect;\n}\n\nexport let globalAllowedDropOperations = DROP_OPERATION.none;\nexport function setGlobalAllowedDropOperations(o: DROP_OPERATION) {\n  globalAllowedDropOperations = o;\n}\n","/*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */\n\nimport {DropOperation} from '@react-types/shared';\n\nexport enum DROP_OPERATION {\n  none = 0,\n  cancel = 0,\n  move = 1 << 0,\n  copy = 1 << 1,\n  link = 1 << 2,\n  all = move | copy | link\n}\n\n// See https://developer.mozilla.org/en-US/docs/Web/API/DataTransfer/effectAllowed\nexport const DROP_OPERATION_ALLOWED = {\n  ...DROP_OPERATION,\n  copyMove: DROP_OPERATION.copy | DROP_OPERATION.move,\n  copyLink: DROP_OPERATION.copy | DROP_OPERATION.link,\n  linkMove: DROP_OPERATION.link | DROP_OPERATION.move,\n  all: DROP_OPERATION.all,\n  uninitialized: DROP_OPERATION.all\n};\n\nexport const EFFECT_ALLOWED = invert(DROP_OPERATION_ALLOWED);\nEFFECT_ALLOWED[DROP_OPERATION.all] = 'all'; // ensure we don't map to 'uninitialized'.\n\nexport const DROP_EFFECT = invert(DROP_OPERATION);\nexport const DROP_EFFECT_TO_DROP_OPERATION: {[name: string]: DropOperation} = {\n  none: 'cancel',\n  link: 'link',\n  copy: 'copy',\n  move: 'move'\n};\n\nexport const DROP_OPERATION_TO_DROP_EFFECT = invert(DROP_EFFECT_TO_DROP_OPERATION);\n\nfunction invert(object) {\n  let res = {};\n  for (let key in object) {\n    res[object[key]] = key;\n  }\n\n  return res;\n}\n\nexport const NATIVE_DRAG_TYPES = new Set(['text/plain', 'text/uri-list', 'text/html']);\nexport const CUSTOM_DRAG_TYPE = 'application/vnd.react-aria.items+json';\nexport const GENERIC_TYPE = 'application/octet-stream';\n","/*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */\n\nimport {AriaButtonProps} from '@react-types/button';\nimport {DragEndEvent, DragItem, DragMoveEvent, DragPreviewRenderer, DragStartEvent, DropOperation, PressEvent} from '@react-types/shared';\nimport {DragEvent, HTMLAttributes, RefObject, useRef, useState} from 'react';\nimport * as DragManager from './DragManager';\nimport {DROP_EFFECT_TO_DROP_OPERATION, DROP_OPERATION, EFFECT_ALLOWED} from './constants';\nimport {globalDropEffect, setGlobalAllowedDropOperations, setGlobalDropEffect, useDragModality, writeToDataTransfer} from './utils';\n// @ts-ignore\nimport intlMessages from '../intl/*.json';\nimport {isVirtualClick, isVirtualPointerEvent, useDescription, useGlobalListeners, useLayoutEffect} from '@react-aria/utils';\nimport {useLocalizedStringFormatter} from '@react-aria/i18n';\n\nexport interface DragOptions {\n  /** Handler that is called when a drag operation is started. */\n  onDragStart?: (e: DragStartEvent) => void,\n  /** Handler that is called when the drag is moved. */\n  onDragMove?: (e: DragMoveEvent) => void,\n  /** Handler that is called when the drag operation is ended, either as a result of a drop or a cancellation. */\n  onDragEnd?: (e: DragEndEvent) => void,\n  /** A function that returns the items being dragged. */\n  getItems: () => DragItem[],\n  /** The ref of the element that will be rendered as the drag preview while dragging. */\n  preview?: RefObject<DragPreviewRenderer>,\n  /** Function that returns the drop operations that are allowed for the dragged items. If not provided, all drop operations are allowed. */\n  getAllowedDropOperations?: () => DropOperation[],\n  /**\n   * Whether the item has an explicit focusable drag affordance to initiate accessible drag and drop mode.\n   * If true, the dragProps will omit these event handlers, and they will be applied to dragButtonProps instead.\n   */\n  hasDragButton?: boolean\n}\n\nexport interface DragResult {\n  /** Props for the draggable element. */\n  dragProps: HTMLAttributes<HTMLElement>,\n  /** Props for the explicit drag button affordance, if any. */\n  dragButtonProps: AriaButtonProps,\n  /** Whether the element is currently being dragged. */\n  isDragging: boolean\n}\n\nconst MESSAGES = {\n  keyboard: {\n    start: 'dragDescriptionKeyboard',\n    end: 'endDragKeyboard'\n  },\n  touch: {\n    start: 'dragDescriptionTouch',\n    end: 'endDragTouch'\n  },\n  virtual: {\n    start: 'dragDescriptionVirtual',\n    end: 'endDragVirtual'\n  }\n};\n\n/**\n * Handles drag interactions for an element, with support for traditional mouse and touch\n * based drag and drop, in addition to full parity for keyboard and screen reader users.\n */\nexport function useDrag(options: DragOptions): DragResult {\n  let {hasDragButton} = options;\n  let stringFormatter = useLocalizedStringFormatter(intlMessages, '@react-aria/dnd');\n  let state = useRef({\n    options,\n    x: 0,\n    y: 0\n  }).current;\n  state.options = options;\n  let isDraggingRef = useRef(false);\n  let [isDragging, setDraggingState] = useState(false);\n  let setDragging = (isDragging) => {\n    isDraggingRef.current = isDragging;\n    setDraggingState(isDragging);\n  };\n  let {addGlobalListener, removeAllGlobalListeners} = useGlobalListeners();\n  let modalityOnPointerDown = useRef<string>(null);\n\n  let onDragStart = (e: DragEvent) => {\n    if (e.defaultPrevented) {\n      return;\n    }\n\n    // Prevent the drag event from propagating to any parent draggables\n    e.stopPropagation();\n\n    // If this drag was initiated by a mobile screen reader (e.g. VoiceOver or TalkBack), enter virtual dragging mode.\n    if (modalityOnPointerDown.current === 'virtual') {\n      e.preventDefault();\n      startDragging(e.target as HTMLElement);\n      modalityOnPointerDown.current = null;\n      return;\n    }\n\n    if (typeof options.onDragStart === 'function') {\n      options.onDragStart({\n        type: 'dragstart',\n        x: e.clientX,\n        y: e.clientY\n      });\n    }\n\n    let items = options.getItems();\n    writeToDataTransfer(e.dataTransfer, items);\n\n    let allowed = DROP_OPERATION.all;\n    if (typeof options.getAllowedDropOperations === 'function') {\n      let allowedOperations = options.getAllowedDropOperations();\n      allowed = DROP_OPERATION.none;\n      for (let operation of allowedOperations) {\n        allowed |= DROP_OPERATION[operation] || DROP_OPERATION.none;\n      }\n    }\n\n    setGlobalAllowedDropOperations(allowed);\n    e.dataTransfer.effectAllowed = EFFECT_ALLOWED[allowed] || 'none';\n\n    // If there is a preview option, use it to render a custom preview image that will\n    // appear under the pointer while dragging. If not, the element itself is dragged by the browser.\n    if (typeof options.preview?.current === 'function') {\n      options.preview.current(items, node => {\n        // Compute the offset that the preview will appear under the mouse.\n        // If possible, this is based on the point the user clicked on the target.\n        // If the preview is much smaller, then just use the center point of the preview.\n        let size = node.getBoundingClientRect();\n        let rect = e.currentTarget.getBoundingClientRect();\n        let x = e.clientX - rect.x;\n        let y = e.clientY - rect.y;\n        if (x > size.width || y > size.height) {\n          x = size.width / 2;\n          y = size.height / 2;\n        }\n\n        // Rounding height to an even number prevents blurry preview seen on some screens\n        let height = 2 * Math.round(size.height / 2);\n        node.style.height = `${height}px`;\n\n        e.dataTransfer.setDragImage(node, x, y);\n      });\n    }\n\n    // Enforce that drops are handled by useDrop.\n    addGlobalListener(window, 'drop', e => {\n      e.preventDefault();\n      e.stopPropagation();\n      console.warn('Drags initiated from the React Aria useDrag hook may only be dropped on a target created with useDrop. This ensures that a keyboard and screen reader accessible alternative is available.');\n    }, {once: true});\n    state.x = e.clientX;\n    state.y = e.clientY;\n\n    // Wait a frame before we set dragging to true so that the browser has time to\n    // render the preview image before we update the element that has been dragged.\n    requestAnimationFrame(() => {\n      setDragging(true);\n    });\n  };\n\n  let onDrag = (e: DragEvent) => {\n    // Prevent the drag event from propagating to any parent draggables\n    e.stopPropagation();\n\n    if (e.clientX === state.x && e.clientY === state.y) {\n      return;\n    }\n\n    if (typeof options.onDragMove === 'function') {\n      options.onDragMove({\n        type: 'dragmove',\n        x: e.clientX,\n        y: e.clientY\n      });\n    }\n\n    state.x = e.clientX;\n    state.y = e.clientY;\n  };\n\n  let onDragEnd = (e: DragEvent) => {\n    // Prevent the drag event from propagating to any parent draggables\n    e.stopPropagation();\n\n    if (typeof options.onDragEnd === 'function') {\n      let event: DragEndEvent = {\n        type: 'dragend',\n        x: e.clientX,\n        y: e.clientY,\n        dropOperation: DROP_EFFECT_TO_DROP_OPERATION[e.dataTransfer.dropEffect]\n      };\n\n      // Chrome Android always returns none as its dropEffect so we use the drop effect set in useDrop via\n      // onDragEnter/onDragOver instead. https://bugs.chromium.org/p/chromium/issues/detail?id=1353951\n      if (globalDropEffect) {\n        event.dropOperation = DROP_EFFECT_TO_DROP_OPERATION[globalDropEffect];\n      }\n      options.onDragEnd(event);\n    }\n\n    setDragging(false);\n    removeAllGlobalListeners();\n    setGlobalAllowedDropOperations(DROP_OPERATION.none);\n    setGlobalDropEffect(undefined);\n  };\n\n  // If the dragged element is removed from the DOM via onDrop, onDragEnd won't fire: https://bugzilla.mozilla.org/show_bug.cgi?id=460801\n  // In this case, we need to manually call onDragEnd on cleanup\n  // eslint-disable-next-line arrow-body-style\n  useLayoutEffect(() => {\n    return () => {\n      if (isDraggingRef.current) {\n        if (typeof state.options.onDragEnd === 'function') {\n          let event: DragEndEvent = {\n            type: 'dragend',\n            x: 0,\n            y: 0,\n            dropOperation: DROP_EFFECT_TO_DROP_OPERATION[globalDropEffect || 'none']\n          };\n          state.options.onDragEnd(event);\n        }\n\n        setDragging(false);\n        setGlobalAllowedDropOperations(DROP_OPERATION.none);\n        setGlobalDropEffect(undefined);\n      }\n    };\n  }, [state]);\n\n  let onPress = (e: PressEvent) => {\n    if (e.pointerType !== 'keyboard' && e.pointerType !== 'virtual') {\n      return;\n    }\n\n    startDragging(e.target as HTMLElement);\n  };\n\n  let startDragging = (target: HTMLElement) => {\n    if (typeof state.options.onDragStart === 'function') {\n      let rect = target.getBoundingClientRect();\n      state.options.onDragStart({\n        type: 'dragstart',\n        x: rect.x + (rect.width / 2),\n        y: rect.y + (rect.height / 2)\n      });\n    }\n\n    DragManager.beginDragging({\n      element: target,\n      items: state.options.getItems(),\n      allowedDropOperations: typeof state.options.getAllowedDropOperations === 'function'\n        ? state.options.getAllowedDropOperations()\n        : ['move', 'copy', 'link'],\n      onDragEnd(e) {\n        setDragging(false);\n        if (typeof state.options.onDragEnd === 'function') {\n          state.options.onDragEnd(e);\n        }\n      }\n    }, stringFormatter);\n\n    setDragging(true);\n  };\n\n  let modality = useDragModality();\n  let message = !isDragging ? MESSAGES[modality].start : MESSAGES[modality].end;\n\n  let descriptionProps = useDescription(stringFormatter.format(message));\n\n  let interactions: HTMLAttributes<HTMLElement>;\n  if (!hasDragButton) {\n    // If there's no separate button to trigger accessible drag and drop mode,\n    // then add event handlers to the draggable element itself to start dragging.\n    // For keyboard, we use the Enter key in a capturing listener to prevent other\n    // events such as selection from also occurring. We attempt to infer whether a\n    // pointer event (e.g. long press) came from a touch screen reader, and then initiate\n    // dragging in the native onDragStart listener above.\n\n    interactions = {\n      ...descriptionProps,\n      onPointerDown(e) {\n        modalityOnPointerDown.current = isVirtualPointerEvent(e.nativeEvent) ? 'virtual' : e.pointerType;\n\n        // Try to detect virtual drag passthrough gestures.\n        if (e.width < 1 && e.height < 1) {\n          // iOS VoiceOver.\n          modalityOnPointerDown.current = 'virtual';\n        } else {\n          let rect = e.currentTarget.getBoundingClientRect();\n          let offsetX = e.clientX - rect.x;\n          let offsetY = e.clientY - rect.y;\n          let centerX = rect.width / 2;\n          let centerY = rect.height / 2;\n\n          if (Math.abs(offsetX - centerX) <= 0.5 && Math.abs(offsetY - centerY) <= 0.5) {\n            // Android TalkBack.\n            modalityOnPointerDown.current = 'virtual';\n          } else {\n            modalityOnPointerDown.current = e.pointerType;\n          }\n        }\n      },\n      onKeyDownCapture(e) {\n        if (e.target === e.currentTarget && e.key === 'Enter') {\n          e.preventDefault();\n          e.stopPropagation();\n        }\n      },\n      onKeyUpCapture(e) {\n        if (e.target === e.currentTarget && e.key === 'Enter') {\n          e.preventDefault();\n          e.stopPropagation();\n          startDragging(e.target as HTMLElement);\n        }\n      },\n      onClick(e) {\n        // Handle NVDA/JAWS in browse mode, and touch screen readers. In this case, no keyboard events are fired.\n        if (isVirtualClick(e.nativeEvent) || modalityOnPointerDown.current === 'virtual') {\n          e.preventDefault();\n          e.stopPropagation();\n          startDragging(e.target as HTMLElement);\n        }\n      }\n    };\n  }\n\n  return {\n    dragProps: {\n      ...interactions,\n      draggable: 'true',\n      onDragStart,\n      onDrag,\n      onDragEnd\n    },\n    dragButtonProps: {\n      ...descriptionProps,\n      onPress\n    },\n    isDragging\n  };\n}\n","/*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */\n\nimport {announce} from '@react-aria/live-announcer';\nimport {ariaHideOutside} from '@react-aria/overlays';\nimport {DragEndEvent, DragItem, DropActivateEvent, DropEnterEvent, DropEvent, DropExitEvent, DropItem, DropOperation, DropTarget as DroppableCollectionTarget, FocusableElement} from '@react-types/shared';\nimport {flushSync} from 'react-dom';\nimport {getDragModality, getTypes} from './utils';\nimport {isVirtualClick, isVirtualPointerEvent} from '@react-aria/utils';\nimport type {LocalizedStringFormatter} from '@internationalized/string';\nimport {useEffect, useState} from 'react';\n\nlet dropTargets = new Map<Element, DropTarget>();\nlet dropItems = new Map<Element, DroppableItem>();\nlet dragSession: DragSession = null;\nlet subscriptions = new Set<() => void>();\n\ninterface DropTarget {\n  element: FocusableElement,\n  getDropOperation?: (types: Set<string>, allowedOperations: DropOperation[]) => DropOperation,\n  onDropEnter?: (e: DropEnterEvent, dragTarget: DragTarget) => void,\n  onDropExit?: (e: DropExitEvent) => void,\n  onDropTargetEnter?: (target?: DroppableCollectionTarget) => void,\n  onDropActivate?: (e: DropActivateEvent, target?: DroppableCollectionTarget) => void,\n  onDrop?: (e: DropEvent, target?: DroppableCollectionTarget) => void,\n  onKeyDown?: (e: KeyboardEvent, dragTarget: DragTarget) => void\n}\n\nexport function registerDropTarget(target: DropTarget) {\n  dropTargets.set(target.element, target);\n  dragSession?.updateValidDropTargets();\n  return () => {\n    dropTargets.delete(target.element);\n    dragSession?.updateValidDropTargets();\n  };\n}\n\ninterface DroppableItem {\n  element: FocusableElement,\n  target: DroppableCollectionTarget,\n  getDropOperation?: (types: Set<string>, allowedOperations: DropOperation[]) => DropOperation\n}\n\nexport function registerDropItem(item: DroppableItem) {\n  dropItems.set(item.element, item);\n  return () => {\n    dropItems.delete(item.element);\n  };\n}\n\ninterface DragTarget {\n  element: FocusableElement,\n  items: DragItem[],\n  allowedDropOperations: DropOperation[],\n  onDragEnd?: (e: DragEndEvent) => void\n}\n\nexport function beginDragging(target: DragTarget, stringFormatter: LocalizedStringFormatter) {\n  if (dragSession) {\n    throw new Error('Cannot begin dragging while already dragging');\n  }\n\n  dragSession = new DragSession(target, stringFormatter);\n  requestAnimationFrame(() => {\n    dragSession.setup();\n    if (getDragModality() === 'keyboard') {\n      dragSession.next();\n    }\n  });\n\n  for (let cb of subscriptions) {\n    cb();\n  }\n}\n\nexport function useDragSession() {\n  let [session, setSession] = useState(dragSession);\n\n  useEffect(() => {\n    let cb = () => setSession(dragSession);\n    subscriptions.add(cb);\n    return () => {\n      subscriptions.delete(cb);\n    };\n  }, []);\n\n  return session;\n}\n\n/** @private */\nexport function isVirtualDragging(): boolean {\n  return !!dragSession;\n}\n\nfunction endDragging() {\n  dragSession = null;\n  for (let cb of subscriptions) {\n    cb();\n  }\n}\n\nexport function isValidDropTarget(element: Element): boolean {\n  for (let target of dropTargets.keys()) {\n    if (target.contains(element)) {\n      return true;\n    }\n  }\n\n  return false;\n}\n\nconst CANCELED_EVENTS = [\n  'pointerdown',\n  'pointermove',\n  'pointerenter',\n  'pointerleave',\n  'pointerover',\n  'pointerout',\n  'pointerup',\n  'mousedown',\n  'mousemove',\n  'mouseenter',\n  'mouseleave',\n  'mouseover',\n  'mouseout',\n  'mouseup',\n  'touchstart',\n  'touchmove',\n  'touchend',\n  'focusin',\n  'focusout'\n];\n\nconst CLICK_EVENTS = [\n  'pointerup',\n  'mouseup',\n  'touchend'\n];\n\nconst MESSAGES = {\n  keyboard: 'dragStartedKeyboard',\n  touch: 'dragStartedTouch',\n  virtual: 'dragStartedVirtual'\n};\n\nclass DragSession {\n  dragTarget: DragTarget;\n  validDropTargets: DropTarget[];\n  currentDropTarget: DropTarget;\n  currentDropItem: DroppableItem;\n  dropOperation: DropOperation;\n  private mutationObserver: MutationObserver;\n  private restoreAriaHidden: () => void;\n  private stringFormatter: LocalizedStringFormatter;\n  private isVirtualClick: boolean;\n  private initialFocused: boolean;\n\n  constructor(target: DragTarget, stringFormatter: LocalizedStringFormatter) {\n    this.dragTarget = target;\n    this.stringFormatter = stringFormatter;\n\n    this.onKeyDown = this.onKeyDown.bind(this);\n    this.onKeyUp = this.onKeyUp.bind(this);\n    this.onFocus = this.onFocus.bind(this);\n    this.onBlur = this.onBlur.bind(this);\n    this.onClick = this.onClick.bind(this);\n    this.onPointerDown = this.onPointerDown.bind(this);\n    this.cancelEvent = this.cancelEvent.bind(this);\n    this.initialFocused = false;\n  }\n\n  setup() {\n    document.addEventListener('keydown', this.onKeyDown, true);\n    document.addEventListener('keyup', this.onKeyUp, true);\n    window.addEventListener('focus', this.onFocus, true);\n    window.addEventListener('blur', this.onBlur, true);\n    document.addEventListener('click', this.onClick, true);\n    document.addEventListener('pointerdown', this.onPointerDown, true);\n\n    for (let event of CANCELED_EVENTS) {\n      document.addEventListener(event, this.cancelEvent, true);\n    }\n\n    this.mutationObserver = new MutationObserver(() =>\n      this.updateValidDropTargets()\n    );\n    this.updateValidDropTargets();\n\n    announce(this.stringFormatter.format(MESSAGES[getDragModality()]));\n  }\n\n  teardown() {\n    document.removeEventListener('keydown', this.onKeyDown, true);\n    document.removeEventListener('keyup', this.onKeyUp, true);\n    window.removeEventListener('focus', this.onFocus, true);\n    window.removeEventListener('blur', this.onBlur, true);\n    document.removeEventListener('click', this.onClick, true);\n    document.removeEventListener('pointerdown', this.onPointerDown, true);\n\n    for (let event of CANCELED_EVENTS) {\n      document.removeEventListener(event, this.cancelEvent, true);\n    }\n\n    this.mutationObserver.disconnect();\n    this.restoreAriaHidden();\n  }\n\n  onKeyDown(e: KeyboardEvent) {\n    this.cancelEvent(e);\n\n    if (e.key === 'Escape') {\n      this.cancel();\n      return;\n    }\n\n    if (e.key === 'Tab' && !(e.metaKey || e.altKey || e.ctrlKey)) {\n      if (e.shiftKey) {\n        this.previous();\n      } else {\n        this.next();\n      }\n    }\n\n    if (typeof this.currentDropTarget?.onKeyDown === 'function') {\n      this.currentDropTarget.onKeyDown(e, this.dragTarget);\n    }\n  }\n\n  onKeyUp(e: KeyboardEvent) {\n    this.cancelEvent(e);\n\n    if (e.key === 'Enter') {\n      if (e.altKey) {\n        this.activate();\n      } else {\n        this.drop();\n      }\n    }\n  }\n\n  onFocus(e: FocusEvent) {\n    // Prevent focus events, except to the original drag target.\n    if (e.target !== this.dragTarget.element) {\n      this.cancelEvent(e);\n    }\n\n    // Ignore focus events on the window/document (JSDOM). Will be handled in onBlur, below.\n    if (!(e.target instanceof HTMLElement) || e.target === this.dragTarget.element) {\n      return;\n    }\n\n    let dropTarget =\n      this.validDropTargets.find(target => target.element === e.target as HTMLElement) ||\n      this.validDropTargets.find(target => target.element.contains(e.target as HTMLElement));\n\n    if (!dropTarget) {\n      if (this.currentDropTarget) {\n        this.currentDropTarget.element.focus();\n      } else {\n        this.dragTarget.element.focus();\n      }\n      return;\n    }\n\n    let item = dropItems.get(e.target as HTMLElement);\n    this.setCurrentDropTarget(dropTarget, item);\n  }\n\n  onBlur(e: FocusEvent) {\n    if (e.target !== this.dragTarget.element) {\n      this.cancelEvent(e);\n    }\n\n    // If nothing is gaining focus, or e.relatedTarget is the window/document (JSDOM),\n    // restore focus back to the current drop target if any, or the original drag target.\n    if (!e.relatedTarget || !(e.relatedTarget instanceof HTMLElement)) {\n      if (this.currentDropTarget) {\n        this.currentDropTarget.element.focus();\n      } else {\n        this.dragTarget.element.focus();\n      }\n    }\n  }\n\n  onClick(e: MouseEvent) {\n    this.cancelEvent(e);\n    if (isVirtualClick(e) || this.isVirtualClick) {\n      if (e.target === this.dragTarget.element) {\n        this.cancel();\n        return;\n      }\n\n      let dropTarget = this.validDropTargets.find(target => target.element.contains(e.target as HTMLElement));\n      if (dropTarget) {\n        let item = dropItems.get(e.target as HTMLElement);\n        this.setCurrentDropTarget(dropTarget, item);\n        this.drop(item);\n      }\n    }\n  }\n\n  onPointerDown(e: PointerEvent) {\n    // Android Talkback double tap has e.detail = 1 for onClick. Detect the virtual click in onPointerDown before onClick fires\n    // so we can properly perform cancel and drop operations.\n    this.cancelEvent(e);\n    this.isVirtualClick = isVirtualPointerEvent(e);\n  }\n\n  cancelEvent(e: Event) {\n    // Allow focusin and focusout on the drag target so focus ring works properly.\n    if ((e.type === 'focusin' || e.type === 'focusout') && e.target === this.dragTarget?.element) {\n      return;\n    }\n\n    // Allow default for events that might cancel a click event\n    if (!CLICK_EVENTS.includes(e.type)) {\n      e.preventDefault();\n    }\n\n    e.stopPropagation();\n    e.stopImmediatePropagation();\n  }\n\n  updateValidDropTargets() {\n    if (!this.mutationObserver) {\n      return;\n    }\n\n    this.mutationObserver.disconnect();\n    if (this.restoreAriaHidden) {\n      this.restoreAriaHidden();\n    }\n\n    this.validDropTargets = findValidDropTargets(this.dragTarget);\n\n    // Shuffle drop target order based on starting drag target.\n    if (this.validDropTargets.length > 0) {\n      let nearestIndex = this.findNearestDropTarget();\n      this.validDropTargets = [\n        ...this.validDropTargets.slice(nearestIndex),\n        ...this.validDropTargets.slice(0, nearestIndex)\n      ];\n    }\n\n    if (this.currentDropTarget && !this.validDropTargets.includes(this.currentDropTarget)) {\n      this.setCurrentDropTarget(this.validDropTargets[0]);\n    }\n\n    // Find valid drop items within collections\n    let types = getTypes(this.dragTarget.items);\n    let validDropItems = [...dropItems.values()].filter(item => {\n      if (typeof item.getDropOperation === 'function') {\n        return item.getDropOperation(types, this.dragTarget.allowedDropOperations) !== 'cancel';\n      }\n\n      return true;\n    });\n\n    // Filter out drop targets that contain valid items. We don't want to stop hiding elements\n    // other than the drop items that exist inside the collection.\n    let visibleDropTargets = this.validDropTargets.filter(target =>\n      !validDropItems.some(item => target.element.contains(item.element))\n    );\n\n    this.restoreAriaHidden = ariaHideOutside([\n      this.dragTarget.element,\n      ...validDropItems.map(item => item.element),\n      ...visibleDropTargets.map(target => target.element)\n    ]);\n\n    this.mutationObserver.observe(document.body, {subtree: true, attributes: true, attributeFilter: ['aria-hidden']});\n  }\n\n  next() {\n    if (!this.currentDropTarget) {\n      this.setCurrentDropTarget(this.validDropTargets[0]);\n      return;\n    }\n\n    let index = this.validDropTargets.indexOf(this.currentDropTarget);\n    if (index < 0) {\n      this.setCurrentDropTarget(this.validDropTargets[0]);\n      return;\n    }\n\n    // If we've reached the end of the valid drop targets, cycle back to the original drag target.\n    // This lets the user cancel the drag in case they don't have an Escape key (e.g. iPad keyboard case).\n    if (index === this.validDropTargets.length - 1) {\n      if (!this.dragTarget.element.closest('[aria-hidden=\"true\"]')) {\n        this.setCurrentDropTarget(null);\n        this.dragTarget.element.focus();\n      } else {\n        this.setCurrentDropTarget(this.validDropTargets[0]);\n      }\n    } else {\n      this.setCurrentDropTarget(this.validDropTargets[index + 1]);\n    }\n  }\n\n  previous() {\n    if (!this.currentDropTarget) {\n      this.setCurrentDropTarget(this.validDropTargets[this.validDropTargets.length - 1]);\n      return;\n    }\n\n    let index = this.validDropTargets.indexOf(this.currentDropTarget);\n    if (index < 0) {\n      this.setCurrentDropTarget(this.validDropTargets[this.validDropTargets.length - 1]);\n      return;\n    }\n\n    // If we've reached the start of the valid drop targets, cycle back to the original drag target.\n    // This lets the user cancel the drag in case they don't have an Escape key (e.g. iPad keyboard case).\n    if (index === 0) {\n      if (!this.dragTarget.element.closest('[aria-hidden=\"true\"]')) {\n        this.setCurrentDropTarget(null);\n        this.dragTarget.element.focus();\n      } else {\n        this.setCurrentDropTarget(this.validDropTargets[this.validDropTargets.length - 1]);\n      }\n    } else {\n      this.setCurrentDropTarget(this.validDropTargets[index - 1]);\n    }\n  }\n\n  findNearestDropTarget(): number {\n    let dragTargetRect = this.dragTarget.element.getBoundingClientRect();\n\n    let minDistance = Infinity;\n    let nearest = -1;\n    for (let i = 0; i < this.validDropTargets.length; i++) {\n      let dropTarget = this.validDropTargets[i];\n      let rect = dropTarget.element.getBoundingClientRect();\n      let dx = rect.left - dragTargetRect.left;\n      let dy = rect.top - dragTargetRect.top;\n      let dist = (dx * dx) + (dy * dy);\n      if (dist < minDistance) {\n        minDistance = dist;\n        nearest = i;\n      }\n    }\n\n    return nearest;\n  }\n\n  setCurrentDropTarget(dropTarget: DropTarget, item?: DroppableItem) {\n    if (dropTarget !== this.currentDropTarget) {\n      if (this.currentDropTarget && typeof this.currentDropTarget.onDropExit === 'function') {\n        let rect = this.currentDropTarget.element.getBoundingClientRect();\n        this.currentDropTarget.onDropExit({\n          type: 'dropexit',\n          x: rect.left + (rect.width / 2),\n          y: rect.top + (rect.height / 2)\n        });\n      }\n\n      this.currentDropTarget = dropTarget;\n\n      if (dropTarget) {\n        if (typeof dropTarget.onDropEnter === 'function') {\n          let rect = dropTarget.element.getBoundingClientRect();\n          dropTarget.onDropEnter({\n            type: 'dropenter',\n            x: rect.left + (rect.width / 2),\n            y: rect.top + (rect.height / 2)\n          }, this.dragTarget);\n        }\n\n        if (!item) {\n          dropTarget?.element.focus();\n        }\n      }\n    }\n\n    if (item !== this.currentDropItem) {\n      if (item && typeof this.currentDropTarget.onDropTargetEnter === 'function') {\n        this.currentDropTarget.onDropTargetEnter(item?.target);\n      }\n\n      item?.element.focus();\n      this.currentDropItem = item;\n\n      // Announce first drop target after drag start announcement finishes.\n      // Otherwise, it will never get announced because drag start announcement is assertive.\n      if (!this.initialFocused) {\n        announce(item?.element.getAttribute('aria-label'), 'polite');\n        this.initialFocused = true;\n      }\n    }\n  }\n\n  end() {\n    this.teardown();\n    endDragging();\n\n    if (typeof this.dragTarget.onDragEnd === 'function') {\n      let target = this.currentDropTarget && this.dropOperation !== 'cancel' ? this.currentDropTarget : this.dragTarget;\n      let rect = target.element.getBoundingClientRect();\n      this.dragTarget.onDragEnd({\n        type: 'dragend',\n        x: rect.x + (rect.width / 2),\n        y: rect.y + (rect.height / 2),\n        dropOperation: this.dropOperation || 'cancel'\n      });\n    }\n\n    // Blur and re-focus the drop target so that the focus ring appears.\n    if (this.currentDropTarget) {\n      // Since we cancel all focus events in drag sessions, refire blur to make sure state gets updated so drag target doesn't think it's still focused\n      // i.e. When you from one list to another during a drag session, we need the blur to fire on the first list after the drag.\n      if (!this.dragTarget.element.contains(this.currentDropTarget.element)) {\n        this.dragTarget.element.dispatchEvent(new FocusEvent('blur'));\n        this.dragTarget.element.dispatchEvent(new FocusEvent('focusout', {bubbles: true}));\n      }\n      // Re-focus the focusedKey upon reorder. This requires a React rerender between blurring and focusing.\n      flushSync(() => {\n        this.currentDropTarget.element.blur();\n      });\n      this.currentDropTarget.element.focus();\n    }\n\n    this.setCurrentDropTarget(null);\n  }\n\n  cancel() {\n    this.setCurrentDropTarget(null);\n    this.end();\n    if (!this.dragTarget.element.closest('[aria-hidden=\"true\"]')) {\n      this.dragTarget.element.focus();\n    }\n\n    announce(this.stringFormatter.format('dropCanceled'));\n  }\n\n  drop(item?: DroppableItem) {\n    if (!this.currentDropTarget) {\n      this.cancel();\n      return;\n    }\n\n    if (typeof item?.getDropOperation === 'function') {\n      let types = getTypes(this.dragTarget.items);\n      this.dropOperation = item.getDropOperation(types, this.dragTarget.allowedDropOperations);\n    } else if (typeof this.currentDropTarget.getDropOperation === 'function') {\n      let types = getTypes(this.dragTarget.items);\n      this.dropOperation = this.currentDropTarget.getDropOperation(types, this.dragTarget.allowedDropOperations);\n    } else {\n      // TODO: show menu ??\n      this.dropOperation = this.dragTarget.allowedDropOperations[0];\n    }\n\n    if (typeof this.currentDropTarget.onDrop === 'function') {\n      let items: DropItem[] = this.dragTarget.items.map(item => ({\n        kind: 'text',\n        types: new Set(Object.keys(item)),\n        getText: (type: string) => Promise.resolve(item[type])\n      }));\n\n      let rect = this.currentDropTarget.element.getBoundingClientRect();\n      this.currentDropTarget.onDrop({\n        type: 'drop',\n        x: rect.left + (rect.width / 2),\n        y: rect.top + (rect.height / 2),\n        items,\n        dropOperation: this.dropOperation\n      }, item?.target);\n    }\n\n    this.end();\n    announce(this.stringFormatter.format('dropComplete'));\n  }\n\n  activate() {\n    if (this.currentDropTarget && typeof this.currentDropTarget.onDropActivate === 'function') {\n      let rect = this.currentDropTarget.element.getBoundingClientRect();\n      this.currentDropTarget.onDropActivate({\n        type: 'dropactivate',\n        x: rect.left + (rect.width / 2),\n        y: rect.top + (rect.height / 2)\n      });\n    }\n  }\n}\n\nfunction findValidDropTargets(options: DragTarget) {\n  let types = getTypes(options.items);\n  return [...dropTargets.values()].filter(target => {\n    if (target.element.closest('[aria-hidden=\"true\"]')) {\n      return false;\n    }\n\n    if (typeof target.getDropOperation === 'function') {\n      return target.getDropOperation(types, options.allowedDropOperations) !== 'cancel';\n    }\n\n    return true;\n  });\n}\n","const _temp0 = require(\"../intl/ar-AE.json\");\nconst _temp1 = require(\"../intl/bg-BG.json\");\nconst _temp2 = require(\"../intl/cs-CZ.json\");\nconst _temp3 = require(\"../intl/da-DK.json\");\nconst _temp4 = require(\"../intl/de-DE.json\");\nconst _temp5 = require(\"../intl/el-GR.json\");\nconst _temp6 = require(\"../intl/en-US.json\");\nconst _temp7 = require(\"../intl/es-ES.json\");\nconst _temp8 = require(\"../intl/et-EE.json\");\nconst _temp9 = require(\"../intl/fi-FI.json\");\nconst _temp10 = require(\"../intl/fr-FR.json\");\nconst _temp11 = require(\"../intl/he-IL.json\");\nconst _temp12 = require(\"../intl/hr-HR.json\");\nconst _temp13 = require(\"../intl/hu-HU.json\");\nconst _temp14 = require(\"../intl/it-IT.json\");\nconst _temp15 = require(\"../intl/ja-JP.json\");\nconst _temp16 = require(\"../intl/ko-KR.json\");\nconst _temp17 = require(\"../intl/lt-LT.json\");\nconst _temp18 = require(\"../intl/lv-LV.json\");\nconst _temp19 = require(\"../intl/nb-NO.json\");\nconst _temp20 = require(\"../intl/nl-NL.json\");\nconst _temp21 = require(\"../intl/pl-PL.json\");\nconst _temp22 = require(\"../intl/pt-BR.json\");\nconst _temp23 = require(\"../intl/pt-PT.json\");\nconst _temp24 = require(\"../intl/ro-RO.json\");\nconst _temp25 = require(\"../intl/ru-RU.json\");\nconst _temp26 = require(\"../intl/sk-SK.json\");\nconst _temp27 = require(\"../intl/sl-SI.json\");\nconst _temp28 = require(\"../intl/sr-SP.json\");\nconst _temp29 = require(\"../intl/sv-SE.json\");\nconst _temp30 = require(\"../intl/tr-TR.json\");\nconst _temp31 = require(\"../intl/uk-UA.json\");\nconst _temp32 = require(\"../intl/zh-CN.json\");\nconst _temp33 = require(\"../intl/zh-TW.json\");\nmodule.exports = {\n  \"ar-AE\": _temp0,\n  \"bg-BG\": _temp1,\n  \"cs-CZ\": _temp2,\n  \"da-DK\": _temp3,\n  \"de-DE\": _temp4,\n  \"el-GR\": _temp5,\n  \"en-US\": _temp6,\n  \"es-ES\": _temp7,\n  \"et-EE\": _temp8,\n  \"fi-FI\": _temp9,\n  \"fr-FR\": _temp10,\n  \"he-IL\": _temp11,\n  \"hr-HR\": _temp12,\n  \"hu-HU\": _temp13,\n  \"it-IT\": _temp14,\n  \"ja-JP\": _temp15,\n  \"ko-KR\": _temp16,\n  \"lt-LT\": _temp17,\n  \"lv-LV\": _temp18,\n  \"nb-NO\": _temp19,\n  \"nl-NL\": _temp20,\n  \"pl-PL\": _temp21,\n  \"pt-BR\": _temp22,\n  \"pt-PT\": _temp23,\n  \"ro-RO\": _temp24,\n  \"ru-RU\": _temp25,\n  \"sk-SK\": _temp26,\n  \"sl-SI\": _temp27,\n  \"sr-SP\": _temp28,\n  \"sv-SE\": _temp29,\n  \"tr-TR\": _temp30,\n  \"uk-UA\": _temp31,\n  \"zh-CN\": _temp32,\n  \"zh-TW\": _temp33\n}","/*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */\n\nimport {AriaButtonProps} from '@react-types/button';\nimport {DragEvent, HTMLAttributes, RefObject,  useRef, useState} from 'react';\nimport * as DragManager from './DragManager';\nimport {DragTypes, globalAllowedDropOperations, globalDndState, readFromDataTransfer, setGlobalDnDState, setGlobalDropEffect} from './utils';\nimport {DROP_EFFECT_TO_DROP_OPERATION, DROP_OPERATION, DROP_OPERATION_ALLOWED, DROP_OPERATION_TO_DROP_EFFECT} from './constants';\nimport {DropActivateEvent, DropEnterEvent, DropEvent, DropExitEvent, DropMoveEvent, DropOperation, DragTypes as IDragTypes} from '@react-types/shared';\nimport {isIPad, isMac, useEffectEvent, useLayoutEffect} from '@react-aria/utils';\nimport {useVirtualDrop} from './useVirtualDrop';\n\nexport interface DropOptions {\n  /** A ref for the droppable element. */\n  ref: RefObject<HTMLElement>,\n  /**\n   * A function returning the drop operation to be performed when items matching the given types are dropped\n   * on the drop target.\n   */\n  getDropOperation?: (types: IDragTypes, allowedOperations: DropOperation[]) => DropOperation,\n  /** A function that returns the drop operation for a specific point within the target. */\n  getDropOperationForPoint?: (types: IDragTypes, allowedOperations: DropOperation[], x: number, y: number) => DropOperation,\n  /** Handler that is called when a valid drag enters the drop target. */\n  onDropEnter?: (e: DropEnterEvent) => void,\n  /** Handler that is called when a valid drag is moved within the drop target. */\n  onDropMove?: (e: DropMoveEvent) => void,\n  /**\n   * Handler that is called after a valid drag is held over the drop target for a period of time.\n   * This typically opens the item so that the user can drop within it.\n   * @private\n   */\n  onDropActivate?: (e: DropActivateEvent) => void,\n  /** Handler that is called when a valid drag exits the drop target. */\n  onDropExit?: (e: DropExitEvent) => void,\n  /** Handler that is called when a valid drag is dropped on the drop target. */\n  onDrop?: (e: DropEvent) => void,\n  /**\n   * Whether the item has an explicit focusable drop affordance to initiate accessible drag and drop mode.\n   * If true, the dropProps will omit these event handlers, and they will be applied to dropButtonProps instead.\n   */\n  hasDropButton?: boolean\n}\n\nexport interface DropResult {\n  /** Props for the droppable element. */\n  dropProps: HTMLAttributes<HTMLElement>,\n  /** Whether the drop target is currently focused or hovered. */\n  isDropTarget: boolean,\n  /** Props for the explicit drop button affordance, if any. */\n  dropButtonProps?: AriaButtonProps\n  \n}\n\nconst DROP_ACTIVATE_TIMEOUT = 800;\n\n/**\n * Handles drop interactions for an element, with support for traditional mouse and touch\n * based drag and drop, in addition to full parity for keyboard and screen reader users.\n */\nexport function useDrop(options: DropOptions): DropResult {\n  let {hasDropButton} = options;\n  let [isDropTarget, setDropTarget] = useState(false);\n  let state = useRef({\n    x: 0,\n    y: 0,\n    dragOverElements: new Set<Element>(),\n    dropEffect: 'none' as DataTransfer['dropEffect'],\n    allowedOperations: DROP_OPERATION.all,\n    dropActivateTimer: null\n  }).current;\n\n  let fireDropEnter = (e: DragEvent) => {\n    setDropTarget(true);\n\n    if (typeof options.onDropEnter === 'function') {\n      let rect = (e.currentTarget as HTMLElement).getBoundingClientRect();\n      options.onDropEnter({\n        type: 'dropenter',\n        x: e.clientX - rect.x,\n        y: e.clientY - rect.y\n      });\n    }\n  };\n\n  let fireDropExit = (e: DragEvent) => {\n    setDropTarget(false);\n\n    if (typeof options.onDropExit === 'function') {\n      let rect = (e.currentTarget as HTMLElement).getBoundingClientRect();\n      options.onDropExit({\n        type: 'dropexit',\n        x: e.clientX - rect.x,\n        y: e.clientY - rect.y\n      });\n    }\n  };\n\n  let onDragOver = (e: DragEvent) => {\n    e.preventDefault();\n    e.stopPropagation();\n\n    let allowedOperations = getAllowedOperations(e);\n    if (e.clientX === state.x && e.clientY === state.y && allowedOperations === state.allowedOperations) {\n      e.dataTransfer.dropEffect = state.dropEffect;\n      return;\n    }\n\n    state.x = e.clientX;\n    state.y = e.clientY;\n\n    let prevDropEffect = state.dropEffect;\n\n    // Update drop effect if allowed drop operations changed (e.g. user pressed modifier key).\n    if (allowedOperations !== state.allowedOperations) {\n      let allowedOps = allowedOperationsToArray(allowedOperations);\n      let dropOperation = allowedOps[0];\n      if (typeof options.getDropOperation === 'function') {\n        let types = new DragTypes(e.dataTransfer);\n        dropOperation = getDropOperation(allowedOperations, options.getDropOperation(types, allowedOps));\n      }\n      state.dropEffect = DROP_OPERATION_TO_DROP_EFFECT[dropOperation] || 'none';\n    }\n\n    if (typeof options.getDropOperationForPoint === 'function') {\n      let types = new DragTypes(e.dataTransfer);\n      let rect = (e.currentTarget as HTMLElement).getBoundingClientRect();\n      let dropOperation = getDropOperation(\n        allowedOperations,\n        options.getDropOperationForPoint(types, allowedOperationsToArray(allowedOperations), state.x - rect.x, state.y - rect.y)\n      );\n      state.dropEffect = DROP_OPERATION_TO_DROP_EFFECT[dropOperation] || 'none';\n    }\n\n    state.allowedOperations = allowedOperations;\n    e.dataTransfer.dropEffect = state.dropEffect;\n\n    // If the drop operation changes, update state and fire events appropriately.\n    if (state.dropEffect === 'none' && prevDropEffect !== 'none') {\n      fireDropExit(e);\n    } else if (state.dropEffect !== 'none' && prevDropEffect === 'none') {\n      fireDropEnter(e);\n    }\n\n    if (typeof options.onDropMove === 'function' && state.dropEffect !== 'none') {\n      let rect = (e.currentTarget as HTMLElement).getBoundingClientRect();\n      options.onDropMove({\n        type: 'dropmove',\n        x: state.x - rect.x,\n        y: state.y - rect.y\n      });\n    }\n\n    clearTimeout(state.dropActivateTimer);\n\n    if (typeof options.onDropActivate === 'function' && state.dropEffect !== 'none') {\n      let rect = (e.currentTarget as HTMLElement).getBoundingClientRect();\n      state.dropActivateTimer = setTimeout(() => {\n        options.onDropActivate({\n          type: 'dropactivate',\n          x: state.x - rect.x,\n          y: state.y - rect.y\n        });\n      }, DROP_ACTIVATE_TIMEOUT);\n    }\n  };\n\n  let onDragEnter = (e: DragEvent) => {\n    e.preventDefault();\n    e.stopPropagation();\n    state.dragOverElements.add(e.target as Element);\n    if (state.dragOverElements.size > 1) {\n      return;\n    }\n\n    let allowedOperationsBits = getAllowedOperations(e);\n    let allowedOperations = allowedOperationsToArray(allowedOperationsBits);\n    let dropOperation = allowedOperations[0];\n\n    if (typeof options.getDropOperation === 'function') {\n      let types = new DragTypes(e.dataTransfer);\n      dropOperation = getDropOperation(allowedOperationsBits, options.getDropOperation(types, allowedOperations));\n    }\n\n    if (typeof options.getDropOperationForPoint === 'function') {\n      let types = new DragTypes(e.dataTransfer);\n      let rect = (e.currentTarget as HTMLElement).getBoundingClientRect();\n      dropOperation = getDropOperation(\n        allowedOperationsBits,\n        options.getDropOperationForPoint(types, allowedOperations, e.clientX - rect.x, e.clientY - rect.y)\n      );\n    }\n\n    state.x = e.clientX;\n    state.y = e.clientY;\n    state.allowedOperations = allowedOperationsBits;\n    state.dropEffect = DROP_OPERATION_TO_DROP_EFFECT[dropOperation] || 'none';\n    e.dataTransfer.dropEffect = state.dropEffect;\n\n    if (dropOperation !== 'cancel') {\n      fireDropEnter(e);\n    }\n  };\n\n  let onDragLeave = (e: DragEvent) => {\n    e.preventDefault();\n    e.stopPropagation();\n\n    // We would use e.relatedTarget to detect if the drag is still inside the drop target,\n    // but it is always null in WebKit. https://bugs.webkit.org/show_bug.cgi?id=66547\n    // Instead, we track all of the targets of dragenter events in a set, and remove them\n    // in dragleave. When the set becomes empty, we've left the drop target completely.\n    // We must also remove any elements that are no longer in the DOM, because dragleave\n    // events will never be fired for these. This can happen, for example, with drop\n    // indicators between items, which disappear when the drop target changes.\n\n    state.dragOverElements.delete(e.target as Element);\n    for (let element of state.dragOverElements) {\n      if (!e.currentTarget.contains(element)) {\n        state.dragOverElements.delete(element);\n      }\n    }\n\n    if (state.dragOverElements.size > 0) {\n      return;\n    }\n\n    if (state.dropEffect !== 'none') {\n      fireDropExit(e);\n    }\n\n    clearTimeout(state.dropActivateTimer);\n  };\n\n  let onDrop = (e: DragEvent) => {\n    e.preventDefault();\n    e.stopPropagation();\n    // Track drop effect in global state for Chrome Android. https://bugs.chromium.org/p/chromium/issues/detail?id=1353951\n    // Android onDragEnd always returns \"none\" as its drop effect.\n    setGlobalDropEffect(state.dropEffect);\n\n    if (typeof options.onDrop === 'function') {\n      let dropOperation = DROP_EFFECT_TO_DROP_OPERATION[state.dropEffect];\n      let items = readFromDataTransfer(e.dataTransfer);\n\n      let rect = (e.currentTarget as HTMLElement).getBoundingClientRect();\n      let event: DropEvent = {\n        type: 'drop',\n        x: e.clientX - rect.x,\n        y: e.clientY - rect.y,\n        items,\n        dropOperation\n      };\n\n      options.onDrop(event);\n    }\n\n    let dndStateSnapshot = {...globalDndState};\n    state.dragOverElements.clear();\n    fireDropExit(e);\n    clearTimeout(state.dropActivateTimer);\n    // If there wasn't a collection being tracked as a dragged collection, then we are in a case where a non RSP drag is dropped on a\n    // RSP collection and thus we don't need to preserve the global drop effect\n    if (dndStateSnapshot.draggingCollectionRef == null) {\n      setGlobalDropEffect(undefined);\n    } else {\n      // Otherwise we need to preserve the global dnd state for onDragEnd's isInternal check.\n      // At the moment fireDropExit may clear dropCollectionRef (i.e. useDroppableCollection's provided onDropExit, required to clear dropCollectionRef when exiting a valid drop target)\n      setGlobalDnDState(dndStateSnapshot);\n    }\n  };\n\n  let onDropEnter = useEffectEvent((e: DropEnterEvent) => {\n    if (typeof options.onDropEnter === 'function') {\n      options.onDropEnter(e);\n    }\n  });\n\n  let onDropExit = useEffectEvent((e: DropExitEvent) => {\n    if (typeof options.onDropExit === 'function') {\n      options.onDropExit(e);\n    }\n  });\n\n  let onDropActivate = useEffectEvent((e: DropActivateEvent) => {\n    if (typeof options.onDropActivate === 'function') {\n      options.onDropActivate(e);\n    }\n  });\n\n  let onKeyboardDrop = useEffectEvent((e: DropEvent) => {\n    if (typeof options.onDrop === 'function') {\n      options.onDrop(e);\n    }\n  });\n\n  let getDropOperationKeyboard = useEffectEvent((types: IDragTypes, allowedOperations: DropOperation[]) => {\n    if (options.getDropOperation) {\n      return options.getDropOperation(types, allowedOperations);\n    }\n\n    return allowedOperations[0];\n  });\n\n  let {ref} = options;\n  useLayoutEffect(() => DragManager.registerDropTarget({\n    element: ref.current,\n    getDropOperation: getDropOperationKeyboard,\n    onDropEnter(e) {\n      setDropTarget(true);\n      onDropEnter(e);\n    },\n    onDropExit(e) {\n      setDropTarget(false);\n      onDropExit(e);\n    },\n    onDrop: onKeyboardDrop,\n    onDropActivate\n  }), [ref, getDropOperationKeyboard, onDropEnter, onDropExit, onKeyboardDrop, onDropActivate]);\n\n  let {dropProps} = useVirtualDrop();\n  \n  return {\n    dropProps: {\n      ...(!hasDropButton && dropProps),\n      onDragEnter,\n      onDragOver,\n      onDragLeave,\n      onDrop\n    },\n    dropButtonProps: {...(hasDropButton && dropProps)},\n    isDropTarget\n  };\n}\n\nfunction getAllowedOperations(e: DragEvent) {\n  let allowedOperations = DROP_OPERATION_ALLOWED[e.dataTransfer.effectAllowed];\n\n  // WebKit always sets effectAllowed to \"copyMove\" on macOS, and \"all\" on iOS, regardless of what was\n  // set during the dragstart event: https://bugs.webkit.org/show_bug.cgi?id=178058\n  //\n  // Android Chrome also sets effectAllowed to \"copyMove\" in all cases: https://bugs.chromium.org/p/chromium/issues/detail?id=1359182\n  //\n  // If the drag started within the page, we can use a global variable to get the real allowed operations.\n  // This needs to be intersected with the actual effectAllowed, which may have been filtered based on modifier keys.\n  // Unfortunately, this means that link operations do not work at all in Safari.\n  if (globalAllowedDropOperations) {\n    allowedOperations &= globalAllowedDropOperations;\n  }\n\n  // Chrome and Safari on macOS will automatically filter effectAllowed when pressing modifier keys,\n  // allowing the user to switch between move, link, and copy operations. Firefox on macOS and all\n  // Windows browsers do not do this, so do it ourselves instead. The exact keys are platform dependent.\n  // https://ux.stackexchange.com/questions/83748/what-are-the-most-common-modifier-keys-for-dragging-objects-with-a-mouse\n  //\n  // Note that none of these modifiers are ever set in WebKit due to a bug: https://bugs.webkit.org/show_bug.cgi?id=77465\n  // However, Safari does update effectAllowed correctly, so we can just rely on that.\n  let allowedModifiers = DROP_OPERATION.none;\n  if (isMac()) {\n    if (e.altKey) {\n      allowedModifiers |= DROP_OPERATION.copy;\n    }\n\n    // Chrome and Safari both use the Control key for link, even though Finder uses Command + Option.\n    // iPadOS doesn't support link operations and will not fire the drop event at all if dropEffect is set to link.\n    // https://bugs.webkit.org/show_bug.cgi?id=244701\n    if (e.ctrlKey && !isIPad()) {\n      allowedModifiers |= DROP_OPERATION.link;\n    }\n\n    if (e.metaKey) {\n      allowedModifiers |= DROP_OPERATION.move;\n    }\n  } else {\n    if (e.altKey) {\n      allowedModifiers |= DROP_OPERATION.link;\n    }\n\n    if (e.shiftKey) {\n      allowedModifiers |= DROP_OPERATION.move;\n    }\n\n    if (e.ctrlKey) {\n      allowedModifiers |= DROP_OPERATION.copy;\n    }\n  }\n\n  if (allowedModifiers) {\n    return allowedOperations & allowedModifiers;\n  }\n\n  return allowedOperations;\n}\n\nfunction allowedOperationsToArray(allowedOperationsBits: DROP_OPERATION) {\n  let allowedOperations = [];\n  if (allowedOperationsBits & DROP_OPERATION.move) {\n    allowedOperations.push('move');\n  }\n\n  if (allowedOperationsBits & DROP_OPERATION.copy) {\n    allowedOperations.push('copy');\n  }\n\n  if (allowedOperationsBits & DROP_OPERATION.link) {\n    allowedOperations.push('link');\n  }\n\n  return allowedOperations;\n}\n\nfunction getDropOperation(allowedOperations: DROP_OPERATION, operation: DropOperation) {\n  let op = DROP_OPERATION[operation];\n  return allowedOperations & op ? operation : 'cancel';\n}\n","/*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */\n\nimport {DOMAttributes} from '@react-types/shared';\nimport * as DragManager from './DragManager';\n// @ts-ignore\nimport intlMessages from '../intl/*.json';\nimport {useDescription} from '@react-aria/utils';\nimport {useDragModality} from './utils';\nimport {useLocalizedStringFormatter} from '@react-aria/i18n';\n\ninterface VirtualDropResult {\n  dropProps: DOMAttributes\n}\n\nconst MESSAGES = {\n  keyboard: 'dropDescriptionKeyboard',\n  touch: 'dropDescriptionTouch',\n  virtual: 'dropDescriptionVirtual'\n};\n\nexport function useVirtualDrop(): VirtualDropResult {\n  let stringFormatter = useLocalizedStringFormatter(intlMessages, '@react-aria/dnd');\n  let modality = useDragModality();\n  let dragSession = DragManager.useDragSession();\n  let descriptionProps = useDescription(dragSession ? stringFormatter.format(MESSAGES[modality]) : '');\n\n  return {\n    dropProps: {\n      ...descriptionProps,\n      // Mobile Safari does not properly bubble click events on elements except links or inputs\n      // unless there is an onclick handler bound directly to the element itself. By adding this\n      // handler, React will take care of adding that for us, and we are able to handle document\n      // level click events in the DragManager.\n      // See https://www.quirksmode.org/blog/archives/2010/09/click_event_del.html\n      onClick: () => {}\n    }\n  };\n}\n","/*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */\n\nimport {\n  clearGlobalDnDState,\n  DIRECTORY_DRAG_TYPE,\n  droppableCollectionMap,\n  getTypes,\n  globalDndState,\n  isInternalDropOperation,\n  setDropCollectionRef\n} from './utils';\nimport {\n  Collection,\n  DropEvent,\n  DropOperation,\n  DroppableCollectionDropEvent,\n  DroppableCollectionProps,\n  DropPosition,\n  DropTarget,\n  DropTargetDelegate,\n  Key,\n  KeyboardDelegate,\n  Node\n} from '@react-types/shared';\nimport * as DragManager from './DragManager';\nimport {DroppableCollectionState} from '@react-stately/dnd';\nimport {HTMLAttributes, RefObject, useCallback, useEffect, useRef} from 'react';\nimport {mergeProps, useId, useLayoutEffect} from '@react-aria/utils';\nimport {setInteractionModality} from '@react-aria/interactions';\nimport {useAutoScroll} from './useAutoScroll';\nimport {useDrop} from './useDrop';\nimport {useLocale} from '@react-aria/i18n';\n\nexport interface DroppableCollectionOptions extends DroppableCollectionProps {\n  /** A delegate object that implements behavior for keyboard focus movement. */\n  keyboardDelegate: KeyboardDelegate,\n  /** A delegate object that provides drop targets for pointer coordinates within the collection. */\n  dropTargetDelegate: DropTargetDelegate\n}\n\nexport interface DroppableCollectionResult {\n  /** Props for the collection element. */\n  collectionProps: HTMLAttributes<HTMLElement>\n}\n\ninterface DroppingState {\n  collection: Collection<Node<unknown>>,\n  focusedKey: Key,\n  selectedKeys: Set<Key>,\n  timeout: ReturnType<typeof setTimeout>\n}\n\nconst DROP_POSITIONS: DropPosition[] = ['before', 'on', 'after'];\nconst DROP_POSITIONS_RTL: DropPosition[] = ['after', 'on', 'before'];\n\n/**\n * Handles drop interactions for a collection component, with support for traditional mouse and touch\n * based drag and drop, in addition to full parity for keyboard and screen reader users.\n */\nexport function useDroppableCollection(props: DroppableCollectionOptions, state: DroppableCollectionState, ref: RefObject<HTMLElement>): DroppableCollectionResult {\n  let localState = useRef({\n    props,\n    state,\n    nextTarget: null,\n    dropOperation: null\n  }).current;\n  localState.props = props;\n  localState.state = state;\n\n  let defaultOnDrop = useCallback(async (e: DroppableCollectionDropEvent) => {\n    let {\n      onInsert,\n      onRootDrop,\n      onItemDrop,\n      onReorder,\n      acceptedDragTypes = 'all',\n      shouldAcceptItemDrop\n    } = localState.props;\n\n    let {draggingKeys} = globalDndState;\n    let isInternal = isInternalDropOperation(ref);\n    let {\n      target,\n      dropOperation,\n      items\n    } = e;\n\n    let filteredItems = items;\n    if (acceptedDragTypes !== 'all' || shouldAcceptItemDrop) {\n      filteredItems = items.filter(item => {\n        let itemTypes: Set<string | symbol>;\n        if (item.kind === 'directory') {\n          itemTypes = new Set([DIRECTORY_DRAG_TYPE]);\n        } else {\n          itemTypes = item.kind === 'file' ? new Set([item.type]) : item.types;\n        }\n\n        if (acceptedDragTypes === 'all' || acceptedDragTypes.some(type => itemTypes.has(type))) {\n          // If we are performing a on item drop, check if the item in question accepts the dropped item since the item may have heavier restrictions\n          // than the droppable collection itself\n          if (target.type === 'item' && target.dropPosition === 'on' && shouldAcceptItemDrop) {\n            return shouldAcceptItemDrop(target, itemTypes);\n          }\n          return true;\n        }\n\n        return false;\n      });\n    }\n\n    if (filteredItems.length > 0) {\n      if (target.type === 'root' && onRootDrop) {\n        await onRootDrop({items: filteredItems, dropOperation});\n      }\n\n      if (target.type === 'item') {\n        if (target.dropPosition === 'on' && onItemDrop) {\n          await onItemDrop({items: filteredItems, dropOperation, isInternal, target});\n        }\n\n        if (target.dropPosition !== 'on') {\n          if (!isInternal && onInsert) {\n            await onInsert({items: filteredItems, dropOperation, target});\n          }\n\n          if (isInternal && onReorder) {\n            await onReorder({keys: draggingKeys, dropOperation, target});\n          }\n        }\n      }\n    }\n  }, [localState, ref]);\n\n  let autoScroll = useAutoScroll(ref);\n  let {dropProps} = useDrop({\n    ref,\n    onDropEnter() {\n      state.setTarget(localState.nextTarget);\n    },\n    onDropMove(e) {\n      state.setTarget(localState.nextTarget);\n      autoScroll.move(e.x, e.y);\n    },\n    getDropOperationForPoint(types, allowedOperations, x, y) {\n      let {draggingKeys, dropCollectionRef} = globalDndState;\n      let isInternal = isInternalDropOperation(ref);\n      let isValidDropTarget = (target) => state.getDropOperation({target, types, allowedOperations, isInternal, draggingKeys}) !== 'cancel';\n      let target = props.dropTargetDelegate.getDropTargetFromPoint(x, y, isValidDropTarget);\n      if (!target) {\n        localState.dropOperation = 'cancel';\n        localState.nextTarget = null;\n        return 'cancel';\n      }\n\n      localState.dropOperation = state.getDropOperation({target, types, allowedOperations, isInternal, draggingKeys});\n\n      // If the target doesn't accept the drop, see if the root accepts it instead.\n      if (localState.dropOperation === 'cancel') {\n        let rootTarget: DropTarget = {type: 'root'};\n        let dropOperation = state.getDropOperation({target: rootTarget, types, allowedOperations, isInternal, draggingKeys});\n        if (dropOperation !== 'cancel') {\n          target = rootTarget;\n          localState.dropOperation = dropOperation;\n        }\n      }\n\n      // Only set dropCollectionRef if there is a valid drop target since we cleanup dropCollectionRef in onDropExit\n      // which only runs when leaving a valid drop target or if the dropEffect become none (mouse dnd only).\n      if (target && localState.dropOperation !== 'cancel' && ref?.current !== dropCollectionRef?.current) {\n        setDropCollectionRef(ref);\n      }\n      localState.nextTarget = localState.dropOperation === 'cancel' ? null : target;\n      return localState.dropOperation;\n    },\n    onDropExit() {\n      setDropCollectionRef(undefined);\n      state.setTarget(null);\n      autoScroll.stop();\n    },\n    onDropActivate(e) {\n      if (state.target?.type === 'item' && state.target?.dropPosition === 'on' && typeof props.onDropActivate === 'function') {\n        props.onDropActivate({\n          type: 'dropactivate',\n          x: e.x, // todo\n          y: e.y,\n          target: state.target\n        });\n      }\n    },\n    onDrop(e) {\n      setDropCollectionRef(ref);\n      if (state.target) {\n        onDrop(e, state.target);\n      }\n\n      // If there wasn't a collection being tracked as a dragged collection, then we are in a case where a non RSP drag is dropped on a\n      // RSP collection and thus we don't need to preserve the global DnD state for onDragEnd\n      let {draggingCollectionRef} = globalDndState;\n      if (draggingCollectionRef == null) {\n        clearGlobalDnDState();\n      }\n    }\n  });\n\n  let droppingState = useRef<DroppingState>(null);\n  let onDrop = useCallback((e: DropEvent, target: DropTarget) => {\n    let {state} = localState;\n\n    // Focus the collection.\n    state.selectionManager.setFocused(true);\n\n    // Save some state of the collection/selection before the drop occurs so we can compare later.\n    let focusedKey = state.selectionManager.focusedKey;\n\n    // If parent key was dragged, we want to use it instead (i.e. focus row instead of cell after dropping)\n    if (globalDndState.draggingKeys.has(state.collection.getItem(focusedKey)?.parentKey)) {\n      focusedKey = state.collection.getItem(focusedKey).parentKey;\n      state.selectionManager.setFocusedKey(focusedKey);\n    }\n\n    droppingState.current = {\n      timeout: null,\n      focusedKey,\n      collection: state.collection,\n      selectedKeys: state.selectionManager.selectedKeys\n    };\n\n    let onDropFn = localState.props.onDrop || defaultOnDrop;\n    onDropFn({\n      type: 'drop',\n      x: e.x, // todo\n      y: e.y,\n      target,\n      items: e.items,\n      dropOperation: e.dropOperation\n    });\n\n    // Wait for a short time period after the onDrop is called to allow the data to be read asynchronously\n    // and for React to re-render. If an insert occurs during this time, it will be selected/focused below.\n    // If items are not \"immediately\" inserted by the onDrop handler, the application will need to handle\n    // selecting and focusing those items themselves.\n    droppingState.current.timeout = setTimeout(() => {\n      // If focus didn't move already (e.g. due to an insert), and the user dropped on an item,\n      // focus that item and show the focus ring to give the user feedback that the drop occurred.\n      // Also show the focus ring if the focused key is not selected, e.g. in case of a reorder.\n      let {state} = localState;\n\n      if (target.type === 'item' && target.dropPosition === 'on' && state.collection.getItem(target.key) != null) {\n        state.selectionManager.setFocusedKey(target.key);\n        state.selectionManager.setFocused(true);\n        setInteractionModality('keyboard');\n      } else if (!state.selectionManager.isSelected(focusedKey)) {\n        setInteractionModality('keyboard');\n      }\n\n      droppingState.current = null;\n    }, 50);\n  }, [localState, defaultOnDrop]);\n\n  // eslint-disable-next-line arrow-body-style\n  useEffect(() => {\n    return () => {\n      if (droppingState.current) {\n        clearTimeout(droppingState.current.timeout);\n      }\n    };\n  }, []);\n\n  useLayoutEffect(() => {\n    // If an insert occurs during a drop, we want to immediately select these items to give\n    // feedback to the user that a drop occurred. Only do this if the selection didn't change\n    // since the drop started so we don't override if the user or application did something.\n    if (\n      droppingState.current &&\n      state.selectionManager.isFocused &&\n      state.collection.size > droppingState.current.collection.size &&\n      state.selectionManager.isSelectionEqual(droppingState.current.selectedKeys)\n    ) {\n      let newKeys = new Set<Key>();\n      for (let key of state.collection.getKeys()) {\n        if (!droppingState.current.collection.getItem(key)) {\n          newKeys.add(key);\n        }\n      }\n\n      state.selectionManager.setSelectedKeys(newKeys);\n\n      // If the focused item didn't change since the drop occurred, also focus the first\n      // inserted item. If selection is disabled, then also show the focus ring so there\n      // is some indication that items were added.\n      if (state.selectionManager.focusedKey === droppingState.current.focusedKey) {\n        let first = newKeys.keys().next().value;\n        let item = state.collection.getItem(first);\n\n        // If this is a cell, focus the parent row.\n        if (item?.type === 'cell') {\n          first = item.parentKey;\n        }\n\n        state.selectionManager.setFocusedKey(first);\n\n        if (state.selectionManager.selectionMode === 'none') {\n          setInteractionModality('keyboard');\n        }\n      }\n\n      droppingState.current = null;\n    }\n  });\n\n  let {direction} = useLocale();\n  useEffect(() => {\n    let getNextTarget = (target: DropTarget, wrap = true, horizontal = false): DropTarget => {\n      if (!target) {\n        return {\n          type: 'root'\n        };\n      }\n\n      let {keyboardDelegate} = localState.props;\n      let nextKey: Key;\n      if (target?.type === 'item') {\n        nextKey = horizontal ? keyboardDelegate.getKeyRightOf(target.key) : keyboardDelegate.getKeyBelow(target.key);\n      } else {\n        nextKey = horizontal && direction === 'rtl' ? keyboardDelegate.getLastKey() : keyboardDelegate.getFirstKey();\n      }\n      let dropPositions = horizontal && direction === 'rtl' ? DROP_POSITIONS_RTL : DROP_POSITIONS;\n      let dropPosition: DropPosition = dropPositions[0];\n\n      if (target.type === 'item') {\n        // If the the keyboard delegate returned the next key in the collection,\n        // first try the other positions in the current key. Otherwise (e.g. in a grid layout),\n        // jump to the same drop position in the new key.\n        let nextCollectionKey = horizontal && direction === 'rtl' ? localState.state.collection.getKeyBefore(target.key) : localState.state.collection.getKeyAfter(target.key);\n        if (nextKey == null || nextKey === nextCollectionKey) {\n          let positionIndex = dropPositions.indexOf(target.dropPosition);\n          let nextDropPosition = dropPositions[positionIndex + 1];\n          if (positionIndex < dropPositions.length - 1 && !(nextDropPosition === dropPositions[2] && nextKey != null)) {\n            return {\n              type: 'item',\n              key: target.key,\n              dropPosition: nextDropPosition\n            };\n          }\n\n          // If the last drop position was 'after', then 'before' on the next key is equivalent.\n          // Switch to 'on' instead.\n          if (target.dropPosition === dropPositions[2]) {\n            dropPosition = 'on';\n          }\n        } else {\n          dropPosition = target.dropPosition;\n        }\n      }\n\n      if (nextKey == null) {\n        if (wrap) {\n          return {\n            type: 'root'\n          };\n        }\n\n        return null;\n      }\n\n      return {\n        type: 'item',\n        key: nextKey,\n        dropPosition\n      };\n    };\n\n    let getPreviousTarget = (target: DropTarget, wrap = true, horizontal = false): DropTarget => {\n      let {keyboardDelegate} = localState.props;\n      let nextKey: Key;\n      if (target?.type === 'item') {\n        nextKey = horizontal ? keyboardDelegate.getKeyLeftOf(target.key) : keyboardDelegate.getKeyAbove(target.key);\n      } else {\n        nextKey = horizontal && direction === 'rtl' ? keyboardDelegate.getFirstKey() : keyboardDelegate.getLastKey();\n      }\n      let dropPositions = horizontal && direction === 'rtl' ? DROP_POSITIONS_RTL : DROP_POSITIONS;\n      let dropPosition: DropPosition = !target || target.type === 'root' ? dropPositions[2] : 'on';\n\n      if (target?.type === 'item') {\n        // If the the keyboard delegate returned the previous key in the collection,\n        // first try the other positions in the current key. Otherwise (e.g. in a grid layout),\n        // jump to the same drop position in the new key.\n        let prevCollectionKey = horizontal && direction === 'rtl' ? localState.state.collection.getKeyAfter(target.key) : localState.state.collection.getKeyBefore(target.key);\n        if (nextKey == null || nextKey === prevCollectionKey) {\n          let positionIndex = dropPositions.indexOf(target.dropPosition);\n          let nextDropPosition = dropPositions[positionIndex - 1];\n          if (positionIndex > 0 && nextDropPosition !== dropPositions[2]) {\n            return {\n              type: 'item',\n              key: target.key,\n              dropPosition: nextDropPosition\n            };\n          }\n\n          // If the last drop position was 'before', then 'after' on the previous key is equivalent.\n          // Switch to 'on' instead.\n          if (target.dropPosition === dropPositions[0]) {\n            dropPosition = 'on';\n          }\n        } else {\n          dropPosition = target.dropPosition;\n        }\n      }\n\n      if (nextKey == null) {\n        if (wrap) {\n          return {\n            type: 'root'\n          };\n        }\n\n        return null;\n      }\n\n      return {\n        type: 'item',\n        key: nextKey,\n        dropPosition\n      };\n    };\n\n    let nextValidTarget = (\n      target: DropTarget,\n      types: Set<string>,\n      allowedDropOperations: DropOperation[],\n      getNextTarget: (target: DropTarget, wrap: boolean) => DropTarget,\n      wrap = true\n    ): DropTarget => {\n      let seenRoot = 0;\n      let operation: DropOperation;\n      let {draggingKeys} = globalDndState;\n      let isInternal = isInternalDropOperation(ref);\n      do {\n        let nextTarget = getNextTarget(target, wrap);\n        if (!nextTarget) {\n          return null;\n        }\n        target = nextTarget;\n        operation = localState.state.getDropOperation({target: nextTarget, types, allowedOperations: allowedDropOperations, isInternal, draggingKeys});\n        if (target.type === 'root') {\n          seenRoot++;\n        }\n      } while (\n        operation === 'cancel' &&\n        !localState.state.isDropTarget(target) &&\n        seenRoot < 2\n      );\n\n      if (operation === 'cancel') {\n        return null;\n      }\n\n      return target;\n    };\n\n    return DragManager.registerDropTarget({\n      element: ref.current,\n      getDropOperation(types, allowedOperations) {\n        if (localState.state.target) {\n          let {draggingKeys} = globalDndState;\n          let isInternal = isInternalDropOperation(ref);\n          return localState.state.getDropOperation({target: localState.state.target, types, allowedOperations, isInternal, draggingKeys});\n        }\n\n        // Check if any of the targets accept the drop.\n        // TODO: should we have a faster way of doing this or e.g. for pagination?\n        let target = nextValidTarget(null, types, allowedOperations, getNextTarget);\n        return target ? 'move' : 'cancel';\n      },\n      onDropEnter(e, drag) {\n        let types = getTypes(drag.items);\n        let selectionManager = localState.state.selectionManager;\n        let target: DropTarget;\n        // Update the drop collection ref tracker for useDroppableItem's getDropOperation isInternal check\n        setDropCollectionRef(ref);\n\n        // When entering the droppable collection for the first time, the default drop target\n        // is after the focused key.\n        let key = selectionManager.focusedKey;\n        let dropPosition: DropPosition = 'after';\n\n        // If the focused key is a cell, get the parent item instead.\n        // For now, we assume that individual cells cannot be dropped on.\n        let item = localState.state.collection.getItem(key);\n        if (item?.type === 'cell') {\n          key = item.parentKey;\n        }\n\n        // If the focused item is also selected, the default drop target is after the last selected item.\n        // But if the focused key is the first selected item, then default to before the first selected item.\n        // This is to make reordering lists slightly easier. If you select top down, we assume you want to\n        // move the items down. If you select bottom up, we assume you want to move the items up.\n        if (selectionManager.isSelected(key)) {\n          if (selectionManager.selectedKeys.size > 1 && selectionManager.firstSelectedKey === key) {\n            dropPosition = 'before';\n          } else {\n            key = selectionManager.lastSelectedKey;\n          }\n        }\n\n        if (key != null) {\n          target = {\n            type: 'item',\n            key,\n            dropPosition\n          };\n\n          let {draggingKeys} = globalDndState;\n          let isInternal = isInternalDropOperation(ref);\n          // If the default target is not valid, find the next one that is.\n          if (localState.state.getDropOperation({target, types, allowedOperations: drag.allowedDropOperations, isInternal, draggingKeys}) === 'cancel') {\n            target = nextValidTarget(target, types, drag.allowedDropOperations, getNextTarget, false)\n              ?? nextValidTarget(target, types, drag.allowedDropOperations, getPreviousTarget, false);\n          }\n        }\n\n        // If no focused key, then start from the root.\n        if (!target) {\n          target = nextValidTarget(null, types, drag.allowedDropOperations, getNextTarget);\n        }\n\n        localState.state.setTarget(target);\n      },\n      onDropExit() {\n        setDropCollectionRef(undefined);\n        localState.state.setTarget(null);\n      },\n      onDropTargetEnter(target) {\n        localState.state.setTarget(target);\n      },\n      onDropActivate(e) {\n        if (\n          localState.state.target?.type === 'item' &&\n          localState.state.target?.dropPosition === 'on' &&\n          typeof localState.props.onDropActivate === 'function'\n        ) {\n          localState.props.onDropActivate({\n            type: 'dropactivate',\n            x: e.x, // todo\n            y: e.y,\n            target: localState.state.target\n          });\n        }\n      },\n      onDrop(e, target) {\n        setDropCollectionRef(ref);\n        if (localState.state.target) {\n          onDrop(e, target || localState.state.target);\n        }\n      },\n      onKeyDown(e, drag) {\n        let {keyboardDelegate} = localState.props;\n        let types = getTypes(drag.items);\n        switch (e.key) {\n          case 'ArrowDown': {\n            if (keyboardDelegate.getKeyBelow) {\n              let target = nextValidTarget(localState.state.target, types, drag.allowedDropOperations, getNextTarget);\n              localState.state.setTarget(target);\n            }\n            break;\n          }\n          case 'ArrowUp': {\n            if (keyboardDelegate.getKeyAbove) {\n              let target = nextValidTarget(localState.state.target, types, drag.allowedDropOperations, getPreviousTarget);\n              localState.state.setTarget(target);\n            }\n            break;\n          }\n          case 'ArrowLeft': {\n            if (keyboardDelegate.getKeyLeftOf) {\n              let target = nextValidTarget(localState.state.target, types, drag.allowedDropOperations, (target, wrap) => getPreviousTarget(target, wrap, true));\n              localState.state.setTarget(target);\n            }\n            break;\n          }\n          case 'ArrowRight': {\n            if (keyboardDelegate.getKeyRightOf) {\n              let target = nextValidTarget(localState.state.target, types, drag.allowedDropOperations, (target, wrap) => getNextTarget(target, wrap, true));\n              localState.state.setTarget(target);\n            }\n            break;\n          }\n          case 'Home': {\n            if (keyboardDelegate.getFirstKey) {\n              let target = nextValidTarget(null, types, drag.allowedDropOperations, getNextTarget);\n              localState.state.setTarget(target);\n            }\n            break;\n          }\n          case 'End': {\n            if (keyboardDelegate.getLastKey) {\n              let target = nextValidTarget(null, types, drag.allowedDropOperations, getPreviousTarget);\n              localState.state.setTarget(target);\n            }\n            break;\n          }\n          case 'PageDown': {\n            if (keyboardDelegate.getKeyPageBelow) {\n              let target = localState.state.target;\n              if (!target) {\n                target = nextValidTarget(null, types, drag.allowedDropOperations, getNextTarget);\n              } else {\n                // If on the root, go to the item a page below the top. Otherwise a page below the current item.\n                let nextKey = keyboardDelegate.getKeyPageBelow(\n                  target.type === 'item'\n                    ? target.key\n                    : keyboardDelegate.getFirstKey()\n                );\n                let dropPosition = target.type === 'item' ? target.dropPosition : 'after';\n\n                // If there is no next key, or we are starting on the last key, jump to the last possible position.\n                if (nextKey == null || (target.type === 'item' && target.key === keyboardDelegate.getLastKey())) {\n                  nextKey = keyboardDelegate.getLastKey();\n                  dropPosition = 'after';\n                }\n\n                target = {\n                  type: 'item',\n                  key: nextKey,\n                  dropPosition\n                };\n\n                // If the target does not accept the drop, find the next valid target.\n                // If no next valid target, find the previous valid target.\n                let {draggingCollectionRef, draggingKeys} = globalDndState;\n                let isInternal = draggingCollectionRef?.current === ref?.current;\n                let operation = localState.state.getDropOperation({target, types, allowedOperations: drag.allowedDropOperations, isInternal, draggingKeys});\n                if (operation === 'cancel') {\n                  target = nextValidTarget(target, types, drag.allowedDropOperations, getNextTarget, false)\n                    ?? nextValidTarget(target, types, drag.allowedDropOperations, getPreviousTarget, false);\n                }\n              }\n\n              localState.state.setTarget(target ?? localState.state.target);\n            }\n            break;\n          }\n          case 'PageUp': {\n            if (!keyboardDelegate.getKeyPageAbove) {\n              break;\n            }\n\n            let target = localState.state.target;\n            if (!target) {\n              target = nextValidTarget(null, types, drag.allowedDropOperations, getPreviousTarget);\n            } else if (target.type === 'item') {\n              // If at the top already, switch to the root. Otherwise navigate a page up.\n              if (target.key === keyboardDelegate.getFirstKey()) {\n                target = {\n                  type: 'root'\n                };\n              } else {\n                let nextKey = keyboardDelegate.getKeyPageAbove(target.key);\n                let dropPosition = target.dropPosition;\n                if (nextKey == null) {\n                  nextKey = keyboardDelegate.getFirstKey();\n                  dropPosition = 'before';\n                }\n\n                target = {\n                  type: 'item',\n                  key: nextKey,\n                  dropPosition\n                };\n              }\n\n              // If the target does not accept the drop, find the previous valid target.\n              // If no next valid target, find the next valid target.\n              let {draggingKeys} = globalDndState;\n              let isInternal = isInternalDropOperation(ref);\n              let operation = localState.state.getDropOperation({target, types, allowedOperations: drag.allowedDropOperations, isInternal, draggingKeys});\n              if (operation === 'cancel') {\n                target = nextValidTarget(target, types, drag.allowedDropOperations, getPreviousTarget, false)\n                  ?? nextValidTarget(target, types, drag.allowedDropOperations, getNextTarget, false);\n              }\n            }\n\n            localState.state.setTarget(target ?? localState.state.target);\n            break;\n          }\n        }\n      }\n    });\n  }, [localState, ref, onDrop, direction]);\n\n  let id = useId();\n  droppableCollectionMap.set(state, {id, ref});\n  return {\n    collectionProps: mergeProps(dropProps, {\n      id,\n      // Remove description from collection element. If dropping on the entire collection,\n      // there should be a drop indicator that has this description, so no need to double announce.\n      'aria-describedby': null\n    })\n  };\n}\n","/*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */\n\nimport {getScrollParent, isIOS, isScrollable, isWebKit} from '@react-aria/utils';\nimport {RefObject, useCallback, useEffect, useRef} from 'react';\n\nconst AUTOSCROLL_AREA_SIZE = 20;\n\nexport function useAutoScroll(ref: RefObject<Element>) {\n  let scrollableRef = useRef<Element>(null);\n  let scrollableX = useRef(true);\n  let scrollableY = useRef(true);\n  useEffect(() => {\n    if (ref.current) {\n      scrollableRef.current = isScrollable(ref.current) ? ref.current : getScrollParent(ref.current);\n      let style = window.getComputedStyle(scrollableRef.current);\n      scrollableX.current = /(auto|scroll)/.test(style.overflowX);\n      scrollableY.current = /(auto|scroll)/.test(style.overflowY);\n    }\n  }, [ref]);\n\n  let state = useRef({\n    timer: null,\n    dx: 0,\n    dy: 0\n  }).current;\n\n  useEffect(() => {\n    return () => {\n      if (state.timer) {\n        cancelAnimationFrame(state.timer);\n        state.timer = null;\n      }\n    };\n  // state will become a new object, so it's ok to use in the dependency array for unmount\n  }, [state]);\n\n  let scroll = useCallback(() => {\n    if (scrollableX.current) {\n      scrollableRef.current.scrollLeft += state.dx;\n    }\n    if (scrollableY.current) {\n      scrollableRef.current.scrollTop += state.dy;\n    }\n\n    if (state.timer) {\n      state.timer = requestAnimationFrame(scroll);\n    }\n  }, [scrollableRef, state]);\n\n  return {\n    move(x, y) {\n      // Most browsers auto scroll natively, but WebKit on macOS does not (iOS does 🤷‍♂️).\n      // https://bugs.webkit.org/show_bug.cgi?id=222636\n      if (!isWebKit() || isIOS() || !scrollableRef.current) {\n        return;\n      }\n\n      let box = scrollableRef.current.getBoundingClientRect();\n      let left = AUTOSCROLL_AREA_SIZE;\n      let top = AUTOSCROLL_AREA_SIZE;\n      let bottom = box.height - AUTOSCROLL_AREA_SIZE;\n      let right = box.width - AUTOSCROLL_AREA_SIZE;\n      if (x < left || x > right || y < top || y > bottom) {\n        if (x < left) {\n          state.dx = x - left;\n        } else if (x > right) {\n          state.dx = x - right;\n        }\n        if (y < top) {\n          state.dy = y - top;\n        } else if (y > bottom) {\n          state.dy = y - bottom;\n        }\n\n        if (!state.timer) {\n          state.timer = requestAnimationFrame(scroll);\n        }\n      } else {\n        this.stop();\n      }\n    },\n    stop() {\n      if (state.timer) {\n        cancelAnimationFrame(state.timer);\n        state.timer = null;\n      }\n    }\n  };\n}\n","/*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */\n\nimport * as DragManager from './DragManager';\nimport {DroppableCollectionState} from '@react-stately/dnd';\nimport {DropTarget} from '@react-types/shared';\nimport {getDroppableCollectionRef, getTypes, globalDndState, isInternalDropOperation} from './utils';\nimport {HTMLAttributes, RefObject, useEffect} from 'react';\nimport {useVirtualDrop} from './useVirtualDrop';\n\nexport interface DroppableItemOptions {\n  /** The drop target represented by the item. */\n  target: DropTarget\n}\n\nexport interface DroppableItemResult {\n  /** Props for the droppable element. */\n  dropProps: HTMLAttributes<HTMLElement>,\n  /** Whether the item is currently the active drop target. */\n  isDropTarget: boolean\n}\n\n/**\n * Handles drop interactions for an item within a collection component.\n */\nexport function useDroppableItem(options: DroppableItemOptions, state: DroppableCollectionState, ref: RefObject<HTMLElement>): DroppableItemResult {\n  let {dropProps} = useVirtualDrop();\n  let droppableCollectionRef = getDroppableCollectionRef(state);\n  useEffect(() => {\n    if (ref.current) {\n      return DragManager.registerDropItem({\n        element: ref.current,\n        target: options.target,\n        getDropOperation(types, allowedOperations) {\n          let {draggingKeys} = globalDndState;\n          let isInternal = isInternalDropOperation(droppableCollectionRef);\n          return state.getDropOperation({\n            target: options.target,\n            types,\n            allowedOperations,\n            isInternal,\n            draggingKeys\n          });\n        }\n      });\n    }\n  }, [ref, options.target, state, droppableCollectionRef]);\n\n  let dragSession = DragManager.useDragSession();\n  let {draggingKeys} = globalDndState;\n  let isInternal = isInternalDropOperation(droppableCollectionRef);\n  let isValidDropTarget = dragSession && state.getDropOperation({\n    target: options.target,\n    types: getTypes(dragSession.dragTarget.items),\n    allowedOperations: dragSession.dragTarget.allowedDropOperations,\n    isInternal,\n    draggingKeys\n  }) !== 'cancel';\n\n  let isDropTarget = state.isDropTarget(options.target);\n  useEffect(() => {\n    if (dragSession && isDropTarget && ref.current) {\n      ref.current.focus();\n    }\n  }, [isDropTarget, dragSession, ref]);\n\n  return {\n    dropProps: {\n      ...dropProps,\n      'aria-hidden': !dragSession || isValidDropTarget ? undefined : 'true'\n    },\n    isDropTarget\n  };\n}\n","/*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */\n\nimport * as DragManager from './DragManager';\nimport {DroppableCollectionState} from '@react-stately/dnd';\nimport {DropTarget, Key} from '@react-types/shared';\nimport {getDroppableCollectionId} from './utils';\nimport {HTMLAttributes, RefObject} from 'react';\n// @ts-ignore\nimport intlMessages from '../intl/*.json';\nimport {useDroppableItem} from './useDroppableItem';\nimport {useId} from '@react-aria/utils';\nimport {useLocalizedStringFormatter} from '@react-aria/i18n';\n\nexport interface DropIndicatorProps {\n  /** The drop target that the drop indicator represents. */\n  target: DropTarget\n}\n\nexport interface DropIndicatorAria {\n  /** Props for the drop indicator element. */\n  dropIndicatorProps: HTMLAttributes<HTMLElement>,\n  /** Whether the drop indicator is currently the active drop target. */\n  isDropTarget: boolean,\n  /**\n   * Whether the drop indicator is hidden, both visually and from assistive technology.\n   * Use this to determine whether to omit the element from the DOM entirely.\n   */\n  isHidden: boolean\n}\n\n/**\n * Handles drop interactions for a target within a droppable collection.\n */\nexport function useDropIndicator(props: DropIndicatorProps, state: DroppableCollectionState, ref: RefObject<HTMLElement>): DropIndicatorAria {\n  let {target} = props;\n  let {collection} = state;\n\n  let stringFormatter = useLocalizedStringFormatter(intlMessages, '@react-aria/dnd');\n  let dragSession = DragManager.useDragSession();\n  let {dropProps} = useDroppableItem(props, state, ref);\n  let id = useId();\n  let getText = (key: Key) => collection.getTextValue?.(key) ?? collection.getItem(key)?.textValue;\n\n  let label = '';\n  let labelledBy: string;\n  if (target.type === 'root') {\n    label = stringFormatter.format('dropOnRoot');\n    labelledBy = `${id} ${getDroppableCollectionId(state)}`;\n  } else if (target.dropPosition === 'on') {\n    label = stringFormatter.format('dropOnItem', {\n      itemText: getText(target.key)\n    });\n  } else {\n    let before: Key | null;\n    let after: Key | null;\n    if (collection.getFirstKey() === target.key && target.dropPosition === 'before') {\n      before = null;\n    } else {\n      before = target.dropPosition === 'before' ? collection.getKeyBefore(target.key) : target.key;\n    }\n\n    if (collection.getLastKey() === target.key && target.dropPosition === 'after') {\n      after = null;\n    } else {\n      after = target.dropPosition === 'after' ? collection.getKeyAfter(target.key) : target.key;\n    }\n\n    if (before && after) {\n      label = stringFormatter.format('insertBetween', {\n        beforeItemText: getText(before),\n        afterItemText: getText(after)\n      });\n    } else if (before) {\n      label = stringFormatter.format('insertAfter', {\n        itemText: getText(before)\n      });\n    } else if (after) {\n      label = stringFormatter.format('insertBefore', {\n        itemText: getText(after)\n      });\n    }\n  }\n\n  let isDropTarget = state.isDropTarget(target);\n  let ariaHidden = !dragSession ? 'true' : dropProps['aria-hidden'];\n  return {\n    dropIndicatorProps: {\n      ...dropProps,\n      id,\n      'aria-roledescription': stringFormatter.format('dropIndicator'),\n      'aria-label': label,\n      'aria-labelledby': labelledBy,\n      'aria-hidden': ariaHidden,\n      tabIndex: -1\n    },\n    isDropTarget,\n    // If aria-hidden, we are either not in a drag session or the drop target is invalid.\n    // In that case, there's no need to render anything at all unless we need to show the indicator visually.\n    // This can happen when dragging using the native DnD API as opposed to keyboard dragging.\n    isHidden: !isDropTarget && !!ariaHidden\n  };\n}\n","/*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */\n\nimport {AriaButtonProps} from '@react-types/button';\nimport {clearGlobalDnDState, isInternalDropOperation, setDraggingKeys, useDragModality} from './utils';\nimport {DraggableCollectionState} from '@react-stately/dnd';\nimport {HTMLAttributes} from 'react';\n// @ts-ignore\nimport intlMessages from '../intl/*.json';\nimport {Key} from '@react-types/shared';\nimport {useDescription} from '@react-aria/utils';\nimport {useDrag} from './useDrag';\nimport {useLocalizedStringFormatter} from '@react-aria/i18n';\n\nexport interface DraggableItemProps {\n  /** The key of the draggable item within the collection. */\n  key: Key,\n  /**\n   * Whether the item has an explicit focusable drag affordance to initiate accessible drag and drop mode.\n   * If true, the dragProps will omit these event handlers, and they will be applied to dragButtonProps instead.\n   */\n  hasDragButton?: boolean,\n  /**\n   * Whether the item has a primary action (e.g. Enter key or long press) that would\n   * conflict with initiating accessible drag and drop. If true, the Alt key must be held to\n   * start dragging with a keyboard, and long press is disabled until selection mode is entered.\n   * This should be passed from the associated collection item hook (e.g. useOption, useGridListItem, etc.).\n   */\n  hasAction?: boolean\n}\n\nexport interface DraggableItemResult {\n  /** Props for the draggable item. */\n  dragProps: HTMLAttributes<HTMLElement>,\n  /** Props for the explicit drag button affordance, if any. */\n  dragButtonProps: AriaButtonProps\n}\n\nconst MESSAGES = {\n  keyboard: {\n    selected: 'dragSelectedKeyboard',\n    notSelected: 'dragDescriptionKeyboard'\n  },\n  touch: {\n    selected: 'dragSelectedLongPress',\n    notSelected: 'dragDescriptionLongPress'\n  },\n  virtual: {\n    selected: 'dragDescriptionVirtual',\n    notSelected: 'dragDescriptionVirtual'\n  }\n};\n\n/**\n * Handles drag interactions for an item within a draggable collection.\n */\nexport function useDraggableItem(props: DraggableItemProps, state: DraggableCollectionState): DraggableItemResult {\n  let stringFormatter = useLocalizedStringFormatter(intlMessages, '@react-aria/dnd');\n  let isDisabled = state.selectionManager.isDisabled(props.key);\n  let {dragProps, dragButtonProps} = useDrag({\n    getItems() {\n      return state.getItems(props.key);\n    },\n    preview: state.preview,\n    getAllowedDropOperations: state.getAllowedDropOperations,\n    hasDragButton: props.hasDragButton,\n    onDragStart(e) {\n      state.startDrag(props.key, e);\n      // Track draggingKeys for useDroppableCollection's default onDrop handler and useDroppableCollectionState's default getDropOperation\n      setDraggingKeys(state.draggingKeys);\n    },\n    onDragMove(e) {\n      state.moveDrag(e);\n    },\n    onDragEnd(e) {\n      let {dropOperation} = e;\n      let isInternal = dropOperation === 'cancel' ? false : isInternalDropOperation();\n      state.endDrag({...e, keys: state.draggingKeys, isInternal});\n      clearGlobalDnDState();\n    }\n  });\n\n  let item = state.collection.getItem(props.key);\n  let numKeysForDrag = state.getKeysForDrag(props.key).size;\n  let isSelected = numKeysForDrag > 1 && state.selectionManager.isSelected(props.key);\n  let dragButtonLabel: string;\n  let description: string;\n\n  // Override description to include selected item count.\n  let modality = useDragModality();\n  if (!props.hasDragButton && state.selectionManager.selectionMode !== 'none') {\n    let msg = MESSAGES[modality][isSelected ? 'selected' : 'notSelected'];\n    if (props.hasAction && modality === 'keyboard') {\n      msg += 'Alt';\n    }\n\n    if (isSelected) {\n      description = stringFormatter.format(msg, {count: numKeysForDrag});\n    } else {\n      description = stringFormatter.format(msg);\n    }\n\n    // Remove the onClick handler from useDrag. Long pressing will be required on touch devices,\n    // and NVDA/JAWS are always in forms mode within collection components.\n    delete dragProps.onClick;\n  } else {\n    if (isSelected) {\n      dragButtonLabel = stringFormatter.format('dragSelectedItems', {count: numKeysForDrag});\n    } else {\n      let itemText = state.collection.getTextValue?.(props.key) ?? item?.textValue ?? '';\n      dragButtonLabel = stringFormatter.format('dragItem', {itemText});\n    }\n  }\n\n  let descriptionProps = useDescription(description);\n  if (description) {\n    Object.assign(dragProps, descriptionProps);\n  }\n\n  if (!props.hasDragButton && props.hasAction) {\n    let {onKeyDownCapture, onKeyUpCapture} = dragProps;\n    if (modality === 'touch') {\n      // Remove long press description if an action is present, because in that case long pressing selects the item.\n      delete dragProps['aria-describedby'];\n    }\n\n    // Require Alt key if there is a conflicting action.\n    dragProps.onKeyDownCapture = e => {\n      if (e.altKey) {\n        onKeyDownCapture(e);\n      }\n    };\n\n    dragProps.onKeyUpCapture = e => {\n      if (e.altKey) {\n        onKeyUpCapture(e);\n      }\n    };\n  }\n\n  return {\n    dragProps: isDisabled ? {} : dragProps,\n    dragButtonProps: {\n      ...dragButtonProps,\n      isDisabled,\n      'aria-label': dragButtonLabel\n    }\n  };\n}\n","/*\n * Copyright 2022 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */\n\nimport {DraggableCollectionState} from '@react-stately/dnd';\nimport {globalDndState, setDraggingCollectionRef} from './utils';\nimport {RefObject} from 'react';\n\nexport interface DraggableCollectionOptions {}\n\n/**\n * Handles drag interactions for a collection component, with support for traditional mouse and touch\n * based drag and drop, in addition to full parity for keyboard and screen reader users.\n */\nexport function useDraggableCollection(props: DraggableCollectionOptions, state: DraggableCollectionState, ref: RefObject<HTMLElement>): void {\n  // Update global DnD state if this keys within this collection are dragged\n  let {draggingCollectionRef} = globalDndState;\n  if  (state.draggingKeys.size > 0 && draggingCollectionRef?.current !== ref.current) {\n    setDraggingCollectionRef(ref);\n  }\n}\n","/*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */\n\nimport {chain, useEffectEvent} from '@react-aria/utils';\nimport {DOMAttributes, DragItem, DropItem} from '@react-types/shared';\nimport {readFromDataTransfer, writeToDataTransfer} from './utils';\nimport {useEffect, useRef} from 'react';\nimport {useFocus} from '@react-aria/interactions';\n\nexport interface ClipboardProps {\n  /** A function that returns the items to copy. */\n  getItems?: () => DragItem[],\n  /** Handler that is called when the user triggers a copy interaction. */\n  onCopy?: () => void,\n  /** Handler that is called when the user triggers a cut interaction. */\n  onCut?: () => void,\n  /** Handler that is called when the user triggers a paste interaction. */\n  onPaste?: (items: DropItem[]) => void\n}\n\nexport interface ClipboardResult {\n  /** Props for the element that will handle clipboard events. */\n  clipboardProps: DOMAttributes\n}\n\nconst globalEvents = new Map();\nfunction addGlobalEventListener(event, fn) {\n  let eventData = globalEvents.get(event);\n  if (!eventData) {\n    let handlers = new Set<(e: Event) => void>();\n    let listener = (e) => {\n      for (let handler of handlers) {\n        handler(e);\n      }\n    };\n\n    eventData = {listener, handlers};\n    globalEvents.set(event, eventData);\n\n    document.addEventListener(event, listener);\n  }\n\n  eventData.handlers.add(fn);\n  return () => {\n    eventData.handlers.delete(fn);\n    if (eventData.handlers.size === 0) {\n      document.removeEventListener(event, eventData.listener);\n      globalEvents.delete(event);\n    }\n  };\n}\n\n/**\n * Handles clipboard interactions for a focusable element. Supports items of multiple\n * data types, and integrates with the operating system native clipboard.\n */\nexport function useClipboard(options: ClipboardProps): ClipboardResult {\n  let isFocusedRef = useRef(false);\n  let {focusProps} = useFocus({\n    onFocusChange: (isFocused) => {\n      isFocusedRef.current = isFocused;\n    }\n  });\n\n  let onBeforeCopy = useEffectEvent((e: ClipboardEvent) => {\n    // Enable the \"Copy\" menu item in Safari if this element is focused and copying is supported.\n    if (isFocusedRef.current && options.getItems) {\n      e.preventDefault();\n    }\n  });\n\n  let onCopy = useEffectEvent((e: ClipboardEvent) => {\n    if (!isFocusedRef.current || !options.getItems) {\n      return;\n    }\n\n    e.preventDefault();\n    writeToDataTransfer(e.clipboardData, options.getItems());\n    options.onCopy?.();\n  });\n\n  let onBeforeCut = useEffectEvent((e: ClipboardEvent) => {\n    if (isFocusedRef.current && options.onCut && options.getItems) {\n      e.preventDefault();\n    }\n  });\n\n  let onCut = useEffectEvent((e: ClipboardEvent) => {\n    if (!isFocusedRef.current || !options.onCut || !options.getItems) {\n      return;\n    }\n\n    e.preventDefault();\n    writeToDataTransfer(e.clipboardData, options.getItems());\n    options.onCut();\n  });\n\n  let onBeforePaste = useEffectEvent((e: ClipboardEvent) => {\n    // Unfortunately, e.clipboardData.types is not available in this event so we always\n    // have to enable the Paste menu item even if the type of data is unsupported.\n    if (isFocusedRef.current && options.onPaste) {\n      e.preventDefault();\n    }\n  });\n\n  let onPaste = useEffectEvent((e: ClipboardEvent) => {\n    if (!isFocusedRef.current || !options.onPaste) {\n      return;\n    }\n\n    e.preventDefault();\n    let items = readFromDataTransfer(e.clipboardData);\n    options.onPaste(items);\n  });\n\n  useEffect(() => {\n    return chain(\n      addGlobalEventListener('beforecopy', onBeforeCopy),\n      addGlobalEventListener('copy', onCopy),\n      addGlobalEventListener('beforecut', onBeforeCut),\n      addGlobalEventListener('cut', onCut),\n      addGlobalEventListener('beforepaste', onBeforePaste),\n      addGlobalEventListener('paste', onPaste)\n    );\n  }, [onBeforeCopy, onCopy, onBeforeCut, onCut, onBeforePaste, onPaste]);\n\n  return {\n    clipboardProps: focusProps\n  };\n}\n","/*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */\n\nimport {DragItem, DragPreviewRenderer} from '@react-types/shared';\nimport {flushSync} from 'react-dom';\nimport React, {JSX, RefObject, useImperativeHandle, useRef, useState} from 'react';\n\nexport interface DragPreviewProps {\n  children: (items: DragItem[]) => JSX.Element\n}\n\nfunction DragPreview(props: DragPreviewProps, ref: RefObject<DragPreviewRenderer>) {\n  let render = props.children;\n  let [children, setChildren] = useState<JSX.Element>(null);\n  let domRef = useRef(null);\n\n  useImperativeHandle(ref, () => (items: DragItem[], callback: (node: HTMLElement) => void) => {\n    // This will be called during the onDragStart event by useDrag. We need to render the\n    // preview synchronously before this event returns so we can call event.dataTransfer.setDragImage.\n    flushSync(() => {\n      setChildren(render(items));\n    });\n\n    // Yield back to useDrag to set the drag image.\n    callback(domRef.current);\n\n    // Remove the preview from the DOM after a frame so the browser has time to paint.\n    requestAnimationFrame(() => {\n      setChildren(null);\n    });\n  }, [render]);\n\n  if (!children) {\n    return null;\n  }\n\n  return (\n    <div style={{zIndex: -100, position: 'absolute', top: 0, left: -100000}} ref={domRef}>\n      {children}\n    </div>\n  );\n}\n\nlet _DragPreview = React.forwardRef(DragPreview);\nexport {_DragPreview as DragPreview};\n","import {Collection, Direction, DropTarget, DropTargetDelegate, Node, Orientation} from '@react-types/shared';\nimport {RefObject} from 'react';\n\ninterface ListDropTargetDelegateOptions {\n  /**\n   * Whether the items are arranged in a stack or grid.\n   * @default 'stack'\n   */\n  layout?: 'stack' | 'grid',\n  /**\n   * The primary orientation of the items. Usually this is the\n   * direction that the collection scrolls.\n   * @default 'vertical'\n   */\n  orientation?: Orientation,\n  /**\n   * The horizontal layout direction.\n   * @default 'ltr'\n   */\n  direction?: Direction\n}\n\n// Terms used in the below code:\n//   * \"Primary\"   – The main layout direction. For stacks, this is the direction\n//                   that the stack is arranged in (e.g. horizontal or vertical).\n//                   For grids, this is the main scroll direction.\n//   * \"Secondary\" – The secondary layout direction. For stacks, there is no secondary\n//                   layout direction. For grids, this is the opposite of the primary direction.\n//   * \"Flow\"      – The flow direction of the items. For stacks, this is the the primary\n//                   direction. For grids, it is the secondary direction.\n\nexport class ListDropTargetDelegate implements DropTargetDelegate {\n  private collection: Collection<Node<unknown>>;\n  private ref: RefObject<HTMLElement>;\n  private layout: 'stack' | 'grid';\n  private orientation: Orientation;\n  private direction: Direction;\n\n  constructor(collection: Collection<Node<unknown>>, ref: RefObject<HTMLElement>, options?: ListDropTargetDelegateOptions) {\n    this.collection = collection;\n    this.ref = ref;\n    this.layout = options?.layout || 'stack';\n    this.orientation = options?.orientation || 'vertical';\n    this.direction = options?.direction || 'ltr';\n  }\n\n  private getPrimaryStart(rect: DOMRect) {\n    return this.orientation === 'horizontal' ? rect.left : rect.top;\n  }\n\n  private getPrimaryEnd(rect: DOMRect) {\n    return this.orientation === 'horizontal' ? rect.right : rect.bottom;\n  }\n\n  private getSecondaryStart(rect: DOMRect) {\n    return this.orientation === 'horizontal' ? rect.top : rect.left;\n  }\n\n  private getSecondaryEnd(rect: DOMRect) {\n    return this.orientation === 'horizontal' ? rect.bottom : rect.right;\n  }\n\n  private getFlowStart(rect: DOMRect) {\n    return this.layout === 'stack' ? this.getPrimaryStart(rect) : this.getSecondaryStart(rect);\n  }\n\n  private getFlowEnd(rect: DOMRect) {\n    return this.layout === 'stack' ? this.getPrimaryEnd(rect) : this.getSecondaryEnd(rect);\n  }\n\n  private getFlowSize(rect: DOMRect) {\n    return this.getFlowEnd(rect) - this.getFlowStart(rect);\n  }\n\n  getDropTargetFromPoint(x: number, y: number, isValidDropTarget: (target: DropTarget) => boolean): DropTarget {\n    if (this.collection.size === 0) {\n      return {type: 'root'};\n    }\n\n    let rect = this.ref.current.getBoundingClientRect();\n    let primary = this.orientation === 'horizontal' ? x : y;\n    let secondary = this.orientation === 'horizontal' ? y : x;\n    primary += this.getPrimaryStart(rect);\n    secondary += this.getSecondaryStart(rect);\n\n    let flow = this.layout === 'stack' ? primary : secondary;\n    let isPrimaryRTL = this.orientation === 'horizontal' && this.direction === 'rtl';\n    let isSecondaryRTL = this.layout === 'grid' && this.orientation === 'vertical' && this.direction === 'rtl';\n    let isFlowRTL = this.layout === 'stack' ? isPrimaryRTL : isSecondaryRTL;\n\n    let elements = this.ref.current.querySelectorAll('[data-key]');\n    let elementMap = new Map<string, HTMLElement>();\n    for (let item of elements) {\n      if (item instanceof HTMLElement) {\n        elementMap.set(item.dataset.key, item);\n      }\n    }\n\n    let items = [...this.collection];\n    let low = 0;\n    let high = items.length;\n    while (low < high) {\n      let mid = Math.floor((low + high) / 2);\n      let item = items[mid];\n      let element = elementMap.get(String(item.key));\n      let rect = element.getBoundingClientRect();\n      let update = (isGreater: boolean) => {\n        if (isGreater) {\n          low = mid + 1;\n        } else {\n          high = mid;\n        }\n      };\n\n      if (primary < this.getPrimaryStart(rect)) {\n        update(isPrimaryRTL);\n      } else if (primary > this.getPrimaryEnd(rect)) {\n        update(!isPrimaryRTL);\n      } else if (secondary < this.getSecondaryStart(rect)) {\n        update(isSecondaryRTL);\n      } else if (secondary > this.getSecondaryEnd(rect)) {\n        update(!isSecondaryRTL);\n      } else {\n        let target: DropTarget = {\n          type: 'item',\n          key: item.key,\n          dropPosition: 'on'\n        };\n\n        if (isValidDropTarget(target)) {\n          // Otherwise, if dropping on the item is accepted, try the before/after positions if within 5px\n          // of the start or end of the item.\n          if (flow <= this.getFlowStart(rect) + 5 && isValidDropTarget({...target, dropPosition: 'before'})) {\n            target.dropPosition = isFlowRTL ? 'after' : 'before';\n          } else if (flow >= this.getFlowEnd(rect) - 5 && isValidDropTarget({...target, dropPosition: 'after'})) {\n            target.dropPosition = isFlowRTL ? 'before' : 'after';\n          }\n        } else {\n          // If dropping on the item isn't accepted, try the target before or after depending on the position.\n          let mid = this.getFlowStart(rect) + this.getFlowSize(rect) / 2;\n          if (flow <= mid && isValidDropTarget({...target, dropPosition: 'before'})) {\n            target.dropPosition = isFlowRTL ? 'after' : 'before';\n          } else if (flow >= mid && isValidDropTarget({...target, dropPosition: 'after'})) {\n            target.dropPosition = isFlowRTL ? 'before' : 'after';\n          }\n        }\n\n        return target;\n      }\n    }\n\n    let item = items[Math.min(low, items.length - 1)];\n    let element = elementMap.get(String(item.key));\n    rect = element.getBoundingClientRect();\n\n    if (primary < this.getPrimaryStart(rect) || Math.abs(flow - this.getFlowStart(rect)) < Math.abs(flow - this.getFlowEnd(rect))) {\n      return {\n        type: 'item',\n        key: item.key,\n        dropPosition: isFlowRTL ? 'after' : 'before'\n      };\n    }\n\n    return {\n      type: 'item',\n      key: item.key,\n      dropPosition: isFlowRTL ? 'before' : 'after'\n    };\n  }\n}\n"],"names":[],"version":3,"file":"main.js.map"}